import {
  Buffer,
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  buffer_exports,
  dew,
  dew$7,
  dew$e,
  empty_exports,
  events_exports,
  http_exports,
  https_exports,
  init_buffer,
  init_buffer2,
  init_chunk_DEMDiNwt,
  init_chunk_DtcTpLWz,
  init_empty,
  init_events,
  init_http,
  init_https,
  init_stream,
  init_util,
  process as process2,
  require_core,
  stream_exports,
  util_exports
} from "./chunk-WDST5WCP.js";

// ../binding-http/node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "../binding-http/node_modules/node-fetch/browser.js"(exports5, module) {
    "use strict";
    init_buffer2();
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject = getGlobal();
    module.exports = exports5 = globalObject.fetch;
    if (globalObject.fetch) {
      exports5.default = globalObject.fetch.bind(globalObject);
    }
    exports5.Headers = globalObject.Headers;
    exports5.Request = globalObject.Request;
    exports5.Response = globalObject.Response;
  }
});

// ../../node_modules/rxjs/util/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/rxjs/util/isArray.js"(exports5) {
    "use strict";
    init_buffer2();
    exports5.isArray = Array.isArray || function(x) {
      return x && typeof x.length === "number";
    };
  }
});

// ../../node_modules/rxjs/util/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/rxjs/util/isObject.js"(exports5) {
    "use strict";
    init_buffer2();
    function isObject(x) {
      return x != null && typeof x === "object";
    }
    exports5.isObject = isObject;
  }
});

// ../../node_modules/rxjs/util/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/rxjs/util/isFunction.js"(exports5) {
    "use strict";
    init_buffer2();
    function isFunction(x) {
      return typeof x === "function";
    }
    exports5.isFunction = isFunction;
  }
});

// ../../node_modules/rxjs/util/errorObject.js
var require_errorObject = __commonJS({
  "../../node_modules/rxjs/util/errorObject.js"(exports5) {
    "use strict";
    init_buffer2();
    exports5.errorObject = { e: {} };
  }
});

// ../../node_modules/rxjs/util/tryCatch.js
var require_tryCatch = __commonJS({
  "../../node_modules/rxjs/util/tryCatch.js"(exports5) {
    "use strict";
    init_buffer2();
    var errorObject_1 = require_errorObject();
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
      }
    }
    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }
    exports5.tryCatch = tryCatch;
  }
});

// ../../node_modules/rxjs/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS({
  "../../node_modules/rxjs/util/UnsubscriptionError.js"(exports5) {
    "use strict";
    init_buffer2();
    var __extends = exports5 && exports5.__extends || function(d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var UnsubscriptionError = function(_super) {
      __extends(UnsubscriptionError2, _super);
      function UnsubscriptionError2(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function(err2, i) {
          return i + 1 + ") " + err2.toString();
        }).join("\n  ") : "");
        this.name = err.name = "UnsubscriptionError";
        this.stack = err.stack;
        this.message = err.message;
      }
      return UnsubscriptionError2;
    }(Error);
    exports5.UnsubscriptionError = UnsubscriptionError;
  }
});

// ../../node_modules/rxjs/Subscription.js
var require_Subscription = __commonJS({
  "../../node_modules/rxjs/Subscription.js"(exports5) {
    "use strict";
    init_buffer2();
    var isArray_1 = require_isArray();
    var isObject_1 = require_isObject();
    var isFunction_1 = require_isFunction();
    var tryCatch_1 = require_tryCatch();
    var errorObject_1 = require_errorObject();
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    var Subscription = function() {
      function Subscription2(unsubscribe) {
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
          this._unsubscribe = unsubscribe;
        }
      }
      Subscription2.prototype.unsubscribe = function() {
        var hasErrors = false;
        var errors;
        if (this.closed) {
          return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        while (_parent) {
          _parent.remove(this);
          _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
          var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
          if (trial === errorObject_1.errorObject) {
            hasErrors = true;
            errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
          }
        }
        if (isArray_1.isArray(_subscriptions)) {
          index = -1;
          len = _subscriptions.length;
          while (++index < len) {
            var sub = _subscriptions[index];
            if (isObject_1.isObject(sub)) {
              var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
              if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || [];
                var err = errorObject_1.errorObject.e;
                if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          }
        }
        if (hasErrors) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
      };
      Subscription2.prototype.add = function(teardown) {
        if (!teardown || teardown === Subscription2.EMPTY) {
          return Subscription2.EMPTY;
        }
        if (teardown === this) {
          return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
          case "function":
            subscription = new Subscription2(teardown);
          case "object":
            if (subscription.closed || typeof subscription.unsubscribe !== "function") {
              return subscription;
            } else if (this.closed) {
              subscription.unsubscribe();
              return subscription;
            } else if (typeof subscription._addParent !== "function") {
              var tmp = subscription;
              subscription = new Subscription2();
              subscription._subscriptions = [tmp];
            }
            break;
          default:
            throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
      };
      Subscription2.prototype.remove = function(subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
          var subscriptionIndex = subscriptions.indexOf(subscription);
          if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
          }
        }
      };
      Subscription2.prototype._addParent = function(parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
          this._parent = parent;
        } else if (!_parents) {
          this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
          _parents.push(parent);
        }
      };
      Subscription2.EMPTY = function(empty2) {
        empty2.closed = true;
        return empty2;
      }(new Subscription2());
      return Subscription2;
    }();
    exports5.Subscription = Subscription;
    function flattenUnsubscriptionErrors(errors) {
      return errors.reduce(function(errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
      }, []);
    }
  }
});

// (disabled):../../node_modules/client-oauth2/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "(disabled):../../node_modules/client-oauth2/node_modules/safe-buffer/index.js"() {
    init_buffer2();
  }
});

// ../../node_modules/@jspm/core/nodelibs/browser/querystring.js
var querystring_exports = {};
__export(querystring_exports, {
  decode: () => decode,
  default: () => exports,
  encode: () => encode,
  parse: () => parse,
  stringify: () => stringify
});
function dew$2() {
  if (_dewExec$2) return exports$3;
  _dewExec$2 = true;
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  exports$3 = function(qs, sep, eq, options) {
    sep = sep || "&";
    eq = eq || "=";
    var obj = {};
    if (typeof qs !== "string" || qs.length === 0) {
      return obj;
    }
    var regexp = /\+/g;
    qs = qs.split(sep);
    var maxKeys = 1e3;
    if (options && typeof options.maxKeys === "number") {
      maxKeys = options.maxKeys;
    }
    var len = qs.length;
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }
    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = "";
      }
      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);
      if (!hasOwnProperty(obj, k)) {
        obj[k] = v;
      } else if (Array.isArray(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }
    return obj;
  };
  return exports$3;
}
function dew$1() {
  if (_dewExec$1) return exports$2;
  _dewExec$1 = true;
  var stringifyPrimitive = function(v) {
    switch (typeof v) {
      case "string":
        return v;
      case "boolean":
        return v ? "true" : "false";
      case "number":
        return isFinite(v) ? v : "";
      default:
        return "";
    }
  };
  exports$2 = function(obj, sep, eq, name) {
    sep = sep || "&";
    eq = eq || "=";
    if (obj === null) {
      obj = void 0;
    }
    if (typeof obj === "object") {
      return Object.keys(obj).map(function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (Array.isArray(obj[k])) {
          return obj[k].map(function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).filter(Boolean).join(sep);
    }
    if (!name) return "";
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
  };
  return exports$2;
}
function dew2() {
  if (_dewExec) return exports$1;
  _dewExec = true;
  exports$1.decode = exports$1.parse = dew$2();
  exports$1.encode = exports$1.stringify = dew$1();
  return exports$1;
}
var exports$3, _dewExec$2, exports$2, _dewExec$1, exports$1, _dewExec, exports, decode, encode, parse, stringify;
var init_querystring = __esm({
  "../../node_modules/@jspm/core/nodelibs/browser/querystring.js"() {
    init_buffer2();
    exports$3 = {};
    _dewExec$2 = false;
    exports$2 = {};
    _dewExec$1 = false;
    exports$1 = {};
    _dewExec = false;
    exports = dew2();
    exports["decode"];
    exports["parse"];
    exports["encode"];
    exports["stringify"];
    decode = exports.decode;
    encode = exports.encode;
    parse = exports.parse;
    stringify = exports.stringify;
  }
});

// ../../node_modules/client-oauth2/src/request/browser.js
var require_browser2 = __commonJS({
  "../../node_modules/client-oauth2/src/request/browser.js"(exports5, module) {
    init_buffer2();
    module.exports = function request(method, url, body, headers) {
      return new Promise(function(resolve2, reject) {
        var xhr = new window.XMLHttpRequest();
        xhr.open(method, url);
        xhr.onload = function() {
          return resolve2({
            status: xhr.status,
            body: xhr.responseText
          });
        };
        xhr.onerror = xhr.onabort = function() {
          return reject(new Error(xhr.statusText || "XHR aborted: " + url));
        };
        Object.keys(headers).forEach(function(header) {
          xhr.setRequestHeader(header, headers[header]);
        });
        xhr.send(body);
      });
    };
  }
});

// ../../node_modules/client-oauth2/src/client-oauth2.js
var require_client_oauth2 = __commonJS({
  "../../node_modules/client-oauth2/src/client-oauth2.js"(exports5, module) {
    init_buffer2();
    var Buffer2 = require_safe_buffer().Buffer;
    var Querystring = (init_querystring(), __toCommonJS(querystring_exports));
    var defaultRequest = require_browser2();
    var DEFAULT_URL_BASE = "https://example.org/";
    var btoa;
    if (typeof Buffer2 === "function") {
      btoa = btoaBuffer;
    } else {
      btoa = window.btoa.bind(window);
    }
    module.exports = ClientOAuth2;
    var DEFAULT_HEADERS = {
      Accept: "application/json, application/x-www-form-urlencoded",
      "Content-Type": "application/x-www-form-urlencoded"
    };
    var ERROR_RESPONSES = {
      invalid_request: [
        "The request is missing a required parameter, includes an",
        "invalid parameter value, includes a parameter more than",
        "once, or is otherwise malformed."
      ].join(" "),
      invalid_client: [
        "Client authentication failed (e.g., unknown client, no",
        "client authentication included, or unsupported",
        "authentication method)."
      ].join(" "),
      invalid_grant: [
        "The provided authorization grant (e.g., authorization",
        "code, resource owner credentials) or refresh token is",
        "invalid, expired, revoked, does not match the redirection",
        "URI used in the authorization request, or was issued to",
        "another client."
      ].join(" "),
      unauthorized_client: [
        "The client is not authorized to request an authorization",
        "code using this method."
      ].join(" "),
      unsupported_grant_type: [
        "The authorization grant type is not supported by the",
        "authorization server."
      ].join(" "),
      access_denied: [
        "The resource owner or authorization server denied the request."
      ].join(" "),
      unsupported_response_type: [
        "The authorization server does not support obtaining",
        "an authorization code using this method."
      ].join(" "),
      invalid_scope: [
        "The requested scope is invalid, unknown, or malformed."
      ].join(" "),
      server_error: [
        "The authorization server encountered an unexpected",
        "condition that prevented it from fulfilling the request.",
        "(This error code is needed because a 500 Internal Server",
        "Error HTTP status code cannot be returned to the client",
        "via an HTTP redirect.)"
      ].join(" "),
      temporarily_unavailable: [
        "The authorization server is currently unable to handle",
        "the request due to a temporary overloading or maintenance",
        "of the server."
      ].join(" ")
    };
    function btoaBuffer(string) {
      return Buffer2.from(string).toString("base64");
    }
    function expects(obj) {
      for (var i = 1; i < arguments.length; i++) {
        var prop = arguments[i];
        if (obj[prop] == null) {
          throw new TypeError('Expected "' + prop + '" to exist');
        }
      }
    }
    function getAuthError(body) {
      var message = ERROR_RESPONSES[body.error] || body.error_description || body.error;
      if (message) {
        var err = new Error(message);
        err.body = body;
        err.code = "EAUTH";
        return err;
      }
    }
    function parseResponseBody(body) {
      try {
        return JSON.parse(body);
      } catch (e) {
        return Querystring.parse(body);
      }
    }
    function sanitizeScope(scopes) {
      return Array.isArray(scopes) ? scopes.join(" ") : toString(scopes);
    }
    function createUri(options, tokenType) {
      expects(options, "clientId", "authorizationUri");
      const qs = {
        client_id: options.clientId,
        redirect_uri: options.redirectUri,
        response_type: tokenType,
        state: options.state
      };
      if (options.scopes !== void 0) {
        qs.scope = sanitizeScope(options.scopes);
      }
      const sep = options.authorizationUri.includes("?") ? "&" : "?";
      return options.authorizationUri + sep + Querystring.stringify(
        Object.assign(qs, options.query)
      );
    }
    function auth(username, password) {
      return "Basic " + btoa(toString(username) + ":" + toString(password));
    }
    function toString(str) {
      return str == null ? "" : String(str);
    }
    function requestOptions(requestOptions2, options) {
      return {
        url: requestOptions2.url,
        method: requestOptions2.method,
        body: Object.assign({}, requestOptions2.body, options.body),
        query: Object.assign({}, requestOptions2.query, options.query),
        headers: Object.assign({}, requestOptions2.headers, options.headers)
      };
    }
    function ClientOAuth2(options, request) {
      this.options = options;
      this.request = request || defaultRequest;
      this.code = new CodeFlow(this);
      this.token = new TokenFlow(this);
      this.owner = new OwnerFlow(this);
      this.credentials = new CredentialsFlow(this);
      this.jwt = new JwtBearerFlow(this);
    }
    ClientOAuth2.Token = ClientOAuth2Token;
    ClientOAuth2.prototype.createToken = function(access, refresh, type, data) {
      var options = Object.assign(
        {},
        data,
        typeof access === "string" ? { access_token: access } : access,
        typeof refresh === "string" ? { refresh_token: refresh } : refresh,
        typeof type === "string" ? { token_type: type } : type
      );
      return new ClientOAuth2.Token(this, options);
    };
    ClientOAuth2.prototype._request = function(options) {
      var url = options.url;
      var body = Querystring.stringify(options.body);
      var query = Querystring.stringify(options.query);
      if (query) {
        url += (url.indexOf("?") === -1 ? "?" : "&") + query;
      }
      return this.request(options.method, url, body, options.headers).then(function(res) {
        var body2 = parseResponseBody(res.body);
        var authErr = getAuthError(body2);
        if (authErr) {
          return Promise.reject(authErr);
        }
        if (res.status < 200 || res.status >= 399) {
          var statusErr = new Error("HTTP status " + res.status);
          statusErr.status = res.status;
          statusErr.body = res.body;
          statusErr.code = "ESTATUS";
          return Promise.reject(statusErr);
        }
        return body2;
      });
    };
    function ClientOAuth2Token(client, data) {
      this.client = client;
      this.data = data;
      this.tokenType = data.token_type && data.token_type.toLowerCase();
      this.accessToken = data.access_token;
      this.refreshToken = data.refresh_token;
      this.expiresIn(Number(data.expires_in));
    }
    ClientOAuth2Token.prototype.expiresIn = function(duration) {
      if (typeof duration === "number") {
        this.expires = /* @__PURE__ */ new Date();
        this.expires.setSeconds(this.expires.getSeconds() + duration);
      } else if (duration instanceof Date) {
        this.expires = new Date(duration.getTime());
      } else {
        throw new TypeError("Unknown duration: " + duration);
      }
      return this.expires;
    };
    ClientOAuth2Token.prototype.sign = function(requestObject) {
      if (!this.accessToken) {
        throw new Error("Unable to sign without access token");
      }
      requestObject.headers = requestObject.headers || {};
      if (this.tokenType === "bearer") {
        requestObject.headers.Authorization = "Bearer " + this.accessToken;
      } else {
        var parts = requestObject.url.split("#");
        var token = "access_token=" + this.accessToken;
        var url = parts[0].replace(/[?&]access_token=[^&#]/, "");
        var fragment = parts[1] ? "#" + parts[1] : "";
        requestObject.url = url + (url.indexOf("?") > -1 ? "&" : "?") + token + fragment;
        requestObject.headers.Pragma = "no-store";
        requestObject.headers["Cache-Control"] = "no-store";
      }
      return requestObject;
    };
    ClientOAuth2Token.prototype.refresh = function(opts) {
      var self2 = this;
      var options = Object.assign({}, this.client.options, opts);
      if (!this.refreshToken) {
        return Promise.reject(new Error("No refresh token"));
      }
      return this.client._request(requestOptions({
        url: options.accessTokenUri,
        method: "POST",
        headers: Object.assign({}, DEFAULT_HEADERS, {
          Authorization: auth(options.clientId, options.clientSecret)
        }),
        body: {
          refresh_token: this.refreshToken,
          grant_type: "refresh_token"
        }
      }, options)).then(function(data) {
        return self2.client.createToken(Object.assign({}, self2.data, data));
      });
    };
    ClientOAuth2Token.prototype.expired = function() {
      return Date.now() > this.expires.getTime();
    };
    function OwnerFlow(client) {
      this.client = client;
    }
    OwnerFlow.prototype.getToken = function(username, password, opts) {
      var self2 = this;
      var options = Object.assign({}, this.client.options, opts);
      const body = {
        username,
        password,
        grant_type: "password"
      };
      if (options.scopes !== void 0) {
        body.scope = sanitizeScope(options.scopes);
      }
      return this.client._request(requestOptions({
        url: options.accessTokenUri,
        method: "POST",
        headers: Object.assign({}, DEFAULT_HEADERS, {
          Authorization: auth(options.clientId, options.clientSecret)
        }),
        body
      }, options)).then(function(data) {
        return self2.client.createToken(data);
      });
    };
    function TokenFlow(client) {
      this.client = client;
    }
    TokenFlow.prototype.getUri = function(opts) {
      var options = Object.assign({}, this.client.options, opts);
      return createUri(options, "token");
    };
    TokenFlow.prototype.getToken = function(uri, opts) {
      var options = Object.assign({}, this.client.options, opts);
      var url = typeof uri === "object" ? uri : new URL(uri, DEFAULT_URL_BASE);
      var expectedUrl = new URL(options.redirectUri, DEFAULT_URL_BASE);
      if (typeof url.pathname === "string" && url.pathname !== expectedUrl.pathname) {
        return Promise.reject(
          new TypeError("Redirected path should match configured path, but got: " + url.pathname)
        );
      }
      if (!url.hash && !url.search) {
        return Promise.reject(new TypeError("Unable to process uri: " + uri));
      }
      var data = Object.assign(
        {},
        typeof url.search === "string" ? Querystring.parse(url.search.substr(1)) : url.search || {},
        typeof url.hash === "string" ? Querystring.parse(url.hash.substr(1)) : url.hash || {}
      );
      var err = getAuthError(data);
      if (err) {
        return Promise.reject(err);
      }
      if (options.state != null && data.state !== options.state) {
        return Promise.reject(new TypeError("Invalid state: " + data.state));
      }
      return Promise.resolve(this.client.createToken(data));
    };
    function CredentialsFlow(client) {
      this.client = client;
    }
    CredentialsFlow.prototype.getToken = function(opts) {
      var self2 = this;
      var options = Object.assign({}, this.client.options, opts);
      expects(options, "clientId", "clientSecret", "accessTokenUri");
      const body = {
        grant_type: "client_credentials"
      };
      if (options.scopes !== void 0) {
        body.scope = sanitizeScope(options.scopes);
      }
      return this.client._request(requestOptions({
        url: options.accessTokenUri,
        method: "POST",
        headers: Object.assign({}, DEFAULT_HEADERS, {
          Authorization: auth(options.clientId, options.clientSecret)
        }),
        body
      }, options)).then(function(data) {
        return self2.client.createToken(data);
      });
    };
    function CodeFlow(client) {
      this.client = client;
    }
    CodeFlow.prototype.getUri = function(opts) {
      var options = Object.assign({}, this.client.options, opts);
      return createUri(options, "code");
    };
    CodeFlow.prototype.getToken = function(uri, opts) {
      var self2 = this;
      var options = Object.assign({}, this.client.options, opts);
      expects(options, "clientId", "accessTokenUri");
      var url = typeof uri === "object" ? uri : new URL(uri, DEFAULT_URL_BASE);
      if (typeof options.redirectUri === "string" && typeof url.pathname === "string" && url.pathname !== new URL(options.redirectUri, DEFAULT_URL_BASE).pathname) {
        return Promise.reject(
          new TypeError("Redirected path should match configured path, but got: " + url.pathname)
        );
      }
      if (!url.search || !url.search.substr(1)) {
        return Promise.reject(new TypeError("Unable to process uri: " + uri));
      }
      var data = typeof url.search === "string" ? Querystring.parse(url.search.substr(1)) : url.search || {};
      var err = getAuthError(data);
      if (err) {
        return Promise.reject(err);
      }
      if (options.state != null && data.state !== options.state) {
        return Promise.reject(new TypeError("Invalid state: " + data.state));
      }
      if (!data.code) {
        return Promise.reject(new TypeError("Missing code, unable to request token"));
      }
      var headers = Object.assign({}, DEFAULT_HEADERS);
      var body = { code: data.code, grant_type: "authorization_code", redirect_uri: options.redirectUri };
      if (options.clientSecret) {
        headers.Authorization = auth(options.clientId, options.clientSecret);
      } else {
        body.client_id = options.clientId;
      }
      return this.client._request(requestOptions({
        url: options.accessTokenUri,
        method: "POST",
        headers,
        body
      }, options)).then(function(data2) {
        return self2.client.createToken(data2);
      });
    };
    function JwtBearerFlow(client) {
      this.client = client;
    }
    JwtBearerFlow.prototype.getToken = function(token, opts) {
      var self2 = this;
      var options = Object.assign({}, this.client.options, opts);
      var headers = Object.assign({}, DEFAULT_HEADERS);
      expects(options, "accessTokenUri");
      if (options.clientId) {
        headers.Authorization = auth(options.clientId, options.clientSecret);
      }
      const body = {
        grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
        assertion: token
      };
      if (options.scopes !== void 0) {
        body.scope = sanitizeScope(options.scopes);
      }
      return this.client._request(requestOptions({
        url: options.accessTokenUri,
        method: "POST",
        headers,
        body
      }, options)).then(function(data) {
        return self2.client.createToken(data);
      });
    };
  }
});

// ../../node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "../../node_modules/strict-uri-encode/index.js"(exports5, module) {
    "use strict";
    init_buffer2();
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// ../../node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "../../node_modules/decode-uri-component/index.js"(exports5, module) {
    "use strict";
    init_buffer2();
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode3(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i = 1; i < tokens.length; i++) {
          input = decodeComponents(tokens, i).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode3(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i = 0; i < entries.length; i++) {
        var key = entries[i];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// ../../node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "../../node_modules/split-on-first/index.js"(exports5, module) {
    "use strict";
    init_buffer2();
    module.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// ../../node_modules/filter-obj/index.js
var require_filter_obj = __commonJS({
  "../../node_modules/filter-obj/index.js"(exports5, module) {
    "use strict";
    init_buffer2();
    module.exports = function(obj, predicate) {
      var ret = {};
      var keys = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
          ret[key] = val;
        }
      }
      return ret;
    };
  }
});

// ../../node_modules/query-string/index.js
var require_query_string = __commonJS({
  "../../node_modules/query-string/index.js"(exports5) {
    "use strict";
    init_buffer2();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode3(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode3(key, options), "[", encode3(index, options), "]=", encode3(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode3(key, options), "[]"].join("")];
            }
            return [...result, [encode3(key, options), "[]=", encode3(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode3(key, options), ":list="].join("")];
            }
            return [...result, [encode3(key, options), ":list=", encode3(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode3(key, options), keyValueSep, encode3(value, options)].join("")];
            }
            return [[result, encode3(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode3(key, options)];
            }
            return [...result, [encode3(key, options), "=", encode3(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode3(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode3(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode3(item, options)) : value === null ? value : decode3(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode3(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode3(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode3(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode3(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse3(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode3(value, options);
        formatter(decode3(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k of Object.keys(value)) {
            value[k] = parseValue(value[k], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports5.extract = extract;
    exports5.parse = parse3;
    exports5.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode3(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode3(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode3(key, options) + "=" + encode3(value, options);
      }).filter((x) => x.length > 0).join("&");
    };
    exports5.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse3(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode3(hash, options) } : {}
      );
    };
    exports5.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports5.extract(object.url);
      const parsedQueryFromUrl = exports5.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports5.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode3(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports5.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports5.parseUrl(input, options);
      return exports5.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports5.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports5.pick(input, exclusionFilter, options);
    };
  }
});

// ../binding-http/dist/credential.js
var require_credential = __commonJS({
  "../binding-http/dist/credential.js"(exports5) {
    "use strict";
    init_buffer2();
    var __createBinding = exports5 && exports5.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports5 && exports5.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports5 && exports5.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports5, "__esModule", { value: true });
    exports5.TuyaCustomBearer = exports5.OAuthCredential = exports5.BasicKeyCredential = exports5.BearerCredential = exports5.BasicCredential = exports5.Credential = void 0;
    var node_fetch_1 = __importStar(require_browser());
    var crypto = __importStar((init_empty(), __toCommonJS(empty_exports)));
    var queryString = __importStar(require_query_string());
    var Credential = class {
    };
    exports5.Credential = Credential;
    var BasicCredential = class extends Credential {
      constructor({ username, password }, options) {
        super();
        if (username === void 0 || password === void 0 || username === null || password === null) {
          throw new Error(`No Basic credentials for Thing`);
        }
        this.username = username;
        this.password = password;
        this.options = options;
      }
      async sign(request) {
        const result = request.clone();
        let headerName = "authorization";
        if (this.options !== void 0 && this.options.in === "header" && this.options.name !== void 0) {
          headerName = this.options.name;
        }
        result.headers.set(headerName, "Basic " + Buffer.from(this.username + ":" + this.password).toString("base64"));
        return result;
      }
    };
    exports5.BasicCredential = BasicCredential;
    var BearerCredential = class extends Credential {
      constructor({ token }, options) {
        super();
        if (token === void 0 || token === null) {
          throw new Error(`No Bearer credentials for Thing`);
        }
        this.token = token;
        this.options = options;
      }
      async sign(request) {
        const result = request.clone();
        let headerName = "authorization";
        if (this.options.in === "header" && this.options.name !== void 0) {
          headerName = this.options.name;
        }
        result.headers.set(headerName, "Bearer " + this.token);
        return result;
      }
    };
    exports5.BearerCredential = BearerCredential;
    var BasicKeyCredential = class extends Credential {
      constructor({ apiKey }, options) {
        super();
        if (apiKey === void 0 || apiKey === null) {
          throw new Error(`No API key credentials for Thing`);
        }
        this.apiKey = apiKey;
        this.options = options;
      }
      async sign(request) {
        const result = request.clone();
        let headerName = "authorization";
        if (this.options.in === "header" && this.options.name !== void 0) {
          headerName = this.options.name;
        }
        result.headers.append(headerName, this.apiKey);
        return result;
      }
    };
    exports5.BasicKeyCredential = BasicKeyCredential;
    var OAuthCredential = class _OAuthCredential extends Credential {
      constructor(token, refresh) {
        super();
        this.token = token;
        this.refresh = refresh;
        this.token = token;
      }
      async sign(request) {
        if (this.token instanceof Promise) {
          const tokenRequest = this.token;
          this.token = await tokenRequest;
        }
        let tempRequest = { url: request.url, headers: {} };
        tempRequest = this.token.sign(tempRequest);
        const mergeHeaders = new node_fetch_1.Request(request, tempRequest);
        return mergeHeaders;
      }
      async refreshToken() {
        if (this.token instanceof Promise) {
          throw new Error("Uninitialized token. You have to call sing before refresh");
        }
        let newToken;
        if (this.refresh) {
          newToken = await this.refresh();
        } else {
          newToken = await this.token.refresh();
        }
        return new _OAuthCredential(newToken, this.refresh);
      }
    };
    exports5.OAuthCredential = OAuthCredential;
    var TuyaCustomBearer = class extends Credential {
      constructor(credentials, scheme) {
        super();
        this.key = credentials.key;
        this.secret = credentials.secret;
        this.baseUri = scheme.baseUri;
      }
      async sign(request) {
        const isTokenExpired = this.isTokenExpired();
        if (this.token === void 0 || this.token === "" || isTokenExpired)
          await this.requestAndRefreshToken(isTokenExpired);
        const url = request.url;
        const body = request.body?.read().toString();
        const method = request.method;
        const headers = this.getHeaders(true, request.headers.raw(), body, url, method);
        Object.assign(headers, request.headers.raw());
        return new node_fetch_1.Request(url, { method, body: body !== "" ? body : void 0, headers });
      }
      async requestAndRefreshToken(refresh) {
        const headers = this.getHeaders(false, {});
        const request = {
          headers,
          method: "GET"
        };
        let url = `${this.baseUri}/token?grant_type=1`;
        if (refresh) {
          url = `${this.baseUri}/token/${this.refreshToken}`;
        }
        const data = await (await (0, node_fetch_1.default)(url, request)).json();
        const success = data.success ?? false;
        if (success) {
          this.token = data.result?.access_token;
          this.refreshToken = data.result?.refresh_token;
          const expireTime = data.result?.expire_time;
          if (expireTime != null) {
            this.expireTime = new Date(Date.now() + expireTime * 1e3);
          }
        } else {
          throw new Error("token fetch failed");
        }
      }
      getHeaders(NormalRequest, headers, body, url, method) {
        const requestTime = Date.now().toString();
        const replaceUri = this.baseUri.replace("/v1.0", "");
        const _url = url?.replace(replaceUri, "");
        const sign = this.requestSign(NormalRequest, requestTime, body, _url, method);
        return {
          t: requestTime,
          client_id: this.key,
          sign_method: "HMAC-SHA256",
          sign,
          access_token: this.token ?? ""
        };
      }
      requestSign(NormalRequest, requestTime, body, path = "", method) {
        const bodyHash = crypto.createHash("sha256").update(body ?? "").digest("hex");
        let signUrl = "/v1.0/token?grant_type=1";
        const headerString = "";
        let useToken = "";
        const _method = method ?? "GET";
        if (NormalRequest) {
          useToken = this.token ?? "";
          const pathQuery = queryString.parse(path.split("?")[1]);
          let query = {};
          query = Object.assign(query, pathQuery);
          const sortedQuery = {};
          Object.keys(query).sort().forEach((i) => {
            sortedQuery[i] = query[i];
          });
          const qs = queryString.stringify(sortedQuery);
          signUrl = decodeURIComponent(qs ? `${path.split("?")[0]}?${qs}` : path);
        }
        const endStr = [this.key, useToken, requestTime, [_method, bodyHash, headerString, signUrl].join("\n")].join("");
        const sign = crypto.createHmac("sha256", this.secret).update(endStr).digest("hex").toUpperCase();
        return sign;
      }
      isTokenExpired() {
        return this.expireTime ? Date.now() > this.expireTime.getTime() : false;
      }
    };
    exports5.TuyaCustomBearer = TuyaCustomBearer;
  }
});

// ../binding-http/dist/oauth-manager.js
var require_oauth_manager = __commonJS({
  "../binding-http/dist/oauth-manager.js"(exports5) {
    "use strict";
    init_buffer2();
    var __importDefault = exports5 && exports5.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports5, "__esModule", { value: true });
    var core_1 = require_core();
    var client_oauth2_1 = __importDefault(require_client_oauth2());
    var https_1 = (init_https(), __toCommonJS(https_exports));
    var credential_1 = require_credential();
    function createRequestFunction(rejectUnauthorized) {
      return (method, url, body, headers) => {
        return new Promise((resolve2, reject) => {
          const parsedURL = new URL(url);
          const options = {
            method,
            host: parsedURL.hostname,
            port: parseInt(parsedURL.port),
            path: parsedURL.pathname + parsedURL.search,
            headers
          };
          options.rejectUnauthorized = rejectUnauthorized;
          const req = (0, https_1.request)(options);
          req.on("response", (response) => {
            response.setEncoding("utf8");
            const body2 = [];
            response.on("data", (data) => {
              body2.push(data);
            });
            response.on("end", () => {
              resolve2({
                status: response.statusCode ?? 500,
                body: body2.toString()
              });
            });
          });
          req.on("error", (er) => {
            reject(er);
          });
          req.write(body);
          req.end();
        });
      };
    }
    var OAuthManager = class {
      constructor() {
        this.tokenStore = /* @__PURE__ */ new Map();
      }
      handleClient(securityScheme, credentials) {
        const clientFlow = new client_oauth2_1.default({
          clientId: credentials.clientId,
          clientSecret: credentials.clientSecret,
          accessTokenUri: securityScheme.token,
          scopes: core_1.Helpers.toStringArray(securityScheme.scopes),
          body: {}
        }, createRequestFunction(false));
        const token = clientFlow.credentials.getToken();
        return new credential_1.OAuthCredential(token, clientFlow.credentials.getToken.bind(clientFlow.credentials));
      }
      handleResourceOwnerCredential(securityScheme, credentials) {
        const clientFlow = new client_oauth2_1.default({
          clientId: credentials.clientId,
          clientSecret: credentials.clientSecret,
          accessTokenUri: securityScheme.token,
          scopes: core_1.Helpers.toStringArray(securityScheme.scopes)
        }, createRequestFunction(false));
        const token = clientFlow.owner.getToken(credentials.username, credentials.password);
        return new credential_1.OAuthCredential(token);
      }
    };
    exports5.default = OAuthManager;
  }
});

// ../../node_modules/@jspm/core/nodelibs/browser/punycode.js
function dew3() {
  if (_dewExec2) return exports$12;
  _dewExec2 = true;
  const maxInt = 2147483647;
  const base = 36;
  const tMin = 1;
  const tMax = 26;
  const skew = 38;
  const damp = 700;
  const initialBias = 72;
  const initialN = 128;
  const delimiter = "-";
  const regexPunycode = /^xn--/;
  const regexNonASCII = /[^\0-\x7F]/;
  const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  const errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  const baseMinusTMin = base - tMin;
  const floor = Math.floor;
  const stringFromCharCode = String.fromCharCode;
  function error(type) {
    throw new RangeError(errors[type]);
  }
  function map(array, callback) {
    const result = [];
    let length = array.length;
    while (length--) {
      result[length] = callback(array[length]);
    }
    return result;
  }
  function mapDomain(domain, callback) {
    const parts = domain.split("@");
    let result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map(labels, callback).join(".");
    return result + encoded;
  }
  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter < length) {
      const value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  const basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  const digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  const adapt = function(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  const decode3 = function(input) {
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j = 0; j < basic; ++j) {
      if (input.charCodeAt(j) >= 128) {
        error("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
      const oldi = i;
      for (let w = 1, k = base; ; k += base) {
        if (index >= inputLength) {
          error("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base) {
          error("invalid-input");
        }
        if (digit > floor((maxInt - i) / w)) {
          error("overflow");
        }
        i += digit * w;
        const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t) {
          break;
        }
        const baseMinusT = base - t;
        if (w > floor(maxInt / baseMinusT)) {
          error("overflow");
        }
        w *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);
      if (floor(i / out) > maxInt - n) {
        error("overflow");
      }
      n += floor(i / out);
      i %= out;
      output.splice(i++, 0, n);
    }
    return String.fromCodePoint(...output);
  };
  const encode3 = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (const currentValue of input) {
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue === n) {
          let q = delta;
          for (let k = base; ; k += base) {
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            const qMinusT = q - t;
            const baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  };
  const toUnicode2 = function(input) {
    return mapDomain(input, function(string) {
      return regexPunycode.test(string) ? decode3(string.slice(4).toLowerCase()) : string;
    });
  };
  const toASCII2 = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode3(string) : string;
    });
  };
  const punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    "version": "2.3.1",
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    "ucs2": {
      "decode": ucs2decode,
      "encode": ucs2encode
    },
    "decode": decode3,
    "encode": encode3,
    "toASCII": toASCII2,
    "toUnicode": toUnicode2
  };
  exports$12 = punycode;
  return exports$12;
}
var exports$12, _dewExec2, exports2, decode2, encode2, toASCII, toUnicode, ucs2, version;
var init_punycode = __esm({
  "../../node_modules/@jspm/core/nodelibs/browser/punycode.js"() {
    init_buffer2();
    exports$12 = {};
    _dewExec2 = false;
    exports2 = dew3();
    decode2 = exports2.decode;
    encode2 = exports2.encode;
    toASCII = exports2.toASCII;
    toUnicode = exports2.toUnicode;
    ucs2 = exports2.ucs2;
    version = exports2.version;
  }
});

// ../../node_modules/@jspm/core/nodelibs/browser/chunk-BlJi4mNy.js
function dew4() {
  if (_dewExec3) return exports$13;
  _dewExec3 = true;
  var process$1 = process2;
  function assertPath(path) {
    if (typeof path !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
    }
  }
  function normalizeStringPosix(path, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i = 0; i <= path.length; ++i) {
      if (i < path.length) code = path.charCodeAt(i);
      else if (code === 47) break;
      else code = 47;
      if (code === 47) {
        if (lastSlash === i - 1 || dots === 1) ;
        else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) res += "/..";
            else res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) res += "/" + path.slice(lastSlash + 1, i);
          else res = path.slice(lastSlash + 1, i);
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep + base;
  }
  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve2() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path;
        if (i >= 0) path = arguments[i];
        else {
          if (cwd === void 0) cwd = process$1.cwd();
          path = cwd;
        }
        assertPath(path);
        if (path.length === 0) {
          continue;
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return "/" + resolvedPath;
        else return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize(path) {
      assertPath(path);
      if (path.length === 0) return ".";
      var isAbsolute = path.charCodeAt(0) === 47;
      var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
      path = normalizeStringPosix(path, !isAbsolute);
      if (path.length === 0 && !isAbsolute) path = ".";
      if (path.length > 0 && trailingSeparator) path += "/";
      if (isAbsolute) return "/" + path;
      return path;
    },
    isAbsolute: function isAbsolute(path) {
      assertPath(path);
      return path.length > 0 && path.charCodeAt(0) === 47;
    },
    join: function join() {
      if (arguments.length === 0) return ".";
      var joined;
      for (var i = 0; i < arguments.length; ++i) {
        var arg = arguments[i];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0) joined = arg;
          else joined += "/" + arg;
        }
      }
      if (joined === void 0) return ".";
      return posix.normalize(joined);
    },
    relative: function relative(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) return "";
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to) return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47) break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47) break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i = 0;
      for (; i <= length; ++i) {
        if (i === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i) === 47) {
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              return to.slice(toStart + i);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i) === 47) {
              lastCommonSep = i;
            } else if (i === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i);
        var toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
      }
      var out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === 47) {
          if (out.length === 0) out += "..";
          else out += "/..";
        }
      }
      if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path) {
      return path;
    },
    dirname: function dirname(path) {
      assertPath(path);
      if (path.length === 0) return ".";
      var code = path.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i = path.length - 1; i >= 1; --i) {
        code = path.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) return hasRoot ? "/" : ".";
      if (hasRoot && end === 1) return "//";
      return path.slice(0, end);
    },
    basename: function basename(path, ext) {
      if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
      assertPath(path);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
      } else {
        for (i = path.length - 1; i >= 0; --i) {
          if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
        }
        if (end === -1) return "";
        return path.slice(start, end);
      }
    },
    extname: function extname(path) {
      assertPath(path);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46) {
          if (startDot === -1) startDot = i;
          else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end);
    },
    format: function format2(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse3(path) {
      assertPath(path);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path.length === 0) return ret;
      var code = path.charCodeAt(0);
      var isAbsolute = code === 47;
      var start;
      if (isAbsolute) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i = path.length - 1;
      var preDotState = 0;
      for (; i >= start; --i) {
        code = path.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46) {
          if (startDot === -1) startDot = i;
          else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
          else ret.base = ret.name = path.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path.slice(1, startDot);
          ret.base = path.slice(1, end);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
      }
      if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
      else if (isAbsolute) ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  exports$13 = posix;
  return exports$13;
}
var exports$13, _dewExec3, exports3;
var init_chunk_BlJi4mNy = __esm({
  "../../node_modules/@jspm/core/nodelibs/browser/chunk-BlJi4mNy.js"() {
    init_buffer2();
    init_chunk_DEMDiNwt();
    exports$13 = {};
    _dewExec3 = false;
    exports3 = dew4();
  }
});

// ../../node_modules/@jspm/core/nodelibs/browser/url.js
var url_exports = {};
__export(url_exports, {
  URL: () => _URL,
  Url: () => Url,
  default: () => exports4,
  fileURLToPath: () => fileURLToPath,
  format: () => format,
  parse: () => parse2,
  pathToFileURL: () => pathToFileURL,
  resolve: () => resolve,
  resolveObject: () => resolveObject
});
function dew$72() {
  if (_dewExec$7) return exports$8;
  _dewExec$7 = true;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int = num < 0 ? -$floor(-num) : $floor(num);
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = empty;
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  exports$8 = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && opts.quoteStyle !== "single" && opts.quoteStyle !== "double") {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
      var name = nameOf(obj);
      var keys = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0; i < attrs.length; i++) {
        s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, {
          depth: maxDepth - depth
        });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof _global !== "undefined" && obj === _global) {
      return "{ [object globalThis] }";
    }
    if (!isDate(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
  }
  function isArray(obj) {
    return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isDate(obj) {
    return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isString(obj) {
    return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isNumber(obj) {
    return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isBoolean(obj) {
    return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in (this || _global);
  };
  function has(obj, key) {
    return hasOwn.call(obj, key);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type) {
    return type + " { ? }";
  }
  function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (indexOf(xs[i], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0; i < obj.length; i++) {
        xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  return exports$8;
}
function dew$6() {
  if (_dewExec$6) return exports$7;
  _dewExec$6 = true;
  var GetIntrinsic = dew$7();
  var callBound = dew();
  var inspect = dew$72();
  var $TypeError = dew$e();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $Map = GetIntrinsic("%Map%", true);
  var $weakMapGet = callBound("WeakMap.prototype.get", true);
  var $weakMapSet = callBound("WeakMap.prototype.set", true);
  var $weakMapHas = callBound("WeakMap.prototype.has", true);
  var $mapGet = callBound("Map.prototype.get", true);
  var $mapSet = callBound("Map.prototype.set", true);
  var $mapHas = callBound("Map.prototype.has", true);
  var listGetNode = function(list, key) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) !== null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        curr.next = /** @type {NonNullable<typeof list.next>} */
        list.next;
        list.next = curr;
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    var node = listGetNode(objects, key);
    return node && node.value;
  };
  var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
      node.value = value;
    } else {
      objects.next = /** @type {import('.').ListNode<typeof value>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key) {
    return !!listGetNode(objects, key);
  };
  exports$7 = function getSideChannel() {
    var $wm;
    var $m;
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapGet($m, key);
          }
        } else {
          if ($o) {
            return listGet($o, key);
          }
        }
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapHas($m, key);
          }
        } else {
          if ($o) {
            return listHas($o, key);
          }
        }
        return false;
      },
      set: function(key, value) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap();
          }
          $weakMapSet($wm, key, value);
        } else if ($Map) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        } else {
          if (!$o) {
            $o = {
              key: {},
              next: null
            };
          }
          listSet($o, key, value);
        }
      }
    };
    return channel;
  };
  return exports$7;
}
function dew$5() {
  if (_dewExec$5) return exports$6;
  _dewExec$5 = true;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  exports$6 = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return exports$6;
}
function dew$4() {
  if (_dewExec$4) return exports$5;
  _dewExec$4 = true;
  var formats = dew$5();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue2(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject2(source, options) {
    var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge = function merge2(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (isArray(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source)) {
      source.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge2(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge2(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode3 = function(str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;
  var encode3 = function encode4(str, defaultEncoder, charset, kind, format2) {
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (typeof str === "symbol") {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string = String(str);
    }
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j = 0; j < string.length; j += limit) {
      var segment = string.length >= limit ? string.slice(j, j + limit) : string;
      var arr = [];
      for (var i = 0; i < segment.length; ++i) {
        var c = segment.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats.RFC1738 && (c === 40 || c === 41)) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }
        if (c < 128) {
          arr[arr.length] = hexTable[c];
          continue;
        }
        if (c < 2048) {
          arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
        arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      out += arr.join("");
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue = [{
      obj: {
        o: value
      },
      prop: "o"
    }];
    var refs = [];
    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({
            obj,
            prop: key
          });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer = function isBuffer2(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b) {
    return [].concat(a, b);
  };
  var maybeMap = function maybeMap2(val, fn) {
    if (isArray(val)) {
      var mapped = [];
      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  exports$5 = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode: decode3,
    encode: encode3,
    isBuffer,
    isRegExp,
    maybeMap,
    merge
  };
  return exports$5;
}
function dew$3() {
  if (_dewExec$3) return exports$4;
  _dewExec$3 = true;
  var getSideChannel = dew$6();
  var utils = dew$4();
  var formats = dew$5();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats["default"];
  var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel = {};
  var stringify2 = function stringify3(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj = object;
    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter === "function") {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray(obj)) {
      obj = utils.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format2) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format2);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format2))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray(obj)) {
      if (encodeValuesOnly && encoder) {
        obj = utils.maybeMap(obj, encoder);
      }
      objKeys = [{
        value: obj.length > 0 ? obj.join(",") || null : void 0
      }];
    } else if (isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, "%2E") : prefix;
    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j = 0; j < objKeys.length; ++j) {
      var key = objKeys[j];
      var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
      var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel);
      pushToArray(values, stringify3(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format2 = formats["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format2 = opts.format;
    }
    var formatter = formats.formatters[format2];
    var filter = defaults.filter;
    if (typeof opts.filter === "function" || isArray(opts.filter)) {
      filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      arrayFormat,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      commaRoundTrip: opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
      filter,
      format: format2,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  exports$4 = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj = filter("", obj);
    } else if (isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      pushToArray(keys, stringify2(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  return exports$4;
}
function dew$22() {
  if (_dewExec$22) return exports$32;
  _dewExec$22 = true;
  var utils = dew$4();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {
      __proto__: null
    };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1;
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder, charset, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
        val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        });
      }
      if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
        val = interpretNumericEntities(val);
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray(val) ? [val] : val;
      }
      var existing = has.call(obj, key);
      if (existing && options.duplicates === "combine") {
        obj[key] = utils.combine(obj[key], val);
      } else if (!existing || options.duplicates === "last") {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root = chain[i];
      if (root === "[]" && options.parseArrays) {
        obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
      } else {
        obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === "") {
          obj = {
            0: leaf
          };
        } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
          obj = [];
          obj[index] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
      }
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
      delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  exports$32 = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
      obj = utils.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils.compact(obj);
  };
  return exports$32;
}
function dew$12() {
  if (_dewExec$12) return exports$22;
  _dewExec$12 = true;
  var stringify2 = dew$3();
  var parse3 = dew$22();
  var formats = dew$5();
  exports$22 = {
    formats,
    parse: parse3,
    stringify: stringify2
  };
  return exports$22;
}
function dew5() {
  if (_dewExec4) return exports$14;
  _dewExec4 = true;
  var punycode = exports2;
  function Url2() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
    javascript: true,
    "javascript:": true
  }, hostlessProtocol = {
    javascript: true,
    "javascript:": true
  }, slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  }, querystring = dew$12();
  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && typeof url === "object" && url instanceof Url2) {
      return url;
    }
    var u = new Url2();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
  }
  Url2.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    if (typeof url !== "string") {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    }
    var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, "/");
    url = uSplit.join(splitter);
    var rest = url;
    rest = rest.trim();
    if (!slashesDenoteHost && url.split("#").length === 1) {
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.path = rest;
        this.href = rest;
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
          if (parseQueryString) {
            this.query = querystring.parse(this.search.substr(1));
          } else {
            this.query = this.search.substr(1);
          }
        } else if (parseQueryString) {
          this.search = "";
          this.query = {};
        }
        return this;
      }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
      var slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      var hostEnd = -1;
      for (var i = 0; i < hostEndingChars.length; i++) {
        var hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      var auth, atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf("@");
      } else {
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = decodeURIComponent(auth);
      }
      hostEnd = -1;
      for (var i = 0; i < nonHostChars.length; i++) {
        var hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      if (hostEnd === -1) {
        hostEnd = rest.length;
      }
      this.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost();
      this.hostname = this.hostname || "";
      var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part) {
            continue;
          }
          if (!part.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                newpart += "x";
              } else {
                newpart += part[j];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = "/" + notHost.join(".") + rest;
              }
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      } else {
        this.hostname = this.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        this.hostname = punycode.toASCII(this.hostname);
      }
      var p = this.port ? ":" + this.port : "";
      var h = this.hostname || "";
      this.host = h + p;
      this.href += this.host;
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        if (rest[0] !== "/") {
          rest = "/" + rest;
        }
      }
    }
    if (!unsafeProtocol[lowerProto]) {
      for (var i = 0, l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        if (rest.indexOf(ae) === -1) {
          continue;
        }
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }
    var hash = rest.indexOf("#");
    if (hash !== -1) {
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      this.search = rest.substr(qm);
      this.query = rest.substr(qm + 1);
      if (parseQueryString) {
        this.query = querystring.parse(this.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      this.search = "";
      this.query = {};
    }
    if (rest) {
      this.pathname = rest;
    }
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = "/";
    }
    if (this.pathname || this.search) {
      var p = this.pathname || "";
      var s = this.search || "";
      this.path = p + s;
    }
    this.href = this.format();
    return this;
  };
  function urlFormat(obj) {
    if (typeof obj === "string") {
      obj = urlParse(obj);
    }
    if (!(obj instanceof Url2)) {
      return Url2.prototype.format.call(obj);
    }
    return obj.format();
  }
  Url2.prototype.format = function() {
    var auth = this.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
      if (this.port) {
        host += ":" + this.port;
      }
    }
    if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
      query = querystring.stringify(this.query, {
        arrayFormat: "repeat",
        addQueryPrefix: false
      });
    }
    var search = this.search || query && "?" + query || "";
    if (protocol && protocol.substr(-1) !== ":") {
      protocol += ":";
    }
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = "//" + (host || "");
      if (pathname && pathname.charAt(0) !== "/") {
        pathname = "/" + pathname;
      }
    } else if (!host) {
      host = "";
    }
    if (hash && hash.charAt(0) !== "#") {
      hash = "#" + hash;
    }
    if (search && search.charAt(0) !== "?") {
      search = "?" + search;
    }
    pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
    search = search.replace("#", "%23");
    return protocol + host + pathname + search + hash;
  };
  function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
  }
  Url2.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };
  function urlResolveObject(source, relative) {
    if (!source) {
      return relative;
    }
    return urlParse(source, false, true).resolveObject(relative);
  }
  Url2.prototype.resolveObject = function(relative) {
    if (typeof relative === "string") {
      var rel = new Url2();
      rel.parse(relative, false, true);
      relative = rel;
    }
    var result = new Url2();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
      var tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }
    result.hash = relative.hash;
    if (relative.href === "") {
      result.href = result.format();
      return result;
    }
    if (relative.slashes && !relative.protocol) {
      var rkeys = Object.keys(relative);
      for (var rk = 0; rk < rkeys.length; rk++) {
        var rkey = rkeys[rk];
        if (rkey !== "protocol") {
          result[rkey] = relative[rkey];
        }
      }
      if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
        result.pathname = "/";
        result.path = result.pathname;
      }
      result.href = result.format();
      return result;
    }
    if (relative.protocol && relative.protocol !== result.protocol) {
      if (!slashedProtocol[relative.protocol]) {
        var keys = Object.keys(relative);
        for (var v = 0; v < keys.length; v++) {
          var k = keys[v];
          result[k] = relative[k];
        }
        result.href = result.format();
        return result;
      }
      result.protocol = relative.protocol;
      if (!relative.host && !hostlessProtocol[relative.protocol]) {
        var relPath = (relative.pathname || "").split("/");
        while (relPath.length && !(relative.host = relPath.shift())) {
        }
        if (!relative.host) {
          relative.host = "";
        }
        if (!relative.hostname) {
          relative.hostname = "";
        }
        if (relPath[0] !== "") {
          relPath.unshift("");
        }
        if (relPath.length < 2) {
          relPath.unshift("");
        }
        result.pathname = relPath.join("/");
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.query = relative.query;
      result.host = relative.host || "";
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result.port = relative.port;
      if (result.pathname || result.search) {
        var p = result.pathname || "";
        var s = result.search || "";
        result.path = p + s;
      }
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
    if (psychotic) {
      result.hostname = "";
      result.port = null;
      if (result.host) {
        if (srcPath[0] === "") {
          srcPath[0] = result.host;
        } else {
          srcPath.unshift(result.host);
        }
      }
      result.host = "";
      if (relative.protocol) {
        relative.hostname = null;
        relative.port = null;
        if (relative.host) {
          if (relPath[0] === "") {
            relPath[0] = relative.host;
          } else {
            relPath.unshift(relative.host);
          }
        }
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      result.host = relative.host || relative.host === "" ? relative.host : result.host;
      result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
      result.search = relative.search;
      result.query = relative.query;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath) {
        srcPath = [];
      }
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
      result.query = relative.query;
    } else if (relative.search != null) {
      if (psychotic) {
        result.host = srcPath.shift();
        result.hostname = result.host;
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.hostname = authInHost.shift();
          result.host = result.hostname;
        }
      }
      result.search = relative.search;
      result.query = relative.query;
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.href = result.format();
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      if (result.search) {
        result.path = "/" + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
      last = srcPath[i];
      if (last === ".") {
        srcPath.splice(i, 1);
      } else if (last === "..") {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (; up--; up) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    if (psychotic) {
      result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
      result.host = result.hostname;
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift("");
    }
    if (srcPath.length > 0) {
      result.pathname = srcPath.join("/");
    } else {
      result.pathname = null;
      result.path = null;
    }
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  };
  Url2.prototype.parseHost = function() {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) {
      this.hostname = host;
    }
  };
  exports$14.parse = urlParse;
  exports$14.resolve = urlResolve;
  exports$14.resolveObject = urlResolveObject;
  exports$14.format = urlFormat;
  exports$14.Url = Url2;
  return exports$14;
}
function fileURLToPath(path) {
  if (typeof path === "string") path = new URL(path);
  else if (!(path instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows ? getPathFromURLWin(path) : getPathFromURLPosix(path);
}
function getPathFromURLWin(url) {
  const hostname = url.hostname;
  let pathname = url.pathname;
  for (let n = 0; n < pathname.length; n++) {
    if (pathname[n] === "%") {
      const third = pathname.codePointAt(n + 2) || 32;
      if (pathname[n + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== "") {
    return `\\\\${hostname}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep = pathname[2];
    if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
    sep !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n = 0; n < pathname.length; n++) {
    if (pathname[n] === "%") {
      const third = pathname.codePointAt(n + 2) || 32;
      if (pathname[n + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL(filepath) {
  let resolved = exports3.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports3.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%")) resolved = resolved.replace(percentRegEx, "%25");
  if (!isWindows && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx, "%5C");
  }
  if (resolved.includes("\n")) resolved = resolved.replace(newlineRegEx, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx, "%0D");
  }
  if (resolved.includes("	")) resolved = resolved.replace(tabRegEx, "%09");
  outURL.pathname = resolved;
  return outURL;
}
var empty, exports$8, _dewExec$7, _global, exports$7, _dewExec$6, exports$6, _dewExec$5, exports$5, _dewExec$4, exports$4, _dewExec$3, exports$32, _dewExec$22, exports$22, _dewExec$12, exports$14, _dewExec4, exports4, processPlatform, Url, format, resolve, resolveObject, parse2, _URL, CHAR_BACKWARD_SLASH, CHAR_FORWARD_SLASH, CHAR_LOWERCASE_A, CHAR_LOWERCASE_Z, isWindows, forwardSlashRegEx, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx;
var init_url = __esm({
  "../../node_modules/@jspm/core/nodelibs/browser/url.js"() {
    init_buffer2();
    init_punycode();
    init_chunk_DtcTpLWz();
    init_chunk_BlJi4mNy();
    init_chunk_DEMDiNwt();
    empty = Object.freeze(/* @__PURE__ */ Object.create(null));
    exports$8 = {};
    _dewExec$7 = false;
    _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
    exports$7 = {};
    _dewExec$6 = false;
    exports$6 = {};
    _dewExec$5 = false;
    exports$5 = {};
    _dewExec$4 = false;
    exports$4 = {};
    _dewExec$3 = false;
    exports$32 = {};
    _dewExec$22 = false;
    exports$22 = {};
    _dewExec$12 = false;
    exports$14 = {};
    _dewExec4 = false;
    exports4 = dew5();
    exports4["parse"];
    exports4["resolve"];
    exports4["resolveObject"];
    exports4["format"];
    exports4["Url"];
    processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
    exports4.URL = typeof URL !== "undefined" ? URL : null;
    exports4.pathToFileURL = pathToFileURL;
    exports4.fileURLToPath = fileURLToPath;
    Url = exports4.Url;
    format = exports4.format;
    resolve = exports4.resolve;
    resolveObject = exports4.resolveObject;
    parse2 = exports4.parse;
    _URL = exports4.URL;
    CHAR_BACKWARD_SLASH = 92;
    CHAR_FORWARD_SLASH = 47;
    CHAR_LOWERCASE_A = 97;
    CHAR_LOWERCASE_Z = 122;
    isWindows = processPlatform === "win32";
    forwardSlashRegEx = /\//g;
    percentRegEx = /%/g;
    backslashRegEx = /\\/g;
    newlineRegEx = /\n/g;
    carriageReturnRegEx = /\r/g;
    tabRegEx = /\t/g;
  }
});

// ../../node_modules/eventsource/lib/eventsource.js
var require_eventsource = __commonJS({
  "../../node_modules/eventsource/lib/eventsource.js"(exports5, module) {
    init_buffer2();
    var parse3 = (init_url(), __toCommonJS(url_exports)).parse;
    var events = (init_events(), __toCommonJS(events_exports));
    var https = (init_https(), __toCommonJS(https_exports));
    var http = (init_http(), __toCommonJS(http_exports));
    var util = (init_util(), __toCommonJS(util_exports));
    var httpsOptions = [
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "rejectUnauthorized",
      "secureProtocol",
      "servername",
      "checkServerIdentity"
    ];
    var bom = [239, 187, 191];
    var colon = 58;
    var space = 32;
    var lineFeed = 10;
    var carriageReturn = 13;
    var maxBufferAheadAllocation = 1024 * 256;
    var reUnsafeHeader = /^(cookie|authorization)$/i;
    function hasBom(buf) {
      return bom.every(function(charCode, index) {
        return buf[index] === charCode;
      });
    }
    function EventSource(url, eventSourceInitDict) {
      var readyState = EventSource.CONNECTING;
      var headers = eventSourceInitDict && eventSourceInitDict.headers;
      var hasNewOrigin = false;
      Object.defineProperty(this, "readyState", {
        get: function() {
          return readyState;
        }
      });
      Object.defineProperty(this, "url", {
        get: function() {
          return url;
        }
      });
      var self2 = this;
      self2.reconnectInterval = 1e3;
      self2.connectionInProgress = false;
      function onConnectionClosed(message) {
        if (readyState === EventSource.CLOSED) return;
        readyState = EventSource.CONNECTING;
        _emit("error", new Event("error", { message }));
        if (reconnectUrl) {
          url = reconnectUrl;
          reconnectUrl = null;
          hasNewOrigin = false;
        }
        setTimeout(function() {
          if (readyState !== EventSource.CONNECTING || self2.connectionInProgress) {
            return;
          }
          self2.connectionInProgress = true;
          connect();
        }, self2.reconnectInterval);
      }
      var req;
      var lastEventId = "";
      if (headers && headers["Last-Event-ID"]) {
        lastEventId = headers["Last-Event-ID"];
        delete headers["Last-Event-ID"];
      }
      var discardTrailingNewline = false;
      var data = "";
      var eventName = "";
      var reconnectUrl = null;
      function connect() {
        var options = parse3(url);
        var isSecure = options.protocol === "https:";
        options.headers = { "Cache-Control": "no-cache", "Accept": "text/event-stream" };
        if (lastEventId) options.headers["Last-Event-ID"] = lastEventId;
        if (headers) {
          var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;
          for (var i in reqHeaders) {
            var header = reqHeaders[i];
            if (header) {
              options.headers[i] = header;
            }
          }
        }
        options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);
        if (eventSourceInitDict && eventSourceInitDict.createConnection !== void 0) {
          options.createConnection = eventSourceInitDict.createConnection;
        }
        var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;
        if (useProxy) {
          var proxy = parse3(eventSourceInitDict.proxy);
          isSecure = proxy.protocol === "https:";
          options.protocol = isSecure ? "https:" : "http:";
          options.path = url;
          options.headers.Host = options.host;
          options.hostname = proxy.hostname;
          options.host = proxy.host;
          options.port = proxy.port;
        }
        if (eventSourceInitDict && eventSourceInitDict.https) {
          for (var optName in eventSourceInitDict.https) {
            if (httpsOptions.indexOf(optName) === -1) {
              continue;
            }
            var option = eventSourceInitDict.https[optName];
            if (option !== void 0) {
              options[optName] = option;
            }
          }
        }
        if (eventSourceInitDict && eventSourceInitDict.withCredentials !== void 0) {
          options.withCredentials = eventSourceInitDict.withCredentials;
        }
        req = (isSecure ? https : http).request(options, function(res) {
          self2.connectionInProgress = false;
          if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {
            _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage }));
            onConnectionClosed();
            return;
          }
          if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {
            var location = res.headers.location;
            if (!location) {
              _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage }));
              return;
            }
            var prevOrigin = new URL(url).origin;
            var nextOrigin = new URL(location).origin;
            hasNewOrigin = prevOrigin !== nextOrigin;
            if (res.statusCode === 307) reconnectUrl = url;
            url = location;
            process.nextTick(connect);
            return;
          }
          if (res.statusCode !== 200) {
            _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage }));
            return self2.close();
          }
          readyState = EventSource.OPEN;
          res.on("close", function() {
            res.removeAllListeners("close");
            res.removeAllListeners("end");
            onConnectionClosed();
          });
          res.on("end", function() {
            res.removeAllListeners("close");
            res.removeAllListeners("end");
            onConnectionClosed();
          });
          _emit("open", new Event("open"));
          var buf;
          var newBuffer;
          var startingPos = 0;
          var startingFieldLength = -1;
          var newBufferSize = 0;
          var bytesUsed = 0;
          res.on("data", function(chunk) {
            if (!buf) {
              buf = chunk;
              if (hasBom(buf)) {
                buf = buf.slice(bom.length);
              }
              bytesUsed = buf.length;
            } else {
              if (chunk.length > buf.length - bytesUsed) {
                newBufferSize = buf.length * 2 + chunk.length;
                if (newBufferSize > maxBufferAheadAllocation) {
                  newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation;
                }
                newBuffer = Buffer.alloc(newBufferSize);
                buf.copy(newBuffer, 0, 0, bytesUsed);
                buf = newBuffer;
              }
              chunk.copy(buf, bytesUsed);
              bytesUsed += chunk.length;
            }
            var pos = 0;
            var length = bytesUsed;
            while (pos < length) {
              if (discardTrailingNewline) {
                if (buf[pos] === lineFeed) {
                  ++pos;
                }
                discardTrailingNewline = false;
              }
              var lineLength = -1;
              var fieldLength = startingFieldLength;
              var c;
              for (var i2 = startingPos; lineLength < 0 && i2 < length; ++i2) {
                c = buf[i2];
                if (c === colon) {
                  if (fieldLength < 0) {
                    fieldLength = i2 - pos;
                  }
                } else if (c === carriageReturn) {
                  discardTrailingNewline = true;
                  lineLength = i2 - pos;
                } else if (c === lineFeed) {
                  lineLength = i2 - pos;
                }
              }
              if (lineLength < 0) {
                startingPos = length - pos;
                startingFieldLength = fieldLength;
                break;
              } else {
                startingPos = 0;
                startingFieldLength = -1;
              }
              parseEventStreamLine(buf, pos, fieldLength, lineLength);
              pos += lineLength + 1;
            }
            if (pos === length) {
              buf = void 0;
              bytesUsed = 0;
            } else if (pos > 0) {
              buf = buf.slice(pos, bytesUsed);
              bytesUsed = buf.length;
            }
          });
        });
        req.on("error", function(err) {
          self2.connectionInProgress = false;
          onConnectionClosed(err.message);
        });
        if (req.setNoDelay) req.setNoDelay(true);
        req.end();
      }
      connect();
      function _emit() {
        if (self2.listeners(arguments[0]).length > 0) {
          self2.emit.apply(self2, arguments);
        }
      }
      this._close = function() {
        if (readyState === EventSource.CLOSED) return;
        readyState = EventSource.CLOSED;
        if (req.abort) req.abort();
        if (req.xhr && req.xhr.abort) req.xhr.abort();
      };
      function parseEventStreamLine(buf, pos, fieldLength, lineLength) {
        if (lineLength === 0) {
          if (data.length > 0) {
            var type = eventName || "message";
            _emit(type, new MessageEvent(type, {
              data: data.slice(0, -1),
              // remove trailing newline
              lastEventId,
              origin: new URL(url).origin
            }));
            data = "";
          }
          eventName = void 0;
        } else if (fieldLength > 0) {
          var noValue = fieldLength < 0;
          var step = 0;
          var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();
          if (noValue) {
            step = lineLength;
          } else if (buf[pos + fieldLength + 1] !== space) {
            step = fieldLength + 1;
          } else {
            step = fieldLength + 2;
          }
          pos += step;
          var valueLength = lineLength - step;
          var value = buf.slice(pos, pos + valueLength).toString();
          if (field === "data") {
            data += value + "\n";
          } else if (field === "event") {
            eventName = value;
          } else if (field === "id") {
            lastEventId = value;
          } else if (field === "retry") {
            var retry = parseInt(value, 10);
            if (!Number.isNaN(retry)) {
              self2.reconnectInterval = retry;
            }
          }
        }
      }
    }
    module.exports = EventSource;
    util.inherits(EventSource, events.EventEmitter);
    EventSource.prototype.constructor = EventSource;
    ["open", "error", "message"].forEach(function(method) {
      Object.defineProperty(EventSource.prototype, "on" + method, {
        /**
         * Returns the current listener
         *
         * @return {Mixed} the set function or undefined
         * @api private
         */
        get: function get() {
          var listener = this.listeners(method)[0];
          return listener ? listener._listener ? listener._listener : listener : void 0;
        },
        /**
         * Start listening for events
         *
         * @param {Function} listener the listener
         * @return {Mixed} the set function or undefined
         * @api private
         */
        set: function set(listener) {
          this.removeAllListeners(method);
          this.addEventListener(method, listener);
        }
      });
    });
    Object.defineProperty(EventSource, "CONNECTING", { enumerable: true, value: 0 });
    Object.defineProperty(EventSource, "OPEN", { enumerable: true, value: 1 });
    Object.defineProperty(EventSource, "CLOSED", { enumerable: true, value: 2 });
    EventSource.prototype.CONNECTING = 0;
    EventSource.prototype.OPEN = 1;
    EventSource.prototype.CLOSED = 2;
    EventSource.prototype.close = function() {
      this._close();
    };
    EventSource.prototype.addEventListener = function addEventListener(type, listener) {
      if (typeof listener === "function") {
        listener._listener = listener;
        this.on(type, listener);
      }
    };
    EventSource.prototype.dispatchEvent = function dispatchEvent(event) {
      if (!event.type) {
        throw new Error("UNSPECIFIED_EVENT_TYPE_ERR");
      }
      this.emit(event.type, event.detail);
    };
    EventSource.prototype.removeEventListener = function removeEventListener(type, listener) {
      if (typeof listener === "function") {
        listener._listener = void 0;
        this.removeListener(type, listener);
      }
    };
    function Event(type, optionalProperties) {
      Object.defineProperty(this, "type", { writable: false, value: type, enumerable: true });
      if (optionalProperties) {
        for (var f in optionalProperties) {
          if (optionalProperties.hasOwnProperty(f)) {
            Object.defineProperty(this, f, { writable: false, value: optionalProperties[f], enumerable: true });
          }
        }
      }
    }
    function MessageEvent(type, eventInitDict) {
      Object.defineProperty(this, "type", { writable: false, value: type, enumerable: true });
      for (var f in eventInitDict) {
        if (eventInitDict.hasOwnProperty(f)) {
          Object.defineProperty(this, f, { writable: false, value: eventInitDict[f], enumerable: true });
        }
      }
    }
    function removeUnsafeHeaders(headers) {
      var safe = {};
      for (var key in headers) {
        if (reUnsafeHeader.test(key)) {
          continue;
        }
        safe[key] = headers[key];
      }
      return safe;
    }
  }
});

// ../binding-http/dist/subscription-protocols.js
var require_subscription_protocols = __commonJS({
  "../binding-http/dist/subscription-protocols.js"(exports5) {
    "use strict";
    init_buffer2();
    var __importDefault = exports5 && exports5.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports5, "__esModule", { value: true });
    exports5.SSESubscription = exports5.LongPollingSubscription = void 0;
    var eventsource_1 = __importDefault(require_eventsource());
    var core_1 = require_core();
    var stream_1 = (init_stream(), __toCommonJS(stream_exports));
    var { debug } = (0, core_1.createLoggers)("binding-http", "subscription-protocols");
    var LongPollingSubscription = class {
      constructor(form, client) {
        this.form = form;
        this.client = client;
        this.closed = false;
        this.abortController = new AbortController();
      }
      open(next, error, complete) {
        return new Promise((resolve2, reject) => {
          const polling = async (handshake) => {
            try {
              if (handshake) {
                const headRequest = await this.client["generateFetchRequest"](this.form, "HEAD", {
                  timeout: 1e3,
                  signal: this.abortController.signal
                });
                const result2 = await this.client["doFetch"](headRequest);
                if (result2.ok)
                  resolve2();
              }
              const request = await this.client["generateFetchRequest"](this.form, "GET", {
                timeout: 60 * 60 * 1e3,
                signal: this.abortController.signal
              });
              debug(`HttpClient (subscribeResource) sending ${request.method} to ${request.url}`);
              const result = await this.client["doFetch"](request);
              this.client["checkFetchResponse"](result);
              debug(`HttpClient received ${result.status} from ${request.url}`);
              debug(`HttpClient received headers: ${JSON.stringify(result.headers.raw())}`);
              debug(`HttpClient received Content-Type: ${result.headers.get("content-type")}`);
              if (!this.closed) {
                const body = core_1.ProtocolHelpers.toNodeStream(result.body);
                next(new core_1.Content(result.headers.get("content-type") ?? core_1.ContentSerdes.DEFAULT, body));
                polling(false);
              }
              complete && complete();
            } catch (e) {
              const err = e instanceof Error ? e : new Error(JSON.stringify(e));
              error && error(err);
              complete && complete();
              reject(e);
            }
          };
          polling(true);
        });
      }
      close() {
        this.abortController.abort();
        this.closed = true;
      }
    };
    exports5.LongPollingSubscription = LongPollingSubscription;
    var SSESubscription = class {
      constructor(form) {
        this.form = form;
        this.closed = false;
      }
      open(next, error, complete) {
        return new Promise((resolve2, reject) => {
          this.eventSource = new eventsource_1.default(this.form.href);
          this.eventSource.onopen = (event) => {
            debug(`HttpClient (subscribeResource) Server-Sent Event connection is opened to ${this.form.href}`);
            resolve2();
          };
          this.eventSource.onmessage = (event) => {
            debug(`HttpClient received ${JSON.stringify(event)} from ${this.form.href}`);
            const output = new core_1.Content(this.form.contentType ?? core_1.ContentSerdes.DEFAULT, stream_1.Readable.from(event.data));
            next(output);
          };
          this.eventSource.onerror = function(event) {
            error?.(new Error(event.toString()));
            complete && complete();
            reject(event.toString());
          };
        });
      }
      close() {
        this.eventSource?.close();
      }
    };
    exports5.SSESubscription = SSESubscription;
  }
});

// ../binding-http/dist/http-client-impl.js
var require_http_client_impl = __commonJS({
  "../binding-http/dist/http-client-impl.js"(exports5) {
    "use strict";
    init_buffer2();
    var __createBinding = exports5 && exports5.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports5 && exports5.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports5 && exports5.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __importDefault = exports5 && exports5.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports5, "__esModule", { value: true });
    var http = __importStar((init_http(), __toCommonJS(http_exports)));
    var https = __importStar((init_https(), __toCommonJS(https_exports)));
    var Subscription_1 = require_Subscription();
    var core_1 = require_core();
    var node_fetch_1 = __importStar(require_browser());
    var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));
    var oauth_manager_1 = __importDefault(require_oauth_manager());
    var credential_1 = require_credential();
    var subscription_protocols_1 = require_subscription_protocols();
    var { debug, warn, error } = (0, core_1.createLoggers)("binding-http", "http-client-impl");
    var HttpClient = class _HttpClient {
      constructor(config = null, secure = false, oauthManager = new oauth_manager_1.default()) {
        this.proxyRequest = null;
        this.allowSelfSigned = false;
        this.credential = null;
        this.activeSubscriptions = /* @__PURE__ */ new Map();
        if (config !== null && config.proxy && config.proxy.href) {
          this.proxyRequest = new node_fetch_1.Request(_HttpClient.fixLocalhostName(config.proxy.href));
          if (config.proxy.scheme === "basic") {
            if (!Object.prototype.hasOwnProperty.call(config.proxy, "username") || !Object.prototype.hasOwnProperty.call(config.proxy, "password"))
              warn("HttpClient client configured for basic proxy auth, but no username/password given");
            this.proxyRequest.headers.set("proxy-authorization", "Basic " + buffer_1.Buffer.from(config.proxy.username + ":" + config.proxy.password).toString("base64"));
          } else if (config.proxy.scheme === "bearer") {
            if (!Object.prototype.hasOwnProperty.call(config.proxy, "token"))
              warn("HttpClient client configured for bearer proxy auth, but no token given");
            this.proxyRequest.headers.set("proxy-authorization", "Bearer " + config.proxy.token);
          }
          if (this.proxyRequest.protocol === "https") {
            secure = true;
          }
          debug(`HttpClient using ${secure ? "secure " : ""}proxy ${this.proxyRequest.hostname}:${this.proxyRequest.port}`);
        }
        if (config !== null && config.allowSelfSigned !== void 0) {
          this.allowSelfSigned = config.allowSelfSigned;
          warn(`HttpClient allowing self-signed/untrusted certificates -- USE FOR TESTING ONLY`);
        }
        this.agent = secure ? new https.Agent({
          rejectUnauthorized: !this.allowSelfSigned
        }) : new http.Agent();
        this.provider = secure ? "https" : "http";
        this.oauth = oauthManager;
      }
      toString() {
        return `[HttpClient]`;
      }
      async readResource(form) {
        const headers = form.contentType != null ? [["accept", form.contentType]] : [["accept", core_1.ContentSerdes.DEFAULT]];
        const request = await this.generateFetchRequest(form, "GET", { headers });
        debug(`HttpClient (readResource) sending ${request.method} to ${request.url}`);
        const result = await this.doFetch(request);
        this.checkFetchResponse(result);
        debug(`HttpClient received headers: ${JSON.stringify(result.headers.raw())}`);
        debug(`HttpClient received Content-Type: ${result.headers.get("content-type")}`);
        const body = core_1.ProtocolHelpers.toNodeStream(result.body);
        return new core_1.Content(result.headers.get("content-type") ?? core_1.ContentSerdes.DEFAULT, body);
      }
      async writeResource(form, content) {
        const request = await this.generateFetchRequest(form, "PUT", {
          headers: [["content-type", content.type]],
          body: content.body
        });
        debug(`HttpClient (writeResource) sending ${request.method} with '${request.headers.get("Content-Type")}' to ${request.url}`);
        const result = await this.doFetch(request);
        debug(`HttpClient received ${result.status} from ${result.url}`);
        this.checkFetchResponse(result);
        debug(`HttpClient received headers: ${JSON.stringify(result.headers.raw())}`);
      }
      async subscribeResource(form, next, error2, complete) {
        const defaultSubprotocol = "longpoll";
        let subprotocol = form.subprotocol;
        if (subprotocol == null) {
          warn(`Subscribing to ${form.href} using long polling for form without subprotocol`);
          subprotocol = defaultSubprotocol;
        }
        let internalSubscription;
        if (subprotocol === defaultSubprotocol) {
          internalSubscription = new subscription_protocols_1.LongPollingSubscription(form, this);
        } else if (form.subprotocol === "sse") {
          internalSubscription = new subscription_protocols_1.SSESubscription(form);
        } else {
          throw new Error(`HttpClient does not support subprotocol ${form.subprotocol}`);
        }
        await internalSubscription.open(next, error2, complete);
        this.activeSubscriptions.set(form.href, internalSubscription);
        return new Subscription_1.Subscription(() => {
          internalSubscription.close();
        });
      }
      async invokeResource(form, content) {
        const headers = content != null ? [["content-type", content.type]] : [];
        if (form.response?.contentType != null) {
          headers.push(["accept", form.response?.contentType]);
        } else if (form.contentType != null) {
          headers.push(["accept", form.contentType]);
        } else {
          headers.push(["accept", core_1.ContentSerdes.DEFAULT]);
        }
        const request = await this.generateFetchRequest(form, "POST", {
          headers,
          body: content?.body
        });
        debug(`HttpClient (invokeResource) sending ${request.method} ${content != null ? `with '"${request.headers.get("Content-Type")}"` : ""} to ${request.url}`);
        const result = await this.doFetch(request);
        debug(`HttpClient received ${result.status} from ${request.url}`);
        debug(`HttpClient received Content-Type: ${result.headers.get("content-type")}`);
        this.checkFetchResponse(result);
        const body = core_1.ProtocolHelpers.toNodeStream(result.body);
        return new core_1.Content(result.headers.get("content-type") ?? core_1.ContentSerdes.DEFAULT, body);
      }
      async unlinkResource(form) {
        debug(`HttpClient (unlinkResource) ${form.href}`);
        const internalSub = this.activeSubscriptions.get(form.href);
        if (internalSub) {
          internalSub.close();
        } else {
          warn(`HttpClient cannot unlink ${form.href} no subscription found`);
        }
      }
      async requestThingDescription(uri) {
        const headers = {
          Accept: "application/td+json"
        };
        const request = await this.generateFetchRequest({ href: uri }, "GET", headers);
        const response = await this.doFetch(request);
        const body = core_1.ProtocolHelpers.toNodeStream(response.body);
        return new core_1.Content(response.headers.get("content-type") ?? "application/td+json", body);
      }
      async start() {
      }
      async stop() {
        this.agent?.destroy?.();
      }
      setSecurity(metadata, credentials) {
        if (metadata === void 0 || !Array.isArray(metadata) || metadata.length === 0) {
          warn("HttpClient without security");
          return false;
        }
        const security = metadata[0];
        switch (security.scheme) {
          case "basic": {
            const securityBasic = security;
            this.credential = new credential_1.BasicCredential(credentials, securityBasic);
            break;
          }
          case "bearer": {
            const securityBearer = security;
            this.credential = new credential_1.BearerCredential(credentials, securityBearer);
            break;
          }
          case "apikey": {
            const securityAPIKey = security;
            this.credential = new credential_1.BasicKeyCredential(credentials, securityAPIKey);
            break;
          }
          case "oauth2": {
            const securityOAuth = security;
            if (securityOAuth.flow === "client") {
              securityOAuth.flow = "client_credentials";
              this.credential = this.oauth.handleClient(securityOAuth, credentials);
            } else if (securityOAuth.flow === "password") {
              this.credential = this.oauth.handleResourceOwnerCredential(securityOAuth, credentials);
            }
            break;
          }
          case "TuyaCustomBearer": {
            this.credential = new credential_1.TuyaCustomBearer(credentials, security);
            break;
          }
          case "nosec":
            break;
          default:
            error(`HttpClient cannot set security scheme '${security.scheme}'. ${metadata}`);
            return false;
        }
        if (security.proxy != null) {
          if (this.proxyRequest !== null) {
            debug(`HttpClient overriding client-side proxy with security proxy '${security.proxy}`);
          }
          this.proxyRequest = new node_fetch_1.Request(_HttpClient.fixLocalhostName(security.proxy));
          if (security.scheme === "basic") {
            const basicCredential = credentials;
            if (basicCredential === void 0 || basicCredential.username === void 0 || basicCredential.password === void 0) {
              throw new Error(`No Basic credentials for Thing`);
            }
            this.proxyRequest.headers.set("proxy-authorization", "Basic " + buffer_1.Buffer.from(basicCredential.username + ":" + basicCredential.password).toString("base64"));
          } else if (security.scheme === "bearer") {
            const tokenCredentials = credentials;
            if (credentials === void 0 || tokenCredentials.token === void 0) {
              throw new Error(`No Bearer credentials for Thing`);
            }
            this.proxyRequest.headers.set("proxy-authorization", "Bearer " + tokenCredentials.token);
          }
        }
        debug(`HttpClient using security scheme '${security.scheme}'`);
        return true;
      }
      async generateFetchRequest(form, defaultMethod, additionalOptions = {}) {
        const requestInit = additionalOptions;
        const url = _HttpClient.fixLocalhostName(form.href);
        requestInit.method = form["htv:methodName"] ? form["htv:methodName"] : defaultMethod;
        requestInit.headers = requestInit.headers ?? [];
        requestInit.headers = requestInit.headers;
        if (Array.isArray(form["htv:headers"])) {
          debug(`HttpClient got Form 'headers' ${form["htv:headers"]}`);
          const headers = form["htv:headers"];
          for (const option of headers) {
            requestInit.headers = requestInit.headers.filter((header) => header[0].toLowerCase() !== option["htv:fieldName"].toLowerCase());
            requestInit.headers.push([option["htv:fieldName"], option["htv:fieldValue"]]);
          }
        } else if (typeof form["htv:headers"] === "object") {
          debug(`HttpClient got Form SINGLE-ENTRY 'headers' ${form["htv:headers"]}`);
          const option = form["htv:headers"];
          requestInit.headers = requestInit.headers.filter((header) => header[0].toLowerCase() !== option["htv:fieldName"].toLowerCase());
          requestInit.headers.push([option["htv:fieldName"], option["htv:fieldValue"]]);
        }
        requestInit.agent = this.agent;
        let request = this.proxyRequest ? new node_fetch_1.Request(this.proxyRequest, requestInit) : new node_fetch_1.Request(url, requestInit);
        if (this.credential) {
          request = await this.credential.sign(request);
        }
        if (this.proxyRequest) {
          const parsedBaseURL = new URL(url);
          request.url = request.url + parsedBaseURL.pathname;
          debug(`HttpClient proxy request URL: ${request.url}`);
          request.headers.set("host", parsedBaseURL.hostname);
        }
        return request;
      }
      _fetch(request) {
        return (0, node_fetch_1.default)(request, { body: request.body });
      }
      async doFetch(request) {
        const result = await this._fetch(request);
        if (_HttpClient.isOAuthTokenExpired(result, this.credential)) {
          this.credential = await this.credential.refreshToken();
          return await this._fetch(await this.credential.sign(request));
        }
        return result;
      }
      checkFetchResponse(response) {
        const statusCode = response.status;
        if (statusCode < 200) {
          throw new Error(`HttpClient received ${statusCode} and cannot continue (not implemented, open GitHub Issue)`);
        } else if (statusCode < 300) {
        } else if (statusCode < 400) {
          throw new Error(`HttpClient received ${statusCode} and cannot continue (not implemented, open GitHub Issue)`);
        } else if (statusCode < 500) {
          throw new Error(`Client error: ${response.statusText}`);
        } else {
          throw new Error(`Server error: ${response.statusText}`);
        }
      }
      static isOAuthTokenExpired(result, credential) {
        return result.status === 401 && credential instanceof credential_1.OAuthCredential;
      }
      static fixLocalhostName(url) {
        const localhostPresent = /^(https?:)?(\/\/)?(?:[^@\n]+@)?(www\.)?(localhost)/gm;
        if (localhostPresent.test(url)) {
          warn("LOCALHOST FIX");
          return url.replace(localhostPresent, "$1$2127.0.0.1");
        }
        return url;
      }
    };
    exports5.default = HttpClient;
  }
});

// ../binding-http/dist/http-client-browser.js
var require_http_client_browser = __commonJS({
  "../binding-http/dist/http-client-browser.js"(exports5) {
    "use strict";
    init_buffer2();
    var __importDefault = exports5 && exports5.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports5, "__esModule", { value: true });
    var core_1 = require_core();
    var node_fetch_1 = __importDefault(require_browser());
    var stream_1 = (init_stream(), __toCommonJS(stream_exports));
    var http_client_impl_1 = __importDefault(require_http_client_impl());
    var BrowserHttpClient = class extends http_client_impl_1.default {
      async generateFetchRequest(form, defaultMethod, additionalOptions) {
        if (additionalOptions?.body instanceof stream_1.Readable) {
          const buffer = await core_1.ProtocolHelpers.readStreamFully(additionalOptions.body);
          additionalOptions.body = buffer;
        }
        return super.generateFetchRequest(form, defaultMethod, additionalOptions);
      }
      async _fetch(request) {
        return (0, node_fetch_1.default)(request);
      }
    };
    exports5.default = BrowserHttpClient;
  }
});

// ../binding-http/dist/http-client-factory.js
var require_http_client_factory = __commonJS({
  "../binding-http/dist/http-client-factory.js"(exports5) {
    "use strict";
    init_buffer2();
    var __importDefault = exports5 && exports5.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports5, "__esModule", { value: true });
    var core_1 = require_core();
    var http_client_1 = __importDefault(require_http_client_browser());
    var oauth_manager_1 = __importDefault(require_oauth_manager());
    var { debug, warn } = (0, core_1.createLoggers)("binding-http", "http-client-factory");
    var HttpClientFactory = class {
      constructor(config = null) {
        this.scheme = "http";
        this.config = null;
        this.oAuthManager = new oauth_manager_1.default();
        this.config = config;
      }
      getClient() {
        if (this.config && this.config.proxy && this.config.proxy.href && this.config.proxy.href.startsWith("https:")) {
          warn("HttpClientFactory creating client for 'https' due to secure proxy configuration");
          return new http_client_1.default(this.config, true, this.oAuthManager);
        } else {
          debug(`HttpClientFactory creating client for '${this.scheme}'`);
          return new http_client_1.default(this.config);
        }
      }
      init() {
        return true;
      }
      destroy() {
        return true;
      }
    };
    exports5.default = HttpClientFactory;
  }
});

// ../binding-http/dist/https-client-factory.js
var require_https_client_factory = __commonJS({
  "../binding-http/dist/https-client-factory.js"(exports5) {
    "use strict";
    init_buffer2();
    var __importDefault = exports5 && exports5.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports5, "__esModule", { value: true });
    var core_1 = require_core();
    var http_client_1 = __importDefault(require_http_client_browser());
    var { debug, warn } = (0, core_1.createLoggers)("binding-http", "https-client-factory");
    var HttpsClientFactory = class {
      constructor(config = null) {
        this.scheme = "https";
        this.config = null;
        this.config = config;
      }
      getClient() {
        if (this.config && this.config.proxy && this.config.proxy.href && this.config.proxy.href.startsWith("http:")) {
          warn("HttpsClientFactory creating client for 'http' due to insecure proxy configuration");
          return new http_client_1.default(this.config);
        } else {
          debug(`HttpsClientFactory creating client for '${this.scheme}'`);
          return new http_client_1.default(this.config, true);
        }
      }
      init() {
        return true;
      }
      destroy() {
        return true;
      }
    };
    exports5.default = HttpsClientFactory;
  }
});

// ../binding-http/dist/http-browser.js
var require_http_browser = __commonJS({
  "../binding-http/dist/http-browser.js"(exports5) {
    init_buffer2();
    var __createBinding = exports5 && exports5.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports5 && exports5.__exportStar || function(m, exports6) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports6, p)) __createBinding(exports6, m, p);
    };
    var __importDefault = exports5 && exports5.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports5, "__esModule", { value: true });
    exports5.HttpForm = exports5.HttpHeader = exports5.HttpsClientFactory = exports5.HttpClientFactory = exports5.HttpClient = void 0;
    var core_1 = require_core();
    var node_fetch_1 = require_browser();
    var http_client_1 = require_http_client_browser();
    Object.defineProperty(exports5, "HttpClient", { enumerable: true, get: function() {
      return __importDefault(http_client_1).default;
    } });
    var http_client_factory_1 = require_http_client_factory();
    Object.defineProperty(exports5, "HttpClientFactory", { enumerable: true, get: function() {
      return __importDefault(http_client_factory_1).default;
    } });
    var https_client_factory_1 = require_https_client_factory();
    Object.defineProperty(exports5, "HttpsClientFactory", { enumerable: true, get: function() {
      return __importDefault(https_client_factory_1).default;
    } });
    __exportStar(require_http_client_browser(), exports5);
    __exportStar(require_http_client_factory(), exports5);
    __exportStar(require_https_client_factory(), exports5);
    var HttpHeader = class {
    };
    exports5.HttpHeader = HttpHeader;
    var HttpForm = class extends core_1.Form {
    };
    exports5.HttpForm = HttpForm;
    node_fetch_1.Headers.prototype.raw = function() {
      const result = {};
      for (const [headerKey, headerValue] of this.entries()) {
        result[headerKey] = headerValue.split(",");
      }
      return result;
    };
    node_fetch_1.Response.prototype.buffer = async function() {
      return Buffer.from(await this.arrayBuffer());
    };
  }
});

export {
  require_http_browser
};
//# sourceMappingURL=chunk-V6ZM6XGX.js.map
