"use strict";
var WoT = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-DtuTasat.js
  function dew$2() {
    if (_dewExec$2) return exports$2;
    _dewExec$2 = true;
    exports$2.byteLength = byteLength;
    exports$2.toByteArray = toByteArray;
    exports$2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i5 = 0, len = code.length; i5 < len; ++i5) {
      lookup[i5] = code[i5];
      revLookup[code.charCodeAt(i5)] = i5;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i6;
      for (i6 = 0; i6 < len2; i6 += 4) {
        tmp = revLookup[b64.charCodeAt(i6)] << 18 | revLookup[b64.charCodeAt(i6 + 1)] << 12 | revLookup[b64.charCodeAt(i6 + 2)] << 6 | revLookup[b64.charCodeAt(i6 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i6)] << 2 | revLookup[b64.charCodeAt(i6 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i6)] << 10 | revLookup[b64.charCodeAt(i6 + 1)] << 4 | revLookup[b64.charCodeAt(i6 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i6 = start; i6 < end; i6 += 3) {
        tmp = (uint8[i6] << 16 & 16711680) + (uint8[i6 + 1] << 8 & 65280) + (uint8[i6 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i6 = 0, len22 = len2 - extraBytes; i6 < len22; i6 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i6, i6 + maxChunkLength > len22 ? len22 : i6 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    return exports$2;
  }
  function dew$1() {
    if (_dewExec$1) return exports$1;
    _dewExec$1 = true;
    exports$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e5, m4;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i5 = isLE ? nBytes - 1 : 0;
      var d4 = isLE ? -1 : 1;
      var s5 = buffer2[offset + i5];
      i5 += d4;
      e5 = s5 & (1 << -nBits) - 1;
      s5 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e5 = e5 * 256 + buffer2[offset + i5], i5 += d4, nBits -= 8) {
      }
      m4 = e5 & (1 << -nBits) - 1;
      e5 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m4 = m4 * 256 + buffer2[offset + i5], i5 += d4, nBits -= 8) {
      }
      if (e5 === 0) {
        e5 = 1 - eBias;
      } else if (e5 === eMax) {
        return m4 ? NaN : (s5 ? -1 : 1) * Infinity;
      } else {
        m4 = m4 + Math.pow(2, mLen);
        e5 = e5 - eBias;
      }
      return (s5 ? -1 : 1) * m4 * Math.pow(2, e5 - mLen);
    };
    exports$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e5, m4, c5;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i5 = isLE ? 0 : nBytes - 1;
      var d4 = isLE ? 1 : -1;
      var s5 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m4 = isNaN(value) ? 1 : 0;
        e5 = eMax;
      } else {
        e5 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c5 = Math.pow(2, -e5)) < 1) {
          e5--;
          c5 *= 2;
        }
        if (e5 + eBias >= 1) {
          value += rt / c5;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c5 >= 2) {
          e5++;
          c5 /= 2;
        }
        if (e5 + eBias >= eMax) {
          m4 = 0;
          e5 = eMax;
        } else if (e5 + eBias >= 1) {
          m4 = (value * c5 - 1) * Math.pow(2, mLen);
          e5 = e5 + eBias;
        } else {
          m4 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e5 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i5] = m4 & 255, i5 += d4, m4 /= 256, mLen -= 8) {
      }
      e5 = e5 << mLen | m4;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i5] = e5 & 255, i5 += d4, e5 /= 256, eLen -= 8) {
      }
      buffer2[offset + i5 - d4] |= s5 * 128;
    };
    return exports$1;
  }
  function dew() {
    if (_dewExec) return exports;
    _dewExec = true;
    const base64 = dew$2();
    const ieee754 = dew$1();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e5) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b4 = fromObject(value);
      if (b4) return b4;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i5 = 0; i5 < length; i5 += 1) {
        buf[i5] = array[i5] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer2(b4) {
      return b4 != null && b4._isBuffer === true && b4 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a5, b4) {
      if (isInstance(a5, Uint8Array)) a5 = Buffer3.from(a5, a5.offset, a5.byteLength);
      if (isInstance(b4, Uint8Array)) b4 = Buffer3.from(b4, b4.offset, b4.byteLength);
      if (!Buffer3.isBuffer(a5) || !Buffer3.isBuffer(b4)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a5 === b4) return 0;
      let x3 = a5.length;
      let y5 = b4.length;
      for (let i5 = 0, len = Math.min(x3, y5); i5 < len; ++i5) {
        if (a5[i5] !== b4[i5]) {
          x3 = a5[i5];
          y5 = b4[i5];
          break;
        }
      }
      if (x3 < y5) return -1;
      if (y5 < x3) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i5;
      if (length === void 0) {
        length = 0;
        for (i5 = 0; i5 < list.length; ++i5) {
          length += list[i5].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        let buf = list[i5];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(buffer2, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b4, n5, m4) {
      const i5 = b4[n5];
      b4[n5] = b4[m4];
      b4[m4] = i5;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 2) {
        swap(this, i5, i5 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 4) {
        swap(this, i5, i5 + 3);
        swap(this, i5 + 1, i5 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 8) {
        swap(this, i5, i5 + 7);
        swap(this, i5 + 1, i5 + 6);
        swap(this, i5 + 2, i5 + 5);
        swap(this, i5 + 3, i5 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b4) {
      if (!Buffer3.isBuffer(b4)) throw new TypeError("Argument must be a Buffer");
      if (this === b4) return true;
      return Buffer3.compare(this, b4) === 0;
    };
    Buffer3.prototype.inspect = function inspect2() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x3 = thisEnd - thisStart;
      let y5 = end - start;
      const len = Math.min(x3, y5);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i5 = 0; i5 < len; ++i5) {
        if (thisCopy[i5] !== targetCopy[i5]) {
          x3 = thisCopy[i5];
          y5 = targetCopy[i5];
          break;
        }
      }
      if (x3 < y5) return -1;
      if (y5 < x3) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i6) {
        if (indexSize === 1) {
          return buf[i6];
        } else {
          return buf.readUInt16BE(i6 * indexSize);
        }
      }
      let i5;
      if (dir) {
        let foundIndex = -1;
        for (i5 = byteOffset; i5 < arrLength; i5++) {
          if (read(arr, i5) === read(val, foundIndex === -1 ? 0 : i5 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i5;
            if (i5 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i5 -= i5 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i5 = byteOffset; i5 >= 0; i5--) {
          let found = true;
          for (let j3 = 0; j3 < valLength; j3++) {
            if (read(arr, i5 + j3) !== read(val, j3)) {
              found = false;
              break;
            }
          }
          if (found) return i5;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i5;
      for (i5 = 0; i5 < length; ++i5) {
        const parsed = parseInt(string.substr(i5 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i5;
        buf[offset + i5] = parsed;
      }
      return i5;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i5 = start;
      while (i5 < end) {
        const firstByte = buf[i5];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i5 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i5 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              fourthByte = buf[i5 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i5 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i5 = 0;
      while (i5 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i5, i5 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i5 = start; i5 < end; ++i5) {
        out += hexSliceLookupTable[buf[i5]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i5 = 0; i5 < bytes.length - 1; i5 += 2) {
        res += String.fromCharCode(bytes[i5] + bytes[i5 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i5 = 0;
      while (++i5 < byteLength2 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i5 = 0;
      while (++i5 < byteLength2 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i5 = byteLength2;
      let mul = 1;
      let val = this[offset + --i5];
      while (i5 > 0 && (mul *= 256)) {
        val += this[offset + --i5] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i5 = 0;
      this[offset] = value & 255;
      while (++i5 < byteLength2 && (mul *= 256)) {
        this[offset + i5] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i5 = byteLength2 - 1;
      let mul = 1;
      this[offset + i5] = value & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        this[offset + i5] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i5 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i5 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i5 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i5] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i5 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i5] = value & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i5 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i5] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    const errors = {};
    function E3(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E3("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E3("ERR_INVALID_ARG_TYPE", function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E3("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i5 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i5 >= start + 4; i5 -= 3) {
        res = `_${val.slice(i5 - 3, i5)}${res}`;
      }
      return `${val.slice(0, i5)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n5 = typeof min === "bigint" ? "n" : "";
        let range;
        {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n5} and < 2${n5} ** ${(byteLength2 + 1) * 8}${n5}`;
          } else {
            range = `>= -(2${n5} ** ${(byteLength2 + 1) * 8 - 1}${n5}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n5}`;
          }
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type2) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type2);
        throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE("offset", `>= ${0} and <= ${length}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i5 = 0; i5 < length; ++i5) {
        codePoint = string.charCodeAt(i5);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i5 + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i5 = 0; i5 < str.length; ++i5) {
        byteArray.push(str.charCodeAt(i5) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c5, hi, lo;
      const byteArray = [];
      for (let i5 = 0; i5 < str.length; ++i5) {
        if ((units -= 2) < 0) break;
        c5 = str.charCodeAt(i5);
        hi = c5 >> 8;
        lo = c5 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i5;
      for (i5 = 0; i5 < length; ++i5) {
        if (i5 + offset >= dst.length || i5 >= src.length) break;
        dst[i5 + offset] = src[i5];
      }
      return i5;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i5 = 0; i5 < 16; ++i5) {
        const i16 = i5 * 16;
        for (let j3 = 0; j3 < 16; ++j3) {
          table[i16 + j3] = alphabet[i5] + alphabet[j3];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    return exports;
  }
  var exports$2, _dewExec$2, exports$1, _dewExec$1, exports, _dewExec;
  var init_chunk_DtuTasat = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-DtuTasat.js"() {
      init_buffer2();
      exports$2 = {};
      _dewExec$2 = false;
      exports$1 = {};
      _dewExec$1 = false;
      exports = {};
      _dewExec = false;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/buffer.js
  var buffer_exports = {};
  __export(buffer_exports, {
    Buffer: () => Buffer2,
    INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
    default: () => exports2,
    kMaxLength: () => kMaxLength
  });
  var exports2, Buffer2, INSPECT_MAX_BYTES, kMaxLength;
  var init_buffer = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/buffer.js"() {
      init_buffer2();
      init_chunk_DtuTasat();
      exports2 = dew();
      exports2["Buffer"];
      exports2["SlowBuffer"];
      exports2["INSPECT_MAX_BYTES"];
      exports2["kMaxLength"];
      Buffer2 = exports2.Buffer;
      INSPECT_MAX_BYTES = exports2.INSPECT_MAX_BYTES;
      kMaxLength = exports2.kMaxLength;
    }
  });

  // ../../node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
  var init_buffer2 = __esm({
    "../../node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
      init_buffer();
    }
  });

  // ../core/dist/thing-description.js
  var require_thing_description = __commonJS({
    "../core/dist/thing-description.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.ThingEvent = exports21.ThingAction = exports21.ThingProperty = exports21.BaseSchema = exports21.Form = exports21.Thing = exports21.DEFAULT_THING_TYPE = exports21.DEFAULT_CONTEXT_LANGUAGE = exports21.DEFAULT_CONTEXT_V11 = exports21.DEFAULT_CONTEXT_V1 = void 0;
      exports21.DEFAULT_CONTEXT_V1 = "https://www.w3.org/2019/wot/td/v1";
      exports21.DEFAULT_CONTEXT_V11 = "https://www.w3.org/2022/wot/td/v1.1";
      exports21.DEFAULT_CONTEXT_LANGUAGE = "en";
      exports21.DEFAULT_THING_TYPE = "Thing";
      var Thing = class {
        constructor() {
          this["@context"] = [exports21.DEFAULT_CONTEXT_V1, exports21.DEFAULT_CONTEXT_V11];
          this["@type"] = exports21.DEFAULT_THING_TYPE;
          this.title = "";
          this.securityDefinitions = {};
          this.security = "";
          this.properties = {};
          this.actions = {};
          this.events = {};
          this.links = [];
        }
      };
      exports21.Thing = Thing;
      var Form = class {
        constructor(href, contentType) {
          this.href = href;
          if (contentType != null)
            this.contentType = contentType;
        }
      };
      exports21.Form = Form;
      var BaseSchema = class {
      };
      exports21.BaseSchema = BaseSchema;
      var ThingProperty = class extends BaseSchema {
      };
      exports21.ThingProperty = ThingProperty;
      var ThingAction = class {
      };
      exports21.ThingAction = ThingAction;
      var ThingEvent = class {
      };
      exports21.ThingEvent = ThingEvent;
    }
  });

  // ../../node_modules/ms/index.js
  var require_ms = __commonJS({
    "../../node_modules/ms/index.js"(exports21, module) {
      init_buffer2();
      var s5 = 1e3;
      var m4 = s5 * 60;
      var h5 = m4 * 60;
      var d4 = h5 * 24;
      var w3 = d4 * 7;
      var y5 = d4 * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type2 = typeof val;
        if (type2 === "string" && val.length > 0) {
          return parse3(val);
        } else if (type2 === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse3(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n5 = parseFloat(match[1]);
        var type2 = (match[2] || "ms").toLowerCase();
        switch (type2) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n5 * y5;
          case "weeks":
          case "week":
          case "w":
            return n5 * w3;
          case "days":
          case "day":
          case "d":
            return n5 * d4;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n5 * h5;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n5 * m4;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n5 * s5;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n5;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d4) {
          return Math.round(ms / d4) + "d";
        }
        if (msAbs >= h5) {
          return Math.round(ms / h5) + "h";
        }
        if (msAbs >= m4) {
          return Math.round(ms / m4) + "m";
        }
        if (msAbs >= s5) {
          return Math.round(ms / s5) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d4) {
          return plural(ms, msAbs, d4, "day");
        }
        if (msAbs >= h5) {
          return plural(ms, msAbs, h5, "hour");
        }
        if (msAbs >= m4) {
          return plural(ms, msAbs, m4, "minute");
        }
        if (msAbs >= s5) {
          return plural(ms, msAbs, s5, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n5, name2) {
        var isPlural = msAbs >= n5 * 1.5;
        return Math.round(ms / n5) + " " + name2 + (isPlural ? "s" : "");
      }
    }
  });

  // ../../node_modules/debug/src/common.js
  var require_common = __commonJS({
    "../../node_modules/debug/src/common.js"(exports21, module) {
      init_buffer2();
      function setup(env3) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env3).forEach((key) => {
          createDebug[key] = env3[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i5 = 0; i5 < namespace.length; i5++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i5);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self2 = debug;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format3];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v5) => {
              enableOverride = v5;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
          for (const ns of split) {
            if (ns[0] === "-") {
              createDebug.skips.push(ns.slice(1));
            } else {
              createDebug.names.push(ns);
            }
          }
        }
        function matchesTemplate(search, template) {
          let searchIndex = 0;
          let templateIndex = 0;
          let starIndex = -1;
          let matchIndex = 0;
          while (searchIndex < search.length) {
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
              if (template[templateIndex] === "*") {
                starIndex = templateIndex;
                matchIndex = searchIndex;
                templateIndex++;
              } else {
                searchIndex++;
                templateIndex++;
              }
            } else if (starIndex !== -1) {
              templateIndex = starIndex + 1;
              matchIndex++;
              searchIndex = matchIndex;
            } else {
              return false;
            }
          }
          while (templateIndex < template.length && template[templateIndex] === "*") {
            templateIndex++;
          }
          return templateIndex === template.length;
        }
        function disable() {
          const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name2) {
          for (const skip of createDebug.skips) {
            if (matchesTemplate(name2, skip)) {
              return false;
            }
          }
          for (const ns of createDebug.names) {
            if (matchesTemplate(name2, ns)) {
              return true;
            }
          }
          return false;
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // ../../node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../../node_modules/debug/src/browser.js"(exports21, module) {
      init_buffer2();
      exports21.formatArgs = formatArgs;
      exports21.save = save;
      exports21.load = load;
      exports21.useColors = useColors;
      exports21.storage = localstorage();
      exports21.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports21.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        let m4;
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && (m4 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m4[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c5 = "color: " + this.color;
        args.splice(1, 0, c5, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c5);
      }
      exports21.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports21.storage.setItem("debug", namespaces);
          } else {
            exports21.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r5;
        try {
          r5 = exports21.storage.getItem("debug");
        } catch (error) {
        }
        if (!r5 && typeof process !== "undefined" && "env" in process) {
          r5 = process.env.DEBUG;
        }
        return r5;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports21);
      var { formatters } = module.exports;
      formatters.j = function(v5) {
        try {
          return JSON.stringify(v5);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // ../core/dist/logger.js
  var require_logger = __commonJS({
    "../core/dist/logger.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.createInfoLogger = createInfoLogger;
      exports21.createDebugLogger = createDebugLogger;
      exports21.createWarnLogger = createWarnLogger;
      exports21.createErrorLogger = createErrorLogger;
      exports21.createLoggers = createLoggers;
      var debug_1 = __importDefault(require_browser());
      var LogLevel;
      (function(LogLevel2) {
        LogLevel2[LogLevel2["info"] = 0] = "info";
        LogLevel2[LogLevel2["debug"] = 1] = "debug";
        LogLevel2[LogLevel2["warn"] = 2] = "warn";
        LogLevel2[LogLevel2["error"] = 3] = "error";
      })(LogLevel || (LogLevel = {}));
      function createLogger(namespaces, logLevel) {
        const namespace = ["node-wot", ...namespaces, LogLevel[logLevel]].join(":");
        return (0, debug_1.default)(namespace);
      }
      function createInfoLogger(...namespaces) {
        return createLogger(namespaces, LogLevel.info);
      }
      function createDebugLogger(...namespaces) {
        return createLogger(namespaces, LogLevel.debug);
      }
      function createWarnLogger(...namespaces) {
        return createLogger(namespaces, LogLevel.warn);
      }
      function createErrorLogger(...namespaces) {
        return createLogger(namespaces, LogLevel.error);
      }
      function createLoggers(...namespaces) {
        return {
          info: createInfoLogger(...namespaces),
          debug: createDebugLogger(...namespaces),
          warn: createWarnLogger(...namespaces),
          error: createErrorLogger(...namespaces)
        };
      }
    }
  });

  // ../../node_modules/is-absolute-url/index.js
  var require_is_absolute_url = __commonJS({
    "../../node_modules/is-absolute-url/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      module.exports = (url) => {
        if (typeof url !== "string") {
          throw new TypeError(`Expected a \`string\`, got \`${typeof url}\``);
        }
        if (/^[a-zA-Z]:\\/.test(url)) {
          return false;
        }
        return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url);
      };
    }
  });

  // ../../node_modules/url-toolkit/src/url-toolkit.js
  var require_url_toolkit = __commonJS({
    "../../node_modules/url-toolkit/src/url-toolkit.js"(exports21, module) {
      init_buffer2();
      (function(root) {
        var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
        var FIRST_SEGMENT_REGEX = /^([^\/?#]*)(.*)$/;
        var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
        var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;
        var URLToolkit = {
          // jshint ignore:line
          // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
          // E.g
          // With opts.alwaysNormalize = false (default, spec compliant)
          // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
          // With opts.alwaysNormalize = true (not spec compliant)
          // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
          buildAbsoluteURL: function(baseURL, relativeURL, opts) {
            opts = opts || {};
            baseURL = baseURL.trim();
            relativeURL = relativeURL.trim();
            if (!relativeURL) {
              if (!opts.alwaysNormalize) {
                return baseURL;
              }
              var basePartsForNormalise = URLToolkit.parseURL(baseURL);
              if (!basePartsForNormalise) {
                throw new Error("Error trying to parse base URL.");
              }
              basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
              return URLToolkit.buildURLFromParts(basePartsForNormalise);
            }
            var relativeParts = URLToolkit.parseURL(relativeURL);
            if (!relativeParts) {
              throw new Error("Error trying to parse relative URL.");
            }
            if (relativeParts.scheme) {
              if (!opts.alwaysNormalize) {
                return relativeURL;
              }
              relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
              return URLToolkit.buildURLFromParts(relativeParts);
            }
            var baseParts = URLToolkit.parseURL(baseURL);
            if (!baseParts) {
              throw new Error("Error trying to parse base URL.");
            }
            if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
              var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
              baseParts.netLoc = pathParts[1];
              baseParts.path = pathParts[2];
            }
            if (baseParts.netLoc && !baseParts.path) {
              baseParts.path = "/";
            }
            var builtParts = {
              // 2c) Otherwise, the embedded URL inherits the scheme of
              // the base URL.
              scheme: baseParts.scheme,
              netLoc: relativeParts.netLoc,
              path: null,
              params: relativeParts.params,
              query: relativeParts.query,
              fragment: relativeParts.fragment
            };
            if (!relativeParts.netLoc) {
              builtParts.netLoc = baseParts.netLoc;
              if (relativeParts.path[0] !== "/") {
                if (!relativeParts.path) {
                  builtParts.path = baseParts.path;
                  if (!relativeParts.params) {
                    builtParts.params = baseParts.params;
                    if (!relativeParts.query) {
                      builtParts.query = baseParts.query;
                    }
                  }
                } else {
                  var baseURLPath = baseParts.path;
                  var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                  builtParts.path = URLToolkit.normalizePath(newPath);
                }
              }
            }
            if (builtParts.path === null) {
              builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
            }
            return URLToolkit.buildURLFromParts(builtParts);
          },
          parseURL: function(url) {
            var parts = URL_REGEX.exec(url);
            if (!parts) {
              return null;
            }
            return {
              scheme: parts[1] || "",
              netLoc: parts[2] || "",
              path: parts[3] || "",
              params: parts[4] || "",
              query: parts[5] || "",
              fragment: parts[6] || ""
            };
          },
          normalizePath: function(path2) {
            path2 = path2.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
            while (path2.length !== (path2 = path2.replace(SLASH_DOT_DOT_REGEX, "")).length) {
            }
            return path2.split("").reverse().join("");
          },
          buildURLFromParts: function(parts) {
            return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
          }
        };
        if (typeof exports21 === "object" && typeof module === "object")
          module.exports = URLToolkit;
        else if (typeof define === "function" && define.amd)
          define([], function() {
            return URLToolkit;
          });
        else if (typeof exports21 === "object")
          exports21["URLToolkit"] = URLToolkit;
        else
          root["URLToolkit"] = URLToolkit;
      })(exports21);
    }
  });

  // ../core/dist/serdes.js
  var require_serdes = __commonJS({
    "../core/dist/serdes.js"(exports21) {
      "use strict";
      init_buffer2();
      var __createBinding = exports21 && exports21.__createBinding || (Object.create ? function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m4, k3);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k3];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o5[k22] = m4[k3];
      });
      var __setModuleDefault = exports21 && exports21.__setModuleDefault || (Object.create ? function(o5, v5) {
        Object.defineProperty(o5, "default", { enumerable: true, value: v5 });
      } : function(o5, v5) {
        o5["default"] = v5;
      });
      var __importStar = exports21 && exports21.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o5) {
          ownKeys = Object.getOwnPropertyNames || function(o6) {
            var ar = [];
            for (var k3 in o6) if (Object.prototype.hasOwnProperty.call(o6, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o5);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i5 = 0; i5 < k3.length; i5++) if (k3[i5] !== "default") __createBinding(result, mod, k3[i5]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.setContextLanguage = setContextLanguage;
      exports21.parseTD = parseTD;
      exports21.serializeTD = serializeTD;
      var TD = __importStar(require_thing_description());
      var logger_1 = require_logger();
      var isAbsoluteUrl = require_is_absolute_url();
      var URLToolkit = require_url_toolkit();
      var { debug, warn } = (0, logger_1.createLoggers)("core", "serdes");
      function adjustAffordanceField(thing, affordanceKey) {
        const affordance = thing[affordanceKey];
        if (typeof affordance !== "object" || affordance == null) {
          thing[affordanceKey] = {};
        }
      }
      function adjustBooleanField(affordance, key) {
        const currentValue = affordance[key];
        if (currentValue === void 0 || typeof currentValue !== "boolean") {
          affordance[key] = false;
        }
      }
      function setContextLanguage(thing, language, forceOverride) {
        if (Array.isArray(thing["@context"])) {
          const arrayContext = thing["@context"];
          let languageSet = false;
          for (const arrayEntry of arrayContext) {
            if (typeof arrayEntry === "object") {
              if (arrayEntry["@language"] !== void 0) {
                if (forceOverride) {
                  arrayEntry["@language"] = language;
                }
                languageSet = true;
              }
            }
          }
          if (!languageSet) {
            arrayContext.push({
              "@language": language
            });
          }
        }
      }
      function parseTD(td, normalize) {
        debug(`parseTD() parsing
\`\`\`
${td}
\`\`\``);
        const thing = JSON.parse(td.replace(/^\uFEFF/, ""));
        if (thing["@context"] === void 0) {
          thing["@context"] = [TD.DEFAULT_CONTEXT_V1, TD.DEFAULT_CONTEXT_V11];
        } else if (Array.isArray(thing["@context"])) {
          let semContext = thing["@context"];
          const indexV1 = semContext.indexOf(TD.DEFAULT_CONTEXT_V1);
          const indexV11 = semContext.indexOf(TD.DEFAULT_CONTEXT_V11);
          if (indexV1 === -1 && indexV11 === -1) {
            semContext.unshift(TD.DEFAULT_CONTEXT_V11);
            semContext.unshift(TD.DEFAULT_CONTEXT_V1);
          } else {
            if (indexV1 !== -1 && indexV11 !== -1) {
              semContext = semContext.filter(function(e5) {
                return e5 !== TD.DEFAULT_CONTEXT_V1;
              });
              semContext = semContext.filter(function(e5) {
                return e5 !== TD.DEFAULT_CONTEXT_V11;
              });
              semContext.unshift(TD.DEFAULT_CONTEXT_V11);
              semContext.unshift(TD.DEFAULT_CONTEXT_V1);
            } else {
              if (indexV1 !== -1 && indexV1 !== 0) {
                semContext = semContext.filter(function(e5) {
                  return e5 !== TD.DEFAULT_CONTEXT_V1;
                });
                semContext.unshift(TD.DEFAULT_CONTEXT_V1);
              }
              if (indexV11 !== -1 && indexV11 !== 0) {
                semContext = semContext.filter(function(e5) {
                  return e5 !== TD.DEFAULT_CONTEXT_V11;
                });
                semContext.unshift(TD.DEFAULT_CONTEXT_V11);
              }
            }
            thing["@context"] = semContext;
          }
        } else if (thing["@context"] !== TD.DEFAULT_CONTEXT_V1 && thing["@context"] !== TD.DEFAULT_CONTEXT_V11) {
          const semContext = thing["@context"];
          thing["@context"] = [TD.DEFAULT_CONTEXT_V1, TD.DEFAULT_CONTEXT_V11, semContext];
        }
        setContextLanguage(thing, TD.DEFAULT_CONTEXT_LANGUAGE, false);
        if (thing["@type"] === void 0) {
          thing["@type"] = TD.DEFAULT_THING_TYPE;
        } else if (Array.isArray(thing["@type"])) {
          const semTypes = thing["@type"];
          if (semTypes.indexOf(TD.DEFAULT_THING_TYPE) === -1) {
            semTypes.unshift(TD.DEFAULT_THING_TYPE);
          }
        } else if (thing["@type"] !== TD.DEFAULT_THING_TYPE) {
          const semType = thing["@type"];
          thing["@type"] = [TD.DEFAULT_THING_TYPE, semType];
        }
        for (const property of Object.values(thing.properties ?? {})) {
          for (const key of ["readOnly", "writeOnly", "observable"]) {
            adjustBooleanField(property, key);
          }
        }
        for (const action of Object.values(thing.actions ?? {})) {
          for (const key of ["safe", "idempotent"]) {
            adjustBooleanField(action, key);
          }
        }
        for (const affordanceKey of ["properties", "actions", "events"]) {
          adjustAffordanceField(thing, affordanceKey);
        }
        if (thing.security === void 0) {
          warn("parseTD() found no security metadata");
        }
        if (typeof thing.security === "string") {
          thing.security = [thing.security];
        }
        const allForms = [];
        for (const [propName, prop] of Object.entries(thing.properties ?? {})) {
          if (prop.forms == null) {
            throw new Error(`Property '${propName}' has no forms field`);
          }
          for (const form of prop.forms) {
            if (!form.href) {
              throw new Error(`Form of Property '${propName}' has no href field`);
            }
            if (!isAbsoluteUrl(form.href) && thing.base == null)
              throw new Error(`Form of Property '${propName}' has relative URI while TD has no base field`);
            allForms.push(form);
          }
        }
        for (const [actName, act] of Object.entries(thing.actions ?? {})) {
          if (act.forms == null) {
            throw new Error(`Action '${actName}' has no forms field`);
          }
          for (const form of act.forms) {
            if (!form.href) {
              throw new Error(`Form of Action '${actName}' has no href field`);
            }
            if (!isAbsoluteUrl(form.href) && thing.base == null)
              throw new Error(`Form of Action '${actName}' has relative URI while TD has no base field`);
            allForms.push(form);
          }
        }
        for (const [evtName, evt] of Object.entries(thing.events ?? {})) {
          if (evt.forms == null) {
            throw new Error(`Event '${evtName}' has no forms field`);
          }
          for (const form of evt.forms) {
            if (!form.href) {
              throw new Error(`Form of Event '${evtName}' has no href field`);
            }
            if (!isAbsoluteUrl(form.href) && thing.base == null)
              throw new Error(`Form of Event '${evtName}' has relative URI while TD has no base field`);
            allForms.push(form);
          }
        }
        if (Object.prototype.hasOwnProperty.call(thing, "base")) {
          if (normalize === void 0 || normalize === true) {
            debug("parseTD() normalizing 'base' into 'forms'");
            for (const form of allForms) {
              if (!form.href.match(/^([a-z0-9+-.]+:).+/i)) {
                debug(`parseTDString() applying base '${thing.base}' to '${form.href}'`);
                form.href = URLToolkit.buildAbsoluteURL(thing.base, form.href);
              }
            }
          }
        }
        return thing;
      }
      function serializeTD(thing) {
        const copy = JSON.parse(JSON.stringify(thing));
        if (copy.security == null || copy.security.length === 0) {
          copy.securityDefinitions = {
            nosec_sc: { scheme: "nosec" }
          };
          copy.security = ["nosec_sc"];
        }
        if (copy.forms?.length === 0) {
          delete copy.forms;
        }
        if (copy.properties != null && Object.keys(copy.properties).length === 0) {
          delete copy.properties;
        } else if (copy.properties != null) {
          for (const property of Object.values(copy.properties)) {
            for (const key of ["readOnly", "writeOnly", "observable"]) {
              adjustBooleanField(property, key);
            }
          }
        }
        if (copy.actions != null && Object.keys(copy.actions).length === 0) {
          delete copy.actions;
        } else if (copy.actions != null) {
          for (const action of Object.values(copy.actions)) {
            for (const key of ["safe", "idempotent"]) {
              adjustBooleanField(action, key);
            }
          }
        }
        if (copy.events != null && Object.keys(copy.events).length === 0) {
          delete copy.events;
        }
        if (copy?.links.length === 0) {
          delete copy.links;
        }
        const td = JSON.stringify(copy);
        return td;
      }
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/process.js
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function uptime() {
    return _performance.now() / 1e3;
  }
  function hrtime(previousTimestamp) {
    var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
    var clocktime = _performance.now() * 1e-3;
    var seconds = Math.floor(clocktime) + baseNow;
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += nanoPerSec;
      }
    }
    return [seconds, nanoseconds];
  }
  var env, _performance, nowOffset, nanoPerSec;
  var init_process = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/process.js"() {
      init_buffer2();
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      env = {
        PATH: "/usr/bin",
        LANG: typeof navigator !== "undefined" ? navigator.language + ".UTF-8" : void 0,
        PWD: "/",
        HOME: "/home",
        TMP: "/tmp"
      };
      _performance = {
        now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
        timing: typeof performance !== "undefined" ? performance.timing : void 0
      };
      if (_performance.now === void 0) {
        nowOffset = Date.now();
        if (_performance.timing && _performance.timing.navigationStart) {
          nowOffset = _performance.timing.navigationStart;
        }
        _performance.now = () => Date.now() - nowOffset;
      }
      nanoPerSec = 1e9;
      hrtime.bigint = function(time) {
        var diff = hrtime(time);
        if (typeof BigInt === "undefined") {
          return diff[0] * nanoPerSec + diff[1];
        }
        return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
      };
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/os.js
  var os_exports = {};
  __export(os_exports, {
    EOL: () => EOL,
    arch: () => arch,
    constants: () => constants,
    cpus: () => cpus,
    default: () => exports3,
    endianness: () => endianness,
    freemem: () => freemem,
    getNetworkInterfaces: () => getNetworkInterfaces,
    homedir: () => homedir,
    hostname: () => hostname,
    loadavg: () => loadavg,
    networkInterfaces: () => networkInterfaces,
    platform: () => platform,
    release: () => release,
    tmpDir: () => tmpDir,
    tmpdir: () => tmpdir,
    totalmem: () => totalmem,
    type: () => type,
    uptime: () => uptime,
    version: () => version
  });
  function dew2() {
    if (_dewExec2) return exports$12;
    _dewExec2 = true;
    exports$12.endianness = function() {
      return "LE";
    };
    exports$12.hostname = function() {
      if (typeof location !== "undefined") {
        return location.hostname;
      } else return "";
    };
    exports$12.loadavg = function() {
      return [];
    };
    exports$12.uptime = function() {
      return 0;
    };
    exports$12.freemem = function() {
      return Number.MAX_VALUE;
    };
    exports$12.totalmem = function() {
      return Number.MAX_VALUE;
    };
    exports$12.cpus = function() {
      return [];
    };
    exports$12.type = function() {
      return "Browser";
    };
    exports$12.release = function() {
      if (typeof navigator !== "undefined") {
        return navigator.appVersion;
      }
      return "";
    };
    exports$12.networkInterfaces = exports$12.getNetworkInterfaces = function() {
      return {};
    };
    exports$12.arch = function() {
      return "javascript";
    };
    exports$12.platform = function() {
      return "browser";
    };
    exports$12.tmpdir = exports$12.tmpDir = function() {
      return "/tmp";
    };
    exports$12.EOL = "\n";
    exports$12.homedir = function() {
      return "/";
    };
    return exports$12;
  }
  var exports$12, _dewExec2, exports3, _endianness, version, constants, EOL, arch, cpus, endianness, freemem, getNetworkInterfaces, homedir, hostname, loadavg, networkInterfaces, platform, release, tmpDir, tmpdir, totalmem, type;
  var init_os = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/os.js"() {
      init_buffer2();
      init_process();
      exports$12 = {};
      _dewExec2 = false;
      exports3 = dew2();
      exports3["endianness"];
      exports3["hostname"];
      exports3["loadavg"];
      exports3["uptime"];
      exports3["freemem"];
      exports3["totalmem"];
      exports3["cpus"];
      exports3["type"];
      exports3["release"];
      exports3["networkInterfaces"];
      exports3["getNetworkInterfaces"];
      exports3["arch"];
      exports3["platform"];
      exports3["tmpdir"];
      exports3["tmpDir"];
      exports3["EOL"];
      exports3["homedir"];
      _endianness = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1 ? "LE" : "BE";
      exports3.endianness = function() {
        return _endianness;
      };
      exports3.homedir = function() {
        return "/home";
      };
      exports3.version = function() {
        return "";
      };
      exports3.arch = function() {
        return "x64";
      };
      exports3.totalmem = function() {
        return navigator.deviceMemory !== void 0 ? navigator.deviceMemory * (1 << 30) : 2 * (1 << 30);
      };
      exports3.cpus = function() {
        return Array(navigator.hardwareConcurrency || 0).fill({ model: "", times: {} });
      };
      exports3.uptime = uptime;
      exports3.constants = {};
      version = exports3.version;
      constants = exports3.constants;
      EOL = exports3.EOL;
      arch = exports3.arch;
      cpus = exports3.cpus;
      endianness = exports3.endianness;
      freemem = exports3.freemem;
      getNetworkInterfaces = exports3.getNetworkInterfaces;
      homedir = exports3.homedir;
      hostname = exports3.hostname;
      loadavg = exports3.loadavg;
      networkInterfaces = exports3.networkInterfaces;
      platform = exports3.platform;
      release = exports3.release;
      tmpDir = exports3.tmpDir;
      tmpdir = exports3.tmpdir;
      totalmem = exports3.totalmem;
      type = exports3.type;
    }
  });

  // ../../node_modules/ajv/dist/compile/codegen/code.js
  var require_code = __commonJS({
    "../../node_modules/ajv/dist/compile/codegen/code.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.regexpCode = exports21.getEsmExportName = exports21.getProperty = exports21.safeStringify = exports21.stringify = exports21.strConcat = exports21.addCodeArg = exports21.str = exports21._ = exports21.nil = exports21._Code = exports21.Name = exports21.IDENTIFIER = exports21._CodeOrName = void 0;
      var _CodeOrName = class {
      };
      exports21._CodeOrName = _CodeOrName;
      exports21.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      var Name = class extends _CodeOrName {
        constructor(s5) {
          super();
          if (!exports21.IDENTIFIER.test(s5))
            throw new Error("CodeGen: name must be a valid identifier");
          this.str = s5;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return false;
        }
        get names() {
          return { [this.str]: 1 };
        }
      };
      exports21.Name = Name;
      var _Code = class extends _CodeOrName {
        constructor(code) {
          super();
          this._items = typeof code === "string" ? [code] : code;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1)
            return false;
          const item = this._items[0];
          return item === "" || item === '""';
        }
        get str() {
          var _a;
          return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s5, c5) => `${s5}${c5}`, "");
        }
        get names() {
          var _a;
          return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c5) => {
            if (c5 instanceof Name)
              names[c5.str] = (names[c5.str] || 0) + 1;
            return names;
          }, {});
        }
      };
      exports21._Code = _Code;
      exports21.nil = new _Code("");
      function _3(strs, ...args) {
        const code = [strs[0]];
        let i5 = 0;
        while (i5 < args.length) {
          addCodeArg(code, args[i5]);
          code.push(strs[++i5]);
        }
        return new _Code(code);
      }
      exports21._ = _3;
      var plus = new _Code("+");
      function str(strs, ...args) {
        const expr = [safeStringify(strs[0])];
        let i5 = 0;
        while (i5 < args.length) {
          expr.push(plus);
          addCodeArg(expr, args[i5]);
          expr.push(plus, safeStringify(strs[++i5]));
        }
        optimize(expr);
        return new _Code(expr);
      }
      exports21.str = str;
      function addCodeArg(code, arg) {
        if (arg instanceof _Code)
          code.push(...arg._items);
        else if (arg instanceof Name)
          code.push(arg);
        else
          code.push(interpolate(arg));
      }
      exports21.addCodeArg = addCodeArg;
      function optimize(expr) {
        let i5 = 1;
        while (i5 < expr.length - 1) {
          if (expr[i5] === plus) {
            const res = mergeExprItems(expr[i5 - 1], expr[i5 + 1]);
            if (res !== void 0) {
              expr.splice(i5 - 1, 3, res);
              continue;
            }
            expr[i5++] = "+";
          }
          i5++;
        }
      }
      function mergeExprItems(a5, b4) {
        if (b4 === '""')
          return a5;
        if (a5 === '""')
          return b4;
        if (typeof a5 == "string") {
          if (b4 instanceof Name || a5[a5.length - 1] !== '"')
            return;
          if (typeof b4 != "string")
            return `${a5.slice(0, -1)}${b4}"`;
          if (b4[0] === '"')
            return a5.slice(0, -1) + b4.slice(1);
          return;
        }
        if (typeof b4 == "string" && b4[0] === '"' && !(a5 instanceof Name))
          return `"${a5}${b4.slice(1)}`;
        return;
      }
      function strConcat(c1, c22) {
        return c22.emptyStr() ? c1 : c1.emptyStr() ? c22 : str`${c1}${c22}`;
      }
      exports21.strConcat = strConcat;
      function interpolate(x3) {
        return typeof x3 == "number" || typeof x3 == "boolean" || x3 === null ? x3 : safeStringify(Array.isArray(x3) ? x3.join(",") : x3);
      }
      function stringify2(x3) {
        return new _Code(safeStringify(x3));
      }
      exports21.stringify = stringify2;
      function safeStringify(x3) {
        return JSON.stringify(x3).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      exports21.safeStringify = safeStringify;
      function getProperty(key) {
        return typeof key == "string" && exports21.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _3`[${key}]`;
      }
      exports21.getProperty = getProperty;
      function getEsmExportName(key) {
        if (typeof key == "string" && exports21.IDENTIFIER.test(key)) {
          return new _Code(`${key}`);
        }
        throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
      }
      exports21.getEsmExportName = getEsmExportName;
      function regexpCode(rx) {
        return new _Code(rx.toString());
      }
      exports21.regexpCode = regexpCode;
    }
  });

  // ../../node_modules/ajv/dist/compile/codegen/scope.js
  var require_scope = __commonJS({
    "../../node_modules/ajv/dist/compile/codegen/scope.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.ValueScope = exports21.ValueScopeName = exports21.Scope = exports21.varKinds = exports21.UsedValueState = void 0;
      var code_1 = require_code();
      var ValueError = class extends Error {
        constructor(name2) {
          super(`CodeGen: "code" for ${name2} not defined`);
          this.value = name2.value;
        }
      };
      var UsedValueState;
      (function(UsedValueState2) {
        UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
        UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
      })(UsedValueState || (exports21.UsedValueState = UsedValueState = {}));
      exports21.varKinds = {
        const: new code_1.Name("const"),
        let: new code_1.Name("let"),
        var: new code_1.Name("var")
      };
      var Scope = class {
        constructor({ prefixes, parent } = {}) {
          this._names = {};
          this._prefixes = prefixes;
          this._parent = parent;
        }
        toName(nameOrPrefix) {
          return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
        }
        name(prefix) {
          return new code_1.Name(this._newName(prefix));
        }
        _newName(prefix) {
          const ng = this._names[prefix] || this._nameGroup(prefix);
          return `${prefix}${ng.index++}`;
        }
        _nameGroup(prefix) {
          var _a, _b;
          if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
          }
          return this._names[prefix] = { prefix, index: 0 };
        }
      };
      exports21.Scope = Scope;
      var ValueScopeName = class extends code_1.Name {
        constructor(prefix, nameStr) {
          super(nameStr);
          this.prefix = prefix;
        }
        setValue(value, { property, itemIndex }) {
          this.value = value;
          this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
        }
      };
      exports21.ValueScopeName = ValueScopeName;
      var line = (0, code_1._)`\n`;
      var ValueScope = class extends Scope {
        constructor(opts) {
          super(opts);
          this._values = {};
          this._scope = opts.scope;
          this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
        }
        get() {
          return this._scope;
        }
        name(prefix) {
          return new ValueScopeName(prefix, this._newName(prefix));
        }
        value(nameOrPrefix, value) {
          var _a;
          if (value.ref === void 0)
            throw new Error("CodeGen: ref must be passed in value");
          const name2 = this.toName(nameOrPrefix);
          const { prefix } = name2;
          const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
          let vs = this._values[prefix];
          if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
              return _name;
          } else {
            vs = this._values[prefix] = /* @__PURE__ */ new Map();
          }
          vs.set(valueKey, name2);
          const s5 = this._scope[prefix] || (this._scope[prefix] = []);
          const itemIndex = s5.length;
          s5[itemIndex] = value.ref;
          name2.setValue(value, { property: prefix, itemIndex });
          return name2;
        }
        getValue(prefix, keyOrRef) {
          const vs = this._values[prefix];
          if (!vs)
            return;
          return vs.get(keyOrRef);
        }
        scopeRefs(scopeName, values = this._values) {
          return this._reduceValues(values, (name2) => {
            if (name2.scopePath === void 0)
              throw new Error(`CodeGen: name "${name2}" has no value`);
            return (0, code_1._)`${scopeName}${name2.scopePath}`;
          });
        }
        scopeCode(values = this._values, usedValues, getCode) {
          return this._reduceValues(values, (name2) => {
            if (name2.value === void 0)
              throw new Error(`CodeGen: name "${name2}" has no value`);
            return name2.value.code;
          }, usedValues, getCode);
        }
        _reduceValues(values, valueCode, usedValues = {}, getCode) {
          let code = code_1.nil;
          for (const prefix in values) {
            const vs = values[prefix];
            if (!vs)
              continue;
            const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
            vs.forEach((name2) => {
              if (nameSet.has(name2))
                return;
              nameSet.set(name2, UsedValueState.Started);
              let c5 = valueCode(name2);
              if (c5) {
                const def = this.opts.es5 ? exports21.varKinds.var : exports21.varKinds.const;
                code = (0, code_1._)`${code}${def} ${name2} = ${c5};${this.opts._n}`;
              } else if (c5 = getCode === null || getCode === void 0 ? void 0 : getCode(name2)) {
                code = (0, code_1._)`${code}${c5}${this.opts._n}`;
              } else {
                throw new ValueError(name2);
              }
              nameSet.set(name2, UsedValueState.Completed);
            });
          }
          return code;
        }
      };
      exports21.ValueScope = ValueScope;
    }
  });

  // ../../node_modules/ajv/dist/compile/codegen/index.js
  var require_codegen = __commonJS({
    "../../node_modules/ajv/dist/compile/codegen/index.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.or = exports21.and = exports21.not = exports21.CodeGen = exports21.operators = exports21.varKinds = exports21.ValueScopeName = exports21.ValueScope = exports21.Scope = exports21.Name = exports21.regexpCode = exports21.stringify = exports21.getProperty = exports21.nil = exports21.strConcat = exports21.str = exports21._ = void 0;
      var code_1 = require_code();
      var scope_1 = require_scope();
      var code_2 = require_code();
      Object.defineProperty(exports21, "_", { enumerable: true, get: function() {
        return code_2._;
      } });
      Object.defineProperty(exports21, "str", { enumerable: true, get: function() {
        return code_2.str;
      } });
      Object.defineProperty(exports21, "strConcat", { enumerable: true, get: function() {
        return code_2.strConcat;
      } });
      Object.defineProperty(exports21, "nil", { enumerable: true, get: function() {
        return code_2.nil;
      } });
      Object.defineProperty(exports21, "getProperty", { enumerable: true, get: function() {
        return code_2.getProperty;
      } });
      Object.defineProperty(exports21, "stringify", { enumerable: true, get: function() {
        return code_2.stringify;
      } });
      Object.defineProperty(exports21, "regexpCode", { enumerable: true, get: function() {
        return code_2.regexpCode;
      } });
      Object.defineProperty(exports21, "Name", { enumerable: true, get: function() {
        return code_2.Name;
      } });
      var scope_2 = require_scope();
      Object.defineProperty(exports21, "Scope", { enumerable: true, get: function() {
        return scope_2.Scope;
      } });
      Object.defineProperty(exports21, "ValueScope", { enumerable: true, get: function() {
        return scope_2.ValueScope;
      } });
      Object.defineProperty(exports21, "ValueScopeName", { enumerable: true, get: function() {
        return scope_2.ValueScopeName;
      } });
      Object.defineProperty(exports21, "varKinds", { enumerable: true, get: function() {
        return scope_2.varKinds;
      } });
      exports21.operators = {
        GT: new code_1._Code(">"),
        GTE: new code_1._Code(">="),
        LT: new code_1._Code("<"),
        LTE: new code_1._Code("<="),
        EQ: new code_1._Code("==="),
        NEQ: new code_1._Code("!=="),
        NOT: new code_1._Code("!"),
        OR: new code_1._Code("||"),
        AND: new code_1._Code("&&"),
        ADD: new code_1._Code("+")
      };
      var Node = class {
        optimizeNodes() {
          return this;
        }
        optimizeNames(_names, _constants) {
          return this;
        }
      };
      var Def = class extends Node {
        constructor(varKind, name2, rhs) {
          super();
          this.varKind = varKind;
          this.name = name2;
          this.rhs = rhs;
        }
        render({ es5, _n }) {
          const varKind = es5 ? scope_1.varKinds.var : this.varKind;
          const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${varKind} ${this.name}${rhs};` + _n;
        }
        optimizeNames(names, constants2) {
          if (!names[this.name.str])
            return;
          if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names, constants2);
          return this;
        }
        get names() {
          return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
        }
      };
      var Assign = class extends Node {
        constructor(lhs, rhs, sideEffects) {
          super();
          this.lhs = lhs;
          this.rhs = rhs;
          this.sideEffects = sideEffects;
        }
        render({ _n }) {
          return `${this.lhs} = ${this.rhs};` + _n;
        }
        optimizeNames(names, constants2) {
          if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
            return;
          this.rhs = optimizeExpr(this.rhs, names, constants2);
          return this;
        }
        get names() {
          const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
          return addExprNames(names, this.rhs);
        }
      };
      var AssignOp = class extends Assign {
        constructor(lhs, op, rhs, sideEffects) {
          super(lhs, rhs, sideEffects);
          this.op = op;
        }
        render({ _n }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
        }
      };
      var Label = class extends Node {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          return `${this.label}:` + _n;
        }
      };
      var Break = class extends Node {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          const label = this.label ? ` ${this.label}` : "";
          return `break${label};` + _n;
        }
      };
      var Throw = class extends Node {
        constructor(error) {
          super();
          this.error = error;
        }
        render({ _n }) {
          return `throw ${this.error};` + _n;
        }
        get names() {
          return this.error.names;
        }
      };
      var AnyCode = class extends Node {
        constructor(code) {
          super();
          this.code = code;
        }
        render({ _n }) {
          return `${this.code};` + _n;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(names, constants2) {
          this.code = optimizeExpr(this.code, names, constants2);
          return this;
        }
        get names() {
          return this.code instanceof code_1._CodeOrName ? this.code.names : {};
        }
      };
      var ParentNode = class extends Node {
        constructor(nodes = []) {
          super();
          this.nodes = nodes;
        }
        render(opts) {
          return this.nodes.reduce((code, n5) => code + n5.render(opts), "");
        }
        optimizeNodes() {
          const { nodes } = this;
          let i5 = nodes.length;
          while (i5--) {
            const n5 = nodes[i5].optimizeNodes();
            if (Array.isArray(n5))
              nodes.splice(i5, 1, ...n5);
            else if (n5)
              nodes[i5] = n5;
            else
              nodes.splice(i5, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        optimizeNames(names, constants2) {
          const { nodes } = this;
          let i5 = nodes.length;
          while (i5--) {
            const n5 = nodes[i5];
            if (n5.optimizeNames(names, constants2))
              continue;
            subtractNames(names, n5.names);
            nodes.splice(i5, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((names, n5) => addNames(names, n5.names), {});
        }
      };
      var BlockNode = class extends ParentNode {
        render(opts) {
          return "{" + opts._n + super.render(opts) + "}" + opts._n;
        }
      };
      var Root = class extends ParentNode {
      };
      var Else = class extends BlockNode {
      };
      Else.kind = "else";
      var If = class _If extends BlockNode {
        constructor(condition, nodes) {
          super(nodes);
          this.condition = condition;
        }
        render(opts) {
          let code = `if(${this.condition})` + super.render(opts);
          if (this.else)
            code += "else " + this.else.render(opts);
          return code;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const cond = this.condition;
          if (cond === true)
            return this.nodes;
          let e5 = this.else;
          if (e5) {
            const ns = e5.optimizeNodes();
            e5 = this.else = Array.isArray(ns) ? new Else(ns) : ns;
          }
          if (e5) {
            if (cond === false)
              return e5 instanceof _If ? e5 : e5.nodes;
            if (this.nodes.length)
              return this;
            return new _If(not(cond), e5 instanceof _If ? [e5] : e5.nodes);
          }
          if (cond === false || !this.nodes.length)
            return void 0;
          return this;
        }
        optimizeNames(names, constants2) {
          var _a;
          this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants2);
          if (!(super.optimizeNames(names, constants2) || this.else))
            return;
          this.condition = optimizeExpr(this.condition, names, constants2);
          return this;
        }
        get names() {
          const names = super.names;
          addExprNames(names, this.condition);
          if (this.else)
            addNames(names, this.else.names);
          return names;
        }
      };
      If.kind = "if";
      var For = class extends BlockNode {
      };
      For.kind = "for";
      var ForLoop = class extends For {
        constructor(iteration) {
          super();
          this.iteration = iteration;
        }
        render(opts) {
          return `for(${this.iteration})` + super.render(opts);
        }
        optimizeNames(names, constants2) {
          if (!super.optimizeNames(names, constants2))
            return;
          this.iteration = optimizeExpr(this.iteration, names, constants2);
          return this;
        }
        get names() {
          return addNames(super.names, this.iteration.names);
        }
      };
      var ForRange = class extends For {
        constructor(varKind, name2, from, to) {
          super();
          this.varKind = varKind;
          this.name = name2;
          this.from = from;
          this.to = to;
        }
        render(opts) {
          const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
          const { name: name2, from, to } = this;
          return `for(${varKind} ${name2}=${from}; ${name2}<${to}; ${name2}++)` + super.render(opts);
        }
        get names() {
          const names = addExprNames(super.names, this.from);
          return addExprNames(names, this.to);
        }
      };
      var ForIter = class extends For {
        constructor(loop, varKind, name2, iterable) {
          super();
          this.loop = loop;
          this.varKind = varKind;
          this.name = name2;
          this.iterable = iterable;
        }
        render(opts) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
        }
        optimizeNames(names, constants2) {
          if (!super.optimizeNames(names, constants2))
            return;
          this.iterable = optimizeExpr(this.iterable, names, constants2);
          return this;
        }
        get names() {
          return addNames(super.names, this.iterable.names);
        }
      };
      var Func = class extends BlockNode {
        constructor(name2, args, async) {
          super();
          this.name = name2;
          this.args = args;
          this.async = async;
        }
        render(opts) {
          const _async = this.async ? "async " : "";
          return `${_async}function ${this.name}(${this.args})` + super.render(opts);
        }
      };
      Func.kind = "func";
      var Return = class extends ParentNode {
        render(opts) {
          return "return " + super.render(opts);
        }
      };
      Return.kind = "return";
      var Try = class extends BlockNode {
        render(opts) {
          let code = "try" + super.render(opts);
          if (this.catch)
            code += this.catch.render(opts);
          if (this.finally)
            code += this.finally.render(opts);
          return code;
        }
        optimizeNodes() {
          var _a, _b;
          super.optimizeNodes();
          (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
          return this;
        }
        optimizeNames(names, constants2) {
          var _a, _b;
          super.optimizeNames(names, constants2);
          (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants2);
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants2);
          return this;
        }
        get names() {
          const names = super.names;
          if (this.catch)
            addNames(names, this.catch.names);
          if (this.finally)
            addNames(names, this.finally.names);
          return names;
        }
      };
      var Catch = class extends BlockNode {
        constructor(error) {
          super();
          this.error = error;
        }
        render(opts) {
          return `catch(${this.error})` + super.render(opts);
        }
      };
      Catch.kind = "catch";
      var Finally = class extends BlockNode {
        render(opts) {
          return "finally" + super.render(opts);
        }
      };
      Finally.kind = "finally";
      var CodeGen = class {
        constructor(extScope, opts = {}) {
          this._values = {};
          this._blockStarts = [];
          this._constants = {};
          this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
          this._extScope = extScope;
          this._scope = new scope_1.Scope({ parent: extScope });
          this._nodes = [new Root()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        // returns unique name in the internal scope
        name(prefix) {
          return this._scope.name(prefix);
        }
        // reserves unique name in the external scope
        scopeName(prefix) {
          return this._extScope.name(prefix);
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(prefixOrName, value) {
          const name2 = this._extScope.value(prefixOrName, value);
          const vs = this._values[name2.prefix] || (this._values[name2.prefix] = /* @__PURE__ */ new Set());
          vs.add(name2);
          return name2;
        }
        getScopeValue(prefix, keyOrRef) {
          return this._extScope.getValue(prefix, keyOrRef);
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(scopeName) {
          return this._extScope.scopeRefs(scopeName, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
          const name2 = this._scope.toName(nameOrPrefix);
          if (rhs !== void 0 && constant)
            this._constants[name2.str] = rhs;
          this._leafNode(new Def(varKind, name2, rhs));
          return name2;
        }
        // `const` declaration (`var` in es5 mode)
        const(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
        }
        // `var` declaration with optional assignment
        var(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
        }
        // assignment code
        assign(lhs, rhs, sideEffects) {
          return this._leafNode(new Assign(lhs, rhs, sideEffects));
        }
        // `+=` code
        add(lhs, rhs) {
          return this._leafNode(new AssignOp(lhs, exports21.operators.ADD, rhs));
        }
        // appends passed SafeExpr to code or executes Block
        code(c5) {
          if (typeof c5 == "function")
            c5();
          else if (c5 !== code_1.nil)
            this._leafNode(new AnyCode(c5));
          return this;
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...keyValues) {
          const code = ["{"];
          for (const [key, value] of keyValues) {
            if (code.length > 1)
              code.push(",");
            code.push(key);
            if (key !== value || this.opts.es5) {
              code.push(":");
              (0, code_1.addCodeArg)(code, value);
            }
          }
          code.push("}");
          return new code_1._Code(code);
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(condition, thenBody, elseBody) {
          this._blockNode(new If(condition));
          if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
          } else if (thenBody) {
            this.code(thenBody).endIf();
          } else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
          }
          return this;
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(condition) {
          return this._elseNode(new If(condition));
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new Else());
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(If, Else);
        }
        _for(node, forBody) {
          this._blockNode(node);
          if (forBody)
            this.code(forBody).endFor();
          return this;
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(iteration, forBody) {
          return this._for(new ForLoop(iteration), forBody);
        }
        // `for` statement for a range of values
        forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
          const name2 = this._scope.toName(nameOrPrefix);
          return this._for(new ForRange(varKind, name2, from, to), () => forBody(name2));
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
          const name2 = this._scope.toName(nameOrPrefix);
          if (this.opts.es5) {
            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i5) => {
              this.var(name2, (0, code_1._)`${arr}[${i5}]`);
              forBody(name2);
            });
          }
          return this._for(new ForIter("of", varKind, name2, iterable), () => forBody(name2));
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
          if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
          }
          const name2 = this._scope.toName(nameOrPrefix);
          return this._for(new ForIter("in", varKind, name2, obj), () => forBody(name2));
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(For);
        }
        // `label` statement
        label(label) {
          return this._leafNode(new Label(label));
        }
        // `break` statement
        break(label) {
          return this._leafNode(new Break(label));
        }
        // `return` statement
        return(value) {
          const node = new Return();
          this._blockNode(node);
          this.code(value);
          if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(Return);
        }
        // `try` statement
        try(tryBody, catchCode, finallyCode) {
          if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const node = new Try();
          this._blockNode(node);
          this.code(tryBody);
          if (catchCode) {
            const error = this.name("e");
            this._currNode = node.catch = new Catch(error);
            catchCode(error);
          }
          if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
          }
          return this._endBlockNode(Catch, Finally);
        }
        // `throw` statement
        throw(error) {
          return this._leafNode(new Throw(error));
        }
        // start self-balancing block
        block(body, nodeCount) {
          this._blockStarts.push(this._nodes.length);
          if (body)
            this.code(body).endBlock(nodeCount);
          return this;
        }
        // end the current self-balancing block
        endBlock(nodeCount) {
          const len = this._blockStarts.pop();
          if (len === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const toClose = this._nodes.length - len;
          if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
          }
          this._nodes.length = len;
          return this;
        }
        // `function` heading (or definition if funcBody is passed)
        func(name2, args = code_1.nil, async, funcBody) {
          this._blockNode(new Func(name2, args, async));
          if (funcBody)
            this.code(funcBody).endFunc();
          return this;
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(Func);
        }
        optimize(n5 = 1) {
          while (n5-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
          }
        }
        _leafNode(node) {
          this._currNode.nodes.push(node);
          return this;
        }
        _blockNode(node) {
          this._currNode.nodes.push(node);
          this._nodes.push(node);
        }
        _endBlockNode(N1, N22) {
          const n5 = this._currNode;
          if (n5 instanceof N1 || N22 && n5 instanceof N22) {
            this._nodes.pop();
            return this;
          }
          throw new Error(`CodeGen: not in block "${N22 ? `${N1.kind}/${N22.kind}` : N1.kind}"`);
        }
        _elseNode(node) {
          const n5 = this._currNode;
          if (!(n5 instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
          }
          this._currNode = n5.else = node;
          return this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const ns = this._nodes;
          return ns[ns.length - 1];
        }
        set _currNode(node) {
          const ns = this._nodes;
          ns[ns.length - 1] = node;
        }
      };
      exports21.CodeGen = CodeGen;
      function addNames(names, from) {
        for (const n5 in from)
          names[n5] = (names[n5] || 0) + (from[n5] || 0);
        return names;
      }
      function addExprNames(names, from) {
        return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
      }
      function optimizeExpr(expr, names, constants2) {
        if (expr instanceof code_1.Name)
          return replaceName(expr);
        if (!canOptimize(expr))
          return expr;
        return new code_1._Code(expr._items.reduce((items, c5) => {
          if (c5 instanceof code_1.Name)
            c5 = replaceName(c5);
          if (c5 instanceof code_1._Code)
            items.push(...c5._items);
          else
            items.push(c5);
          return items;
        }, []));
        function replaceName(n5) {
          const c5 = constants2[n5.str];
          if (c5 === void 0 || names[n5.str] !== 1)
            return n5;
          delete names[n5.str];
          return c5;
        }
        function canOptimize(e5) {
          return e5 instanceof code_1._Code && e5._items.some((c5) => c5 instanceof code_1.Name && names[c5.str] === 1 && constants2[c5.str] !== void 0);
        }
      }
      function subtractNames(names, from) {
        for (const n5 in from)
          names[n5] = (names[n5] || 0) - (from[n5] || 0);
      }
      function not(x3) {
        return typeof x3 == "boolean" || typeof x3 == "number" || x3 === null ? !x3 : (0, code_1._)`!${par(x3)}`;
      }
      exports21.not = not;
      var andCode = mappend(exports21.operators.AND);
      function and(...args) {
        return args.reduce(andCode);
      }
      exports21.and = and;
      var orCode = mappend(exports21.operators.OR);
      function or(...args) {
        return args.reduce(orCode);
      }
      exports21.or = or;
      function mappend(op) {
        return (x3, y5) => x3 === code_1.nil ? y5 : y5 === code_1.nil ? x3 : (0, code_1._)`${par(x3)} ${op} ${par(y5)}`;
      }
      function par(x3) {
        return x3 instanceof code_1.Name ? x3 : (0, code_1._)`(${x3})`;
      }
    }
  });

  // ../../node_modules/ajv/dist/compile/util.js
  var require_util = __commonJS({
    "../../node_modules/ajv/dist/compile/util.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.checkStrictMode = exports21.getErrorPath = exports21.Type = exports21.useFunc = exports21.setEvaluated = exports21.evaluatedPropsToName = exports21.mergeEvaluated = exports21.eachItem = exports21.unescapeJsonPointer = exports21.escapeJsonPointer = exports21.escapeFragment = exports21.unescapeFragment = exports21.schemaRefOrVal = exports21.schemaHasRulesButRef = exports21.schemaHasRules = exports21.checkUnknownRules = exports21.alwaysValidSchema = exports21.toHash = void 0;
      var codegen_1 = require_codegen();
      var code_1 = require_code();
      function toHash(arr) {
        const hash = {};
        for (const item of arr)
          hash[item] = true;
        return hash;
      }
      exports21.toHash = toHash;
      function alwaysValidSchema(it, schema) {
        if (typeof schema == "boolean")
          return schema;
        if (Object.keys(schema).length === 0)
          return true;
        checkUnknownRules(it, schema);
        return !schemaHasRules(schema, it.self.RULES.all);
      }
      exports21.alwaysValidSchema = alwaysValidSchema;
      function checkUnknownRules(it, schema = it.schema) {
        const { opts, self: self2 } = it;
        if (!opts.strictSchema)
          return;
        if (typeof schema === "boolean")
          return;
        const rules = self2.RULES.keywords;
        for (const key in schema) {
          if (!rules[key])
            checkStrictMode(it, `unknown keyword: "${key}"`);
        }
      }
      exports21.checkUnknownRules = checkUnknownRules;
      function schemaHasRules(schema, rules) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (rules[key])
            return true;
        return false;
      }
      exports21.schemaHasRules = schemaHasRules;
      function schemaHasRulesButRef(schema, RULES) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (key !== "$ref" && RULES.all[key])
            return true;
        return false;
      }
      exports21.schemaHasRulesButRef = schemaHasRulesButRef;
      function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
        if (!$data) {
          if (typeof schema == "number" || typeof schema == "boolean")
            return schema;
          if (typeof schema == "string")
            return (0, codegen_1._)`${schema}`;
        }
        return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
      }
      exports21.schemaRefOrVal = schemaRefOrVal;
      function unescapeFragment(str) {
        return unescapeJsonPointer(decodeURIComponent(str));
      }
      exports21.unescapeFragment = unescapeFragment;
      function escapeFragment(str) {
        return encodeURIComponent(escapeJsonPointer(str));
      }
      exports21.escapeFragment = escapeFragment;
      function escapeJsonPointer(str) {
        if (typeof str == "number")
          return `${str}`;
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      exports21.escapeJsonPointer = escapeJsonPointer;
      function unescapeJsonPointer(str) {
        return str.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      exports21.unescapeJsonPointer = unescapeJsonPointer;
      function eachItem(xs, f5) {
        if (Array.isArray(xs)) {
          for (const x3 of xs)
            f5(x3);
        } else {
          f5(xs);
        }
      }
      exports21.eachItem = eachItem;
      function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
        return (gen, from, to, toName) => {
          const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
          return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
        };
      }
      exports21.mergeEvaluated = {
        props: makeMergeEvaluated({
          mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
            gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
          }),
          mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
            if (from === true) {
              gen.assign(to, true);
            } else {
              gen.assign(to, (0, codegen_1._)`${to} || {}`);
              setEvaluated(gen, to, from);
            }
          }),
          mergeValues: (from, to) => from === true ? true : { ...from, ...to },
          resultToName: evaluatedPropsToName
        }),
        items: makeMergeEvaluated({
          mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
          mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
          mergeValues: (from, to) => from === true ? true : Math.max(from, to),
          resultToName: (gen, items) => gen.var("items", items)
        })
      };
      function evaluatedPropsToName(gen, ps) {
        if (ps === true)
          return gen.var("props", true);
        const props = gen.var("props", (0, codegen_1._)`{}`);
        if (ps !== void 0)
          setEvaluated(gen, props, ps);
        return props;
      }
      exports21.evaluatedPropsToName = evaluatedPropsToName;
      function setEvaluated(gen, props, ps) {
        Object.keys(ps).forEach((p5) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p5)}`, true));
      }
      exports21.setEvaluated = setEvaluated;
      var snippets = {};
      function useFunc(gen, f5) {
        return gen.scopeValue("func", {
          ref: f5,
          code: snippets[f5.code] || (snippets[f5.code] = new code_1._Code(f5.code))
        });
      }
      exports21.useFunc = useFunc;
      var Type;
      (function(Type2) {
        Type2[Type2["Num"] = 0] = "Num";
        Type2[Type2["Str"] = 1] = "Str";
      })(Type || (exports21.Type = Type = {}));
      function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
        if (dataProp instanceof codegen_1.Name) {
          const isNumber2 = dataPropType === Type.Num;
          return jsPropertySyntax ? isNumber2 ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
        }
        return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
      }
      exports21.getErrorPath = getErrorPath;
      function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
        if (!mode)
          return;
        msg = `strict mode: ${msg}`;
        if (mode === true)
          throw new Error(msg);
        it.self.logger.warn(msg);
      }
      exports21.checkStrictMode = checkStrictMode;
    }
  });

  // ../../node_modules/ajv/dist/compile/names.js
  var require_names = __commonJS({
    "../../node_modules/ajv/dist/compile/names.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var names = {
        // validation function arguments
        data: new codegen_1.Name("data"),
        // data passed to validation function
        // args passed from referencing schema
        valCxt: new codegen_1.Name("valCxt"),
        // validation/data context - should not be used directly, it is destructured to the names below
        instancePath: new codegen_1.Name("instancePath"),
        parentData: new codegen_1.Name("parentData"),
        parentDataProperty: new codegen_1.Name("parentDataProperty"),
        rootData: new codegen_1.Name("rootData"),
        // root data - same as the data passed to the first/top validation function
        dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
        // used to support recursiveRef and dynamicRef
        // function scoped variables
        vErrors: new codegen_1.Name("vErrors"),
        // null or array of validation errors
        errors: new codegen_1.Name("errors"),
        // counter of validation errors
        this: new codegen_1.Name("this"),
        // "globals"
        self: new codegen_1.Name("self"),
        scope: new codegen_1.Name("scope"),
        // JTD serialize/parse name for JSON string and position
        json: new codegen_1.Name("json"),
        jsonPos: new codegen_1.Name("jsonPos"),
        jsonLen: new codegen_1.Name("jsonLen"),
        jsonPart: new codegen_1.Name("jsonPart")
      };
      exports21.default = names;
    }
  });

  // ../../node_modules/ajv/dist/compile/errors.js
  var require_errors = __commonJS({
    "../../node_modules/ajv/dist/compile/errors.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.extendErrors = exports21.resetErrorsCount = exports21.reportExtraError = exports21.reportError = exports21.keyword$DataError = exports21.keywordError = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var names_1 = require_names();
      exports21.keywordError = {
        message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
      };
      exports21.keyword$DataError = {
        message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
      };
      function reportError(cxt, error = exports21.keywordError, errorPaths, overrideAllErrors) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
          addError(gen, errObj);
        } else {
          returnErrors(it, (0, codegen_1._)`[${errObj}]`);
        }
      }
      exports21.reportError = reportError;
      function reportExtraError(cxt, error = exports21.keywordError, errorPaths) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        addError(gen, errObj);
        if (!(compositeRule || allErrors)) {
          returnErrors(it, names_1.default.vErrors);
        }
      }
      exports21.reportExtraError = reportExtraError;
      function resetErrorsCount(gen, errsCount) {
        gen.assign(names_1.default.errors, errsCount);
        gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
      }
      exports21.resetErrorsCount = resetErrorsCount;
      function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
        if (errsCount === void 0)
          throw new Error("ajv implementation error");
        const err = gen.name("err");
        gen.forRange("i", errsCount, names_1.default.errors, (i5) => {
          gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i5}]`);
          gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
          gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
          if (it.opts.verbose) {
            gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
            gen.assign((0, codegen_1._)`${err}.data`, data);
          }
        });
      }
      exports21.extendErrors = extendErrors;
      function addError(gen, errObj) {
        const err = gen.const("err", errObj);
        gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
        gen.code((0, codegen_1._)`${names_1.default.errors}++`);
      }
      function returnErrors(it, errs) {
        const { gen, validateName, schemaEnv } = it;
        if (schemaEnv.$async) {
          gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
          gen.return(false);
        }
      }
      var E3 = {
        keyword: new codegen_1.Name("keyword"),
        schemaPath: new codegen_1.Name("schemaPath"),
        // also used in JTD errors
        params: new codegen_1.Name("params"),
        propertyName: new codegen_1.Name("propertyName"),
        message: new codegen_1.Name("message"),
        schema: new codegen_1.Name("schema"),
        parentSchema: new codegen_1.Name("parentSchema")
      };
      function errorObjectCode(cxt, error, errorPaths) {
        const { createErrors } = cxt.it;
        if (createErrors === false)
          return (0, codegen_1._)`{}`;
        return errorObject(cxt, error, errorPaths);
      }
      function errorObject(cxt, error, errorPaths = {}) {
        const { gen, it } = cxt;
        const keyValues = [
          errorInstancePath(it, errorPaths),
          errorSchemaPath(cxt, errorPaths)
        ];
        extraErrorProps(cxt, error, keyValues);
        return gen.object(...keyValues);
      }
      function errorInstancePath({ errorPath }, { instancePath }) {
        const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
        return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
      }
      function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
        let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
        if (schemaPath) {
          schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
        }
        return [E3.schemaPath, schPath];
      }
      function extraErrorProps(cxt, { params, message }, keyValues) {
        const { keyword, data, schemaValue, it } = cxt;
        const { opts, propertyName, topSchemaRef, schemaPath } = it;
        keyValues.push([E3.keyword, keyword], [E3.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
        if (opts.messages) {
          keyValues.push([E3.message, typeof message == "function" ? message(cxt) : message]);
        }
        if (opts.verbose) {
          keyValues.push([E3.schema, schemaValue], [E3.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
        }
        if (propertyName)
          keyValues.push([E3.propertyName, propertyName]);
      }
    }
  });

  // ../../node_modules/ajv/dist/compile/validate/boolSchema.js
  var require_boolSchema = __commonJS({
    "../../node_modules/ajv/dist/compile/validate/boolSchema.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.boolOrEmptySchema = exports21.topBoolOrEmptySchema = void 0;
      var errors_1 = require_errors();
      var codegen_1 = require_codegen();
      var names_1 = require_names();
      var boolError = {
        message: "boolean schema is false"
      };
      function topBoolOrEmptySchema(it) {
        const { gen, schema, validateName } = it;
        if (schema === false) {
          falseSchemaError(it, false);
        } else if (typeof schema == "object" && schema.$async === true) {
          gen.return(names_1.default.data);
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, null);
          gen.return(true);
        }
      }
      exports21.topBoolOrEmptySchema = topBoolOrEmptySchema;
      function boolOrEmptySchema(it, valid) {
        const { gen, schema } = it;
        if (schema === false) {
          gen.var(valid, false);
          falseSchemaError(it);
        } else {
          gen.var(valid, true);
        }
      }
      exports21.boolOrEmptySchema = boolOrEmptySchema;
      function falseSchemaError(it, overrideAllErrors) {
        const { gen, data } = it;
        const cxt = {
          gen,
          keyword: "false schema",
          data,
          schema: false,
          schemaCode: false,
          schemaValue: false,
          params: {},
          it
        };
        (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
      }
    }
  });

  // ../../node_modules/ajv/dist/compile/rules.js
  var require_rules = __commonJS({
    "../../node_modules/ajv/dist/compile/rules.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.getRules = exports21.isJSONType = void 0;
      var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
      var jsonTypes = new Set(_jsonTypes);
      function isJSONType(x3) {
        return typeof x3 == "string" && jsonTypes.has(x3);
      }
      exports21.isJSONType = isJSONType;
      function getRules() {
        const groups = {
          number: { type: "number", rules: [] },
          string: { type: "string", rules: [] },
          array: { type: "array", rules: [] },
          object: { type: "object", rules: [] }
        };
        return {
          types: { ...groups, integer: true, boolean: true, null: true },
          rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
          post: { rules: [] },
          all: {},
          keywords: {}
        };
      }
      exports21.getRules = getRules;
    }
  });

  // ../../node_modules/ajv/dist/compile/validate/applicability.js
  var require_applicability = __commonJS({
    "../../node_modules/ajv/dist/compile/validate/applicability.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.shouldUseRule = exports21.shouldUseGroup = exports21.schemaHasRulesForType = void 0;
      function schemaHasRulesForType({ schema, self: self2 }, type2) {
        const group = self2.RULES.types[type2];
        return group && group !== true && shouldUseGroup(schema, group);
      }
      exports21.schemaHasRulesForType = schemaHasRulesForType;
      function shouldUseGroup(schema, group) {
        return group.rules.some((rule) => shouldUseRule(schema, rule));
      }
      exports21.shouldUseGroup = shouldUseGroup;
      function shouldUseRule(schema, rule) {
        var _a;
        return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
      }
      exports21.shouldUseRule = shouldUseRule;
    }
  });

  // ../../node_modules/ajv/dist/compile/validate/dataType.js
  var require_dataType = __commonJS({
    "../../node_modules/ajv/dist/compile/validate/dataType.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.reportTypeError = exports21.checkDataTypes = exports21.checkDataType = exports21.coerceAndCheckDataType = exports21.getJSONTypes = exports21.getSchemaTypes = exports21.DataType = void 0;
      var rules_1 = require_rules();
      var applicability_1 = require_applicability();
      var errors_1 = require_errors();
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var DataType;
      (function(DataType2) {
        DataType2[DataType2["Correct"] = 0] = "Correct";
        DataType2[DataType2["Wrong"] = 1] = "Wrong";
      })(DataType || (exports21.DataType = DataType = {}));
      function getSchemaTypes(schema) {
        const types2 = getJSONTypes(schema.type);
        const hasNull = types2.includes("null");
        if (hasNull) {
          if (schema.nullable === false)
            throw new Error("type: null contradicts nullable: false");
        } else {
          if (!types2.length && schema.nullable !== void 0) {
            throw new Error('"nullable" cannot be used without "type"');
          }
          if (schema.nullable === true)
            types2.push("null");
        }
        return types2;
      }
      exports21.getSchemaTypes = getSchemaTypes;
      function getJSONTypes(ts) {
        const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
        if (types2.every(rules_1.isJSONType))
          return types2;
        throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
      }
      exports21.getJSONTypes = getJSONTypes;
      function coerceAndCheckDataType(it, types2) {
        const { gen, data, opts } = it;
        const coerceTo = coerceToTypes(types2, opts.coerceTypes);
        const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
        if (checkTypes) {
          const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
          gen.if(wrongType, () => {
            if (coerceTo.length)
              coerceData(it, types2, coerceTo);
            else
              reportTypeError(it);
          });
        }
        return checkTypes;
      }
      exports21.coerceAndCheckDataType = coerceAndCheckDataType;
      var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
      function coerceToTypes(types2, coerceTypes) {
        return coerceTypes ? types2.filter((t5) => COERCIBLE.has(t5) || coerceTypes === "array" && t5 === "array") : [];
      }
      function coerceData(it, types2, coerceTo) {
        const { gen, data, opts } = it;
        const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
        const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
        if (opts.coerceTypes === "array") {
          gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
        }
        gen.if((0, codegen_1._)`${coerced} !== undefined`);
        for (const t5 of coerceTo) {
          if (COERCIBLE.has(t5) || t5 === "array" && opts.coerceTypes === "array") {
            coerceSpecificType(t5);
          }
        }
        gen.else();
        reportTypeError(it);
        gen.endIf();
        gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
          gen.assign(data, coerced);
          assignParentData(it, coerced);
        });
        function coerceSpecificType(t5) {
          switch (t5) {
            case "string":
              gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
              return;
            case "number":
              gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
              return;
            case "integer":
              gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
              return;
            case "boolean":
              gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
              return;
            case "null":
              gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
              gen.assign(coerced, null);
              return;
            case "array":
              gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
          }
        }
      }
      function assignParentData({ gen, parentData, parentDataProperty }, expr) {
        gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
      }
      function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
        const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
        let cond;
        switch (dataType) {
          case "null":
            return (0, codegen_1._)`${data} ${EQ} null`;
          case "array":
            cond = (0, codegen_1._)`Array.isArray(${data})`;
            break;
          case "object":
            cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
            break;
          case "integer":
            cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
            break;
          case "number":
            cond = numCond();
            break;
          default:
            return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
        }
        return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
        function numCond(_cond = codegen_1.nil) {
          return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
        }
      }
      exports21.checkDataType = checkDataType;
      function checkDataTypes(dataTypes, data, strictNums, correct) {
        if (dataTypes.length === 1) {
          return checkDataType(dataTypes[0], data, strictNums, correct);
        }
        let cond;
        const types2 = (0, util_1.toHash)(dataTypes);
        if (types2.array && types2.object) {
          const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
          cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
          delete types2.null;
          delete types2.array;
          delete types2.object;
        } else {
          cond = codegen_1.nil;
        }
        if (types2.number)
          delete types2.integer;
        for (const t5 in types2)
          cond = (0, codegen_1.and)(cond, checkDataType(t5, data, strictNums, correct));
        return cond;
      }
      exports21.checkDataTypes = checkDataTypes;
      var typeError = {
        message: ({ schema }) => `must be ${schema}`,
        params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
      };
      function reportTypeError(it) {
        const cxt = getTypeErrorContext(it);
        (0, errors_1.reportError)(cxt, typeError);
      }
      exports21.reportTypeError = reportTypeError;
      function getTypeErrorContext(it) {
        const { gen, data, schema } = it;
        const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
        return {
          gen,
          keyword: "type",
          data,
          schema: schema.type,
          schemaCode,
          schemaValue: schemaCode,
          parentSchema: schema,
          params: {},
          it
        };
      }
    }
  });

  // ../../node_modules/ajv/dist/compile/validate/defaults.js
  var require_defaults = __commonJS({
    "../../node_modules/ajv/dist/compile/validate/defaults.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.assignDefaults = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      function assignDefaults(it, ty) {
        const { properties, items } = it.schema;
        if (ty === "object" && properties) {
          for (const key in properties) {
            assignDefault(it, key, properties[key].default);
          }
        } else if (ty === "array" && Array.isArray(items)) {
          items.forEach((sch, i5) => assignDefault(it, i5, sch.default));
        }
      }
      exports21.assignDefaults = assignDefaults;
      function assignDefault(it, prop, defaultValue) {
        const { gen, compositeRule, data, opts } = it;
        if (defaultValue === void 0)
          return;
        const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
        if (compositeRule) {
          (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
          return;
        }
        let condition = (0, codegen_1._)`${childData} === undefined`;
        if (opts.useDefaults === "empty") {
          condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
        }
        gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
      }
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/code.js
  var require_code2 = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/code.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.validateUnion = exports21.validateArray = exports21.usePattern = exports21.callValidateCode = exports21.schemaProperties = exports21.allSchemaProperties = exports21.noPropertyInData = exports21.propertyInData = exports21.isOwnProperty = exports21.hasPropFunc = exports21.reportMissingProp = exports21.checkMissingProp = exports21.checkReportMissingProp = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var names_1 = require_names();
      var util_2 = require_util();
      function checkReportMissingProp(cxt, prop) {
        const { gen, data, it } = cxt;
        gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
          cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
          cxt.error();
        });
      }
      exports21.checkReportMissingProp = checkReportMissingProp;
      function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
        return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
      }
      exports21.checkMissingProp = checkMissingProp;
      function reportMissingProp(cxt, missing) {
        cxt.setParams({ missingProperty: missing }, true);
        cxt.error();
      }
      exports21.reportMissingProp = reportMissingProp;
      function hasPropFunc(gen) {
        return gen.scopeValue("func", {
          // eslint-disable-next-line @typescript-eslint/unbound-method
          ref: Object.prototype.hasOwnProperty,
          code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
        });
      }
      exports21.hasPropFunc = hasPropFunc;
      function isOwnProperty(gen, data, property) {
        return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
      }
      exports21.isOwnProperty = isOwnProperty;
      function propertyInData(gen, data, property, ownProperties) {
        const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
        return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
      }
      exports21.propertyInData = propertyInData;
      function noPropertyInData(gen, data, property, ownProperties) {
        const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
        return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
      }
      exports21.noPropertyInData = noPropertyInData;
      function allSchemaProperties(schemaMap) {
        return schemaMap ? Object.keys(schemaMap).filter((p5) => p5 !== "__proto__") : [];
      }
      exports21.allSchemaProperties = allSchemaProperties;
      function schemaProperties(it, schemaMap) {
        return allSchemaProperties(schemaMap).filter((p5) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p5]));
      }
      exports21.schemaProperties = schemaProperties;
      function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
        const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
        const valCxt = [
          [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
          [names_1.default.parentData, it.parentData],
          [names_1.default.parentDataProperty, it.parentDataProperty],
          [names_1.default.rootData, names_1.default.rootData]
        ];
        if (it.opts.dynamicRef)
          valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
        const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
        return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
      }
      exports21.callValidateCode = callValidateCode;
      var newRegExp = (0, codegen_1._)`new RegExp`;
      function usePattern({ gen, it: { opts } }, pattern) {
        const u5 = opts.unicodeRegExp ? "u" : "";
        const { regExp } = opts.code;
        const rx = regExp(pattern, u5);
        return gen.scopeValue("pattern", {
          key: rx.toString(),
          ref: rx,
          code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u5})`
        });
      }
      exports21.usePattern = usePattern;
      function validateArray(cxt) {
        const { gen, data, keyword, it } = cxt;
        const valid = gen.name("valid");
        if (it.allErrors) {
          const validArr = gen.let("valid", true);
          validateItems(() => gen.assign(validArr, false));
          return validArr;
        }
        gen.var(valid, true);
        validateItems(() => gen.break());
        return valid;
        function validateItems(notValid) {
          const len = gen.const("len", (0, codegen_1._)`${data}.length`);
          gen.forRange("i", 0, len, (i5) => {
            cxt.subschema({
              keyword,
              dataProp: i5,
              dataPropType: util_1.Type.Num
            }, valid);
            gen.if((0, codegen_1.not)(valid), notValid);
          });
        }
      }
      exports21.validateArray = validateArray;
      function validateUnion(cxt) {
        const { gen, schema, keyword, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
        if (alwaysValid && !it.opts.unevaluated)
          return;
        const valid = gen.let("valid", false);
        const schValid = gen.name("_valid");
        gen.block(() => schema.forEach((_sch, i5) => {
          const schCxt = cxt.subschema({
            keyword,
            schemaProp: i5,
            compositeRule: true
          }, schValid);
          gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
          const merged = cxt.mergeValidEvaluated(schCxt, schValid);
          if (!merged)
            gen.if((0, codegen_1.not)(valid));
        }));
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      }
      exports21.validateUnion = validateUnion;
    }
  });

  // ../../node_modules/ajv/dist/compile/validate/keyword.js
  var require_keyword = __commonJS({
    "../../node_modules/ajv/dist/compile/validate/keyword.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.validateKeywordUsage = exports21.validSchemaType = exports21.funcKeywordCode = exports21.macroKeywordCode = void 0;
      var codegen_1 = require_codegen();
      var names_1 = require_names();
      var code_1 = require_code2();
      var errors_1 = require_errors();
      function macroKeywordCode(cxt, def) {
        const { gen, keyword, schema, parentSchema, it } = cxt;
        const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
        const schemaRef = useKeyword(gen, keyword, macroSchema);
        if (it.opts.validateSchema !== false)
          it.self.validateSchema(macroSchema, true);
        const valid = gen.name("valid");
        cxt.subschema({
          schema: macroSchema,
          schemaPath: codegen_1.nil,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`,
          topSchemaRef: schemaRef,
          compositeRule: true
        }, valid);
        cxt.pass(valid, () => cxt.error(true));
      }
      exports21.macroKeywordCode = macroKeywordCode;
      function funcKeywordCode(cxt, def) {
        var _a;
        const { gen, keyword, schema, parentSchema, $data, it } = cxt;
        checkAsyncKeyword(it, def);
        const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
        const validateRef = useKeyword(gen, keyword, validate);
        const valid = gen.let("valid");
        cxt.block$data(valid, validateKeyword);
        cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
        function validateKeyword() {
          if (def.errors === false) {
            assignValid();
            if (def.modifying)
              modifyData(cxt);
            reportErrs(() => cxt.error());
          } else {
            const ruleErrs = def.async ? validateAsync() : validateSync();
            if (def.modifying)
              modifyData(cxt);
            reportErrs(() => addErrs(cxt, ruleErrs));
          }
        }
        function validateAsync() {
          const ruleErrs = gen.let("ruleErrs", null);
          gen.try(() => assignValid((0, codegen_1._)`await `), (e5) => gen.assign(valid, false).if((0, codegen_1._)`${e5} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e5}.errors`), () => gen.throw(e5)));
          return ruleErrs;
        }
        function validateSync() {
          const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
          gen.assign(validateErrs, null);
          assignValid(codegen_1.nil);
          return validateErrs;
        }
        function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
          const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
          const passSchema = !("compile" in def && !$data || def.schema === false);
          gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
        }
        function reportErrs(errors) {
          var _a2;
          gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
        }
      }
      exports21.funcKeywordCode = funcKeywordCode;
      function modifyData(cxt) {
        const { gen, data, it } = cxt;
        gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
      }
      function addErrs(cxt, errs) {
        const { gen } = cxt;
        gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
          gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
          (0, errors_1.extendErrors)(cxt);
        }, () => cxt.error());
      }
      function checkAsyncKeyword({ schemaEnv }, def) {
        if (def.async && !schemaEnv.$async)
          throw new Error("async keyword in sync schema");
      }
      function useKeyword(gen, keyword, result) {
        if (result === void 0)
          throw new Error(`keyword "${keyword}" failed to compile`);
        return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
      }
      function validSchemaType(schema, schemaType, allowUndefined = false) {
        return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
      }
      exports21.validSchemaType = validSchemaType;
      function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
        if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
          throw new Error("ajv implementation error");
        }
        const deps = def.dependencies;
        if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
          throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
        }
        if (def.validateSchema) {
          const valid = def.validateSchema(schema[keyword]);
          if (!valid) {
            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
            if (opts.validateSchema === "log")
              self2.logger.error(msg);
            else
              throw new Error(msg);
          }
        }
      }
      exports21.validateKeywordUsage = validateKeywordUsage;
    }
  });

  // ../../node_modules/ajv/dist/compile/validate/subschema.js
  var require_subschema = __commonJS({
    "../../node_modules/ajv/dist/compile/validate/subschema.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.extendSubschemaMode = exports21.extendSubschemaData = exports21.getSubschema = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
        if (keyword !== void 0 && schema !== void 0) {
          throw new Error('both "keyword" and "schema" passed, only one allowed');
        }
        if (keyword !== void 0) {
          const sch = it.schema[keyword];
          return schemaProp === void 0 ? {
            schema: sch,
            schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
            errSchemaPath: `${it.errSchemaPath}/${keyword}`
          } : {
            schema: sch[schemaProp],
            schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
            errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
          };
        }
        if (schema !== void 0) {
          if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
          }
          return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath
          };
        }
        throw new Error('either "keyword" or "schema" must be passed');
      }
      exports21.getSubschema = getSubschema;
      function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
        if (data !== void 0 && dataProp !== void 0) {
          throw new Error('both "data" and "dataProp" passed, only one allowed');
        }
        const { gen } = it;
        if (dataProp !== void 0) {
          const { errorPath, dataPathArr, opts } = it;
          const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
          dataContextProps(nextData);
          subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
          subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
          subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
        }
        if (data !== void 0) {
          const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
          dataContextProps(nextData);
          if (propertyName !== void 0)
            subschema.propertyName = propertyName;
        }
        if (dataTypes)
          subschema.dataTypes = dataTypes;
        function dataContextProps(_nextData) {
          subschema.data = _nextData;
          subschema.dataLevel = it.dataLevel + 1;
          subschema.dataTypes = [];
          it.definedProperties = /* @__PURE__ */ new Set();
          subschema.parentData = it.data;
          subschema.dataNames = [...it.dataNames, _nextData];
        }
      }
      exports21.extendSubschemaData = extendSubschemaData;
      function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
        if (compositeRule !== void 0)
          subschema.compositeRule = compositeRule;
        if (createErrors !== void 0)
          subschema.createErrors = createErrors;
        if (allErrors !== void 0)
          subschema.allErrors = allErrors;
        subschema.jtdDiscriminator = jtdDiscriminator;
        subschema.jtdMetadata = jtdMetadata;
      }
      exports21.extendSubschemaMode = extendSubschemaMode;
    }
  });

  // ../../node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "../../node_modules/fast-deep-equal/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      module.exports = function equal(a5, b4) {
        if (a5 === b4) return true;
        if (a5 && b4 && typeof a5 == "object" && typeof b4 == "object") {
          if (a5.constructor !== b4.constructor) return false;
          var length, i5, keys;
          if (Array.isArray(a5)) {
            length = a5.length;
            if (length != b4.length) return false;
            for (i5 = length; i5-- !== 0; )
              if (!equal(a5[i5], b4[i5])) return false;
            return true;
          }
          if (a5.constructor === RegExp) return a5.source === b4.source && a5.flags === b4.flags;
          if (a5.valueOf !== Object.prototype.valueOf) return a5.valueOf() === b4.valueOf();
          if (a5.toString !== Object.prototype.toString) return a5.toString() === b4.toString();
          keys = Object.keys(a5);
          length = keys.length;
          if (length !== Object.keys(b4).length) return false;
          for (i5 = length; i5-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b4, keys[i5])) return false;
          for (i5 = length; i5-- !== 0; ) {
            var key = keys[i5];
            if (!equal(a5[key], b4[key])) return false;
          }
          return true;
        }
        return a5 !== a5 && b4 !== b4;
      };
    }
  });

  // ../../node_modules/json-schema-traverse/index.js
  var require_json_schema_traverse = __commonJS({
    "../../node_modules/json-schema-traverse/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var traverse = module.exports = function(schema, opts, cb) {
        if (typeof opts == "function") {
          cb = opts;
          opts = {};
        }
        cb = opts.cb || cb;
        var pre = typeof cb == "function" ? cb : cb.pre || function() {
        };
        var post = cb.post || function() {
        };
        _traverse(opts, pre, post, schema, "", schema);
      };
      traverse.keywords = {
        additionalItems: true,
        items: true,
        contains: true,
        additionalProperties: true,
        propertyNames: true,
        not: true,
        if: true,
        then: true,
        else: true
      };
      traverse.arrayKeywords = {
        items: true,
        allOf: true,
        anyOf: true,
        oneOf: true
      };
      traverse.propsKeywords = {
        $defs: true,
        definitions: true,
        properties: true,
        patternProperties: true,
        dependencies: true
      };
      traverse.skipKeywords = {
        default: true,
        enum: true,
        const: true,
        required: true,
        maximum: true,
        minimum: true,
        exclusiveMaximum: true,
        exclusiveMinimum: true,
        multipleOf: true,
        maxLength: true,
        minLength: true,
        pattern: true,
        format: true,
        maxItems: true,
        minItems: true,
        uniqueItems: true,
        maxProperties: true,
        minProperties: true
      };
      function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (schema && typeof schema == "object" && !Array.isArray(schema)) {
          pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
          for (var key in schema) {
            var sch = schema[key];
            if (Array.isArray(sch)) {
              if (key in traverse.arrayKeywords) {
                for (var i5 = 0; i5 < sch.length; i5++)
                  _traverse(opts, pre, post, sch[i5], jsonPtr + "/" + key + "/" + i5, rootSchema, jsonPtr, key, schema, i5);
              }
            } else if (key in traverse.propsKeywords) {
              if (sch && typeof sch == "object") {
                for (var prop in sch)
                  _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
              }
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
              _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
            }
          }
          post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        }
      }
      function escapeJsonPtr(str) {
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
    }
  });

  // ../../node_modules/ajv/dist/compile/resolve.js
  var require_resolve = __commonJS({
    "../../node_modules/ajv/dist/compile/resolve.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.getSchemaRefs = exports21.resolveUrl = exports21.normalizeId = exports21._getFullPath = exports21.getFullPath = exports21.inlineRef = void 0;
      var util_1 = require_util();
      var equal = require_fast_deep_equal();
      var traverse = require_json_schema_traverse();
      var SIMPLE_INLINED = /* @__PURE__ */ new Set([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum",
        "const"
      ]);
      function inlineRef(schema, limit = true) {
        if (typeof schema == "boolean")
          return true;
        if (limit === true)
          return !hasRef(schema);
        if (!limit)
          return false;
        return countKeys(schema) <= limit;
      }
      exports21.inlineRef = inlineRef;
      var REF_KEYWORDS = /* @__PURE__ */ new Set([
        "$ref",
        "$recursiveRef",
        "$recursiveAnchor",
        "$dynamicRef",
        "$dynamicAnchor"
      ]);
      function hasRef(schema) {
        for (const key in schema) {
          if (REF_KEYWORDS.has(key))
            return true;
          const sch = schema[key];
          if (Array.isArray(sch) && sch.some(hasRef))
            return true;
          if (typeof sch == "object" && hasRef(sch))
            return true;
        }
        return false;
      }
      function countKeys(schema) {
        let count = 0;
        for (const key in schema) {
          if (key === "$ref")
            return Infinity;
          count++;
          if (SIMPLE_INLINED.has(key))
            continue;
          if (typeof schema[key] == "object") {
            (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
          }
          if (count === Infinity)
            return Infinity;
        }
        return count;
      }
      function getFullPath(resolver, id = "", normalize) {
        if (normalize !== false)
          id = normalizeId(id);
        const p5 = resolver.parse(id);
        return _getFullPath(resolver, p5);
      }
      exports21.getFullPath = getFullPath;
      function _getFullPath(resolver, p5) {
        const serialized = resolver.serialize(p5);
        return serialized.split("#")[0] + "#";
      }
      exports21._getFullPath = _getFullPath;
      var TRAILING_SLASH_HASH = /#\/?$/;
      function normalizeId(id) {
        return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
      }
      exports21.normalizeId = normalizeId;
      function resolveUrl(resolver, baseId, id) {
        id = normalizeId(id);
        return resolver.resolve(baseId, id);
      }
      exports21.resolveUrl = resolveUrl;
      var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
      function getSchemaRefs(schema, baseId) {
        if (typeof schema == "boolean")
          return {};
        const { schemaId, uriResolver } = this.opts;
        const schId = normalizeId(schema[schemaId] || baseId);
        const baseIds = { "": schId };
        const pathPrefix = getFullPath(uriResolver, schId, false);
        const localRefs = {};
        const schemaRefs = /* @__PURE__ */ new Set();
        traverse(schema, { allKeys: true }, (sch, jsonPtr, _3, parentJsonPtr) => {
          if (parentJsonPtr === void 0)
            return;
          const fullPath = pathPrefix + jsonPtr;
          let innerBaseId = baseIds[parentJsonPtr];
          if (typeof sch[schemaId] == "string")
            innerBaseId = addRef.call(this, sch[schemaId]);
          addAnchor.call(this, sch.$anchor);
          addAnchor.call(this, sch.$dynamicAnchor);
          baseIds[jsonPtr] = innerBaseId;
          function addRef(ref) {
            const _resolve = this.opts.uriResolver.resolve;
            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
            if (schemaRefs.has(ref))
              throw ambiguos(ref);
            schemaRefs.add(ref);
            let schOrRef = this.refs[ref];
            if (typeof schOrRef == "string")
              schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
              checkAmbiguosRef(sch, schOrRef.schema, ref);
            } else if (ref !== normalizeId(fullPath)) {
              if (ref[0] === "#") {
                checkAmbiguosRef(sch, localRefs[ref], ref);
                localRefs[ref] = sch;
              } else {
                this.refs[ref] = fullPath;
              }
            }
            return ref;
          }
          function addAnchor(anchor) {
            if (typeof anchor == "string") {
              if (!ANCHOR.test(anchor))
                throw new Error(`invalid anchor "${anchor}"`);
              addRef.call(this, `#${anchor}`);
            }
          }
        });
        return localRefs;
        function checkAmbiguosRef(sch1, sch2, ref) {
          if (sch2 !== void 0 && !equal(sch1, sch2))
            throw ambiguos(ref);
        }
        function ambiguos(ref) {
          return new Error(`reference "${ref}" resolves to more than one schema`);
        }
      }
      exports21.getSchemaRefs = getSchemaRefs;
    }
  });

  // ../../node_modules/ajv/dist/compile/validate/index.js
  var require_validate = __commonJS({
    "../../node_modules/ajv/dist/compile/validate/index.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.getData = exports21.KeywordCxt = exports21.validateFunctionCode = void 0;
      var boolSchema_1 = require_boolSchema();
      var dataType_1 = require_dataType();
      var applicability_1 = require_applicability();
      var dataType_2 = require_dataType();
      var defaults_1 = require_defaults();
      var keyword_1 = require_keyword();
      var subschema_1 = require_subschema();
      var codegen_1 = require_codegen();
      var names_1 = require_names();
      var resolve_1 = require_resolve();
      var util_1 = require_util();
      var errors_1 = require_errors();
      function validateFunctionCode(it) {
        if (isSchemaObj(it)) {
          checkKeywords(it);
          if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it);
            return;
          }
        }
        validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
      }
      exports21.validateFunctionCode = validateFunctionCode;
      function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
        if (opts.code.es5) {
          gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
            gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
            destructureValCxtES5(gen, opts);
            gen.code(body);
          });
        } else {
          gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
        }
      }
      function destructureValCxt(opts) {
        return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
      }
      function destructureValCxtES5(gen, opts) {
        gen.if(names_1.default.valCxt, () => {
          gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
          gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
          gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
          gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
          if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
        }, () => {
          gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
          gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
          gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
          gen.var(names_1.default.rootData, names_1.default.data);
          if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
        });
      }
      function topSchemaObjCode(it) {
        const { schema, opts, gen } = it;
        validateFunction(it, () => {
          if (opts.$comment && schema.$comment)
            commentKeyword(it);
          checkNoDefault(it);
          gen.let(names_1.default.vErrors, null);
          gen.let(names_1.default.errors, 0);
          if (opts.unevaluated)
            resetEvaluated(it);
          typeAndKeywords(it);
          returnResults(it);
        });
        return;
      }
      function resetEvaluated(it) {
        const { gen, validateName } = it;
        it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
        gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
        gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
      }
      function funcSourceUrl(schema, opts) {
        const schId = typeof schema == "object" && schema[opts.schemaId];
        return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
      }
      function subschemaCode(it, valid) {
        if (isSchemaObj(it)) {
          checkKeywords(it);
          if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid);
            return;
          }
        }
        (0, boolSchema_1.boolOrEmptySchema)(it, valid);
      }
      function schemaCxtHasRules({ schema, self: self2 }) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (self2.RULES.all[key])
            return true;
        return false;
      }
      function isSchemaObj(it) {
        return typeof it.schema != "boolean";
      }
      function subSchemaObjCode(it, valid) {
        const { schema, gen, opts } = it;
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        updateContext(it);
        checkAsyncSchema(it);
        const errsCount = gen.const("_errs", names_1.default.errors);
        typeAndKeywords(it, errsCount);
        gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      }
      function checkKeywords(it) {
        (0, util_1.checkUnknownRules)(it);
        checkRefsAndKeywords(it);
      }
      function typeAndKeywords(it, errsCount) {
        if (it.opts.jtd)
          return schemaKeywords(it, [], false, errsCount);
        const types2 = (0, dataType_1.getSchemaTypes)(it.schema);
        const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
        schemaKeywords(it, types2, !checkedTypes, errsCount);
      }
      function checkRefsAndKeywords(it) {
        const { schema, errSchemaPath, opts, self: self2 } = it;
        if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
          self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
        }
      }
      function checkNoDefault(it) {
        const { schema, opts } = it;
        if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
          (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
        }
      }
      function updateContext(it) {
        const schId = it.schema[it.opts.schemaId];
        if (schId)
          it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
      }
      function checkAsyncSchema(it) {
        if (it.schema.$async && !it.schemaEnv.$async)
          throw new Error("async schema in sync schema");
      }
      function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
        const msg = schema.$comment;
        if (opts.$comment === true) {
          gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
        } else if (typeof opts.$comment == "function") {
          const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
          const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
          gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
        }
      }
      function returnResults(it) {
        const { gen, schemaEnv, validateName, ValidationError, opts } = it;
        if (schemaEnv.$async) {
          gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
          if (opts.unevaluated)
            assignEvaluated(it);
          gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
        }
      }
      function assignEvaluated({ gen, evaluated, props, items }) {
        if (props instanceof codegen_1.Name)
          gen.assign((0, codegen_1._)`${evaluated}.props`, props);
        if (items instanceof codegen_1.Name)
          gen.assign((0, codegen_1._)`${evaluated}.items`, items);
      }
      function schemaKeywords(it, types2, typeErrors, errsCount) {
        const { gen, schema, data, allErrors, opts, self: self2 } = it;
        const { RULES } = self2;
        if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
          gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
          return;
        }
        if (!opts.jtd)
          checkStrictTypes(it, types2);
        gen.block(() => {
          for (const group of RULES.rules)
            groupKeywords(group);
          groupKeywords(RULES.post);
        });
        function groupKeywords(group) {
          if (!(0, applicability_1.shouldUseGroup)(schema, group))
            return;
          if (group.type) {
            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
            iterateKeywords(it, group);
            if (types2.length === 1 && types2[0] === group.type && typeErrors) {
              gen.else();
              (0, dataType_2.reportTypeError)(it);
            }
            gen.endIf();
          } else {
            iterateKeywords(it, group);
          }
          if (!allErrors)
            gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
        }
      }
      function iterateKeywords(it, group) {
        const { gen, schema, opts: { useDefaults } } = it;
        if (useDefaults)
          (0, defaults_1.assignDefaults)(it, group.type);
        gen.block(() => {
          for (const rule of group.rules) {
            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
              keywordCode(it, rule.keyword, rule.definition, group.type);
            }
          }
        });
      }
      function checkStrictTypes(it, types2) {
        if (it.schemaEnv.meta || !it.opts.strictTypes)
          return;
        checkContextTypes(it, types2);
        if (!it.opts.allowUnionTypes)
          checkMultipleTypes(it, types2);
        checkKeywordTypes(it, it.dataTypes);
      }
      function checkContextTypes(it, types2) {
        if (!types2.length)
          return;
        if (!it.dataTypes.length) {
          it.dataTypes = types2;
          return;
        }
        types2.forEach((t5) => {
          if (!includesType(it.dataTypes, t5)) {
            strictTypesError(it, `type "${t5}" not allowed by context "${it.dataTypes.join(",")}"`);
          }
        });
        narrowSchemaTypes(it, types2);
      }
      function checkMultipleTypes(it, ts) {
        if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
          strictTypesError(it, "use allowUnionTypes to allow union type keyword");
        }
      }
      function checkKeywordTypes(it, ts) {
        const rules = it.self.RULES.all;
        for (const keyword in rules) {
          const rule = rules[keyword];
          if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
            const { type: type2 } = rule.definition;
            if (type2.length && !type2.some((t5) => hasApplicableType(ts, t5))) {
              strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword}"`);
            }
          }
        }
      }
      function hasApplicableType(schTs, kwdT) {
        return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
      }
      function includesType(ts, t5) {
        return ts.includes(t5) || t5 === "integer" && ts.includes("number");
      }
      function narrowSchemaTypes(it, withTypes) {
        const ts = [];
        for (const t5 of it.dataTypes) {
          if (includesType(withTypes, t5))
            ts.push(t5);
          else if (withTypes.includes("integer") && t5 === "number")
            ts.push("integer");
        }
        it.dataTypes = ts;
      }
      function strictTypesError(it, msg) {
        const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
        msg += ` at "${schemaPath}" (strictTypes)`;
        (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
      }
      var KeywordCxt = class {
        constructor(it, def, keyword) {
          (0, keyword_1.validateKeywordUsage)(it, def, keyword);
          this.gen = it.gen;
          this.allErrors = it.allErrors;
          this.keyword = keyword;
          this.data = it.data;
          this.schema = it.schema[keyword];
          this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
          this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
          this.schemaType = def.schemaType;
          this.parentSchema = it.schema;
          this.params = {};
          this.it = it;
          this.def = def;
          if (this.$data) {
            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
          } else {
            this.schemaCode = this.schemaValue;
            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
              throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
            }
          }
          if ("code" in def ? def.trackErrors : def.errors !== false) {
            this.errsCount = it.gen.const("_errs", names_1.default.errors);
          }
        }
        result(condition, successAction, failAction) {
          this.failResult((0, codegen_1.not)(condition), successAction, failAction);
        }
        failResult(condition, successAction, failAction) {
          this.gen.if(condition);
          if (failAction)
            failAction();
          else
            this.error();
          if (successAction) {
            this.gen.else();
            successAction();
            if (this.allErrors)
              this.gen.endIf();
          } else {
            if (this.allErrors)
              this.gen.endIf();
            else
              this.gen.else();
          }
        }
        pass(condition, failAction) {
          this.failResult((0, codegen_1.not)(condition), void 0, failAction);
        }
        fail(condition) {
          if (condition === void 0) {
            this.error();
            if (!this.allErrors)
              this.gen.if(false);
            return;
          }
          this.gen.if(condition);
          this.error();
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
        fail$data(condition) {
          if (!this.$data)
            return this.fail(condition);
          const { schemaCode } = this;
          this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
        }
        error(append, errorParams, errorPaths) {
          if (errorParams) {
            this.setParams(errorParams);
            this._error(append, errorPaths);
            this.setParams({});
            return;
          }
          this._error(append, errorPaths);
        }
        _error(append, errorPaths) {
          ;
          (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
        }
        $dataError() {
          (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
        }
        reset() {
          if (this.errsCount === void 0)
            throw new Error('add "trackErrors" to keyword definition');
          (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
        }
        ok(cond) {
          if (!this.allErrors)
            this.gen.if(cond);
        }
        setParams(obj, assign) {
          if (assign)
            Object.assign(this.params, obj);
          else
            this.params = obj;
        }
        block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
          this.gen.block(() => {
            this.check$data(valid, $dataValid);
            codeBlock();
          });
        }
        check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
          if (!this.$data)
            return;
          const { gen, schemaCode, schemaType, def } = this;
          gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
          if (valid !== codegen_1.nil)
            gen.assign(valid, true);
          if (schemaType.length || def.validateSchema) {
            gen.elseIf(this.invalid$data());
            this.$dataError();
            if (valid !== codegen_1.nil)
              gen.assign(valid, false);
          }
          gen.else();
        }
        invalid$data() {
          const { gen, schemaCode, schemaType, def, it } = this;
          return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
          function wrong$DataType() {
            if (schemaType.length) {
              if (!(schemaCode instanceof codegen_1.Name))
                throw new Error("ajv implementation error");
              const st = Array.isArray(schemaType) ? schemaType : [schemaType];
              return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
            }
            return codegen_1.nil;
          }
          function invalid$DataSchema() {
            if (def.validateSchema) {
              const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
              return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
            }
            return codegen_1.nil;
          }
        }
        subschema(appl, valid) {
          const subschema = (0, subschema_1.getSubschema)(this.it, appl);
          (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
          (0, subschema_1.extendSubschemaMode)(subschema, appl);
          const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
          subschemaCode(nextContext, valid);
          return nextContext;
        }
        mergeEvaluated(schemaCxt, toName) {
          const { it, gen } = this;
          if (!it.opts.unevaluated)
            return;
          if (it.props !== true && schemaCxt.props !== void 0) {
            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
          }
          if (it.items !== true && schemaCxt.items !== void 0) {
            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
          }
        }
        mergeValidEvaluated(schemaCxt, valid) {
          const { it, gen } = this;
          if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
            return true;
          }
        }
      };
      exports21.KeywordCxt = KeywordCxt;
      function keywordCode(it, keyword, def, ruleType) {
        const cxt = new KeywordCxt(it, def, keyword);
        if ("code" in def) {
          def.code(cxt, ruleType);
        } else if (cxt.$data && def.validate) {
          (0, keyword_1.funcKeywordCode)(cxt, def);
        } else if ("macro" in def) {
          (0, keyword_1.macroKeywordCode)(cxt, def);
        } else if (def.compile || def.validate) {
          (0, keyword_1.funcKeywordCode)(cxt, def);
        }
      }
      var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
      var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
      function getData($data, { dataLevel, dataNames, dataPathArr }) {
        let jsonPointer;
        let data;
        if ($data === "")
          return names_1.default.rootData;
        if ($data[0] === "/") {
          if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data}`);
          jsonPointer = $data;
          data = names_1.default.rootData;
        } else {
          const matches = RELATIVE_JSON_POINTER.exec($data);
          if (!matches)
            throw new Error(`Invalid JSON-pointer: ${$data}`);
          const up = +matches[1];
          jsonPointer = matches[2];
          if (jsonPointer === "#") {
            if (up >= dataLevel)
              throw new Error(errorMsg("property/index", up));
            return dataPathArr[dataLevel - up];
          }
          if (up > dataLevel)
            throw new Error(errorMsg("data", up));
          data = dataNames[dataLevel - up];
          if (!jsonPointer)
            return data;
        }
        let expr = data;
        const segments = jsonPointer.split("/");
        for (const segment of segments) {
          if (segment) {
            data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
            expr = (0, codegen_1._)`${expr} && ${data}`;
          }
        }
        return expr;
        function errorMsg(pointerType, up) {
          return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
        }
      }
      exports21.getData = getData;
    }
  });

  // ../../node_modules/ajv/dist/runtime/validation_error.js
  var require_validation_error = __commonJS({
    "../../node_modules/ajv/dist/runtime/validation_error.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var ValidationError = class extends Error {
        constructor(errors) {
          super("validation failed");
          this.errors = errors;
          this.ajv = this.validation = true;
        }
      };
      exports21.default = ValidationError;
    }
  });

  // ../../node_modules/ajv/dist/compile/ref_error.js
  var require_ref_error = __commonJS({
    "../../node_modules/ajv/dist/compile/ref_error.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var resolve_1 = require_resolve();
      var MissingRefError = class extends Error {
        constructor(resolver, baseId, ref, msg) {
          super(msg || `can't resolve reference ${ref} from id ${baseId}`);
          this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
          this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
        }
      };
      exports21.default = MissingRefError;
    }
  });

  // ../../node_modules/ajv/dist/compile/index.js
  var require_compile = __commonJS({
    "../../node_modules/ajv/dist/compile/index.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.resolveSchema = exports21.getCompilingSchema = exports21.resolveRef = exports21.compileSchema = exports21.SchemaEnv = void 0;
      var codegen_1 = require_codegen();
      var validation_error_1 = require_validation_error();
      var names_1 = require_names();
      var resolve_1 = require_resolve();
      var util_1 = require_util();
      var validate_1 = require_validate();
      var SchemaEnv = class {
        constructor(env3) {
          var _a;
          this.refs = {};
          this.dynamicAnchors = {};
          let schema;
          if (typeof env3.schema == "object")
            schema = env3.schema;
          this.schema = env3.schema;
          this.schemaId = env3.schemaId;
          this.root = env3.root || this;
          this.baseId = (_a = env3.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env3.schemaId || "$id"]);
          this.schemaPath = env3.schemaPath;
          this.localRefs = env3.localRefs;
          this.meta = env3.meta;
          this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
          this.refs = {};
        }
      };
      exports21.SchemaEnv = SchemaEnv;
      function compileSchema(sch) {
        const _sch = getCompilingSchema.call(this, sch);
        if (_sch)
          return _sch;
        const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
        const { es5, lines } = this.opts.code;
        const { ownProperties } = this.opts;
        const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
        let _ValidationError;
        if (sch.$async) {
          _ValidationError = gen.scopeValue("Error", {
            ref: validation_error_1.default,
            code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
          });
        }
        const validateName = gen.scopeName("validate");
        sch.validateName = validateName;
        const schemaCxt = {
          gen,
          allErrors: this.opts.allErrors,
          data: names_1.default.data,
          parentData: names_1.default.parentData,
          parentDataProperty: names_1.default.parentDataProperty,
          dataNames: [names_1.default.data],
          dataPathArr: [codegen_1.nil],
          // TODO can its length be used as dataLevel if nil is removed?
          dataLevel: 0,
          dataTypes: [],
          definedProperties: /* @__PURE__ */ new Set(),
          topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
          validateName,
          ValidationError: _ValidationError,
          schema: sch.schema,
          schemaEnv: sch,
          rootId,
          baseId: sch.baseId || rootId,
          schemaPath: codegen_1.nil,
          errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
          errorPath: (0, codegen_1._)`""`,
          opts: this.opts,
          self: this
        };
        let sourceCode;
        try {
          this._compilations.add(sch);
          (0, validate_1.validateFunctionCode)(schemaCxt);
          gen.optimize(this.opts.code.optimize);
          const validateCode = gen.toString();
          sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
          if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
          const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
          const validate = makeValidate(this, this.scope.get());
          this.scope.value(validateName, { ref: validate });
          validate.errors = null;
          validate.schema = sch.schema;
          validate.schemaEnv = sch;
          if (sch.$async)
            validate.$async = true;
          if (this.opts.code.source === true) {
            validate.source = { validateName, validateCode, scopeValues: gen._values };
          }
          if (this.opts.unevaluated) {
            const { props, items } = schemaCxt;
            validate.evaluated = {
              props: props instanceof codegen_1.Name ? void 0 : props,
              items: items instanceof codegen_1.Name ? void 0 : items,
              dynamicProps: props instanceof codegen_1.Name,
              dynamicItems: items instanceof codegen_1.Name
            };
            if (validate.source)
              validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
          }
          sch.validate = validate;
          return sch;
        } catch (e5) {
          delete sch.validate;
          delete sch.validateName;
          if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
          throw e5;
        } finally {
          this._compilations.delete(sch);
        }
      }
      exports21.compileSchema = compileSchema;
      function resolveRef(root, baseId, ref) {
        var _a;
        ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
        const schOrFunc = root.refs[ref];
        if (schOrFunc)
          return schOrFunc;
        let _sch = resolve2.call(this, root, ref);
        if (_sch === void 0) {
          const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
          const { schemaId } = this.opts;
          if (schema)
            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
        }
        if (_sch === void 0)
          return;
        return root.refs[ref] = inlineOrCompile.call(this, _sch);
      }
      exports21.resolveRef = resolveRef;
      function inlineOrCompile(sch) {
        if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
          return sch.schema;
        return sch.validate ? sch : compileSchema.call(this, sch);
      }
      function getCompilingSchema(schEnv) {
        for (const sch of this._compilations) {
          if (sameSchemaEnv(sch, schEnv))
            return sch;
        }
      }
      exports21.getCompilingSchema = getCompilingSchema;
      function sameSchemaEnv(s1, s22) {
        return s1.schema === s22.schema && s1.root === s22.root && s1.baseId === s22.baseId;
      }
      function resolve2(root, ref) {
        let sch;
        while (typeof (sch = this.refs[ref]) == "string")
          ref = sch;
        return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
      }
      function resolveSchema(root, ref) {
        const p5 = this.opts.uriResolver.parse(ref);
        const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p5);
        let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
        if (Object.keys(root.schema).length > 0 && refPath === baseId) {
          return getJsonPointer.call(this, p5, root);
        }
        const id = (0, resolve_1.normalizeId)(refPath);
        const schOrRef = this.refs[id] || this.schemas[id];
        if (typeof schOrRef == "string") {
          const sch = resolveSchema.call(this, root, schOrRef);
          if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
          return getJsonPointer.call(this, p5, sch);
        }
        if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
          return;
        if (!schOrRef.validate)
          compileSchema.call(this, schOrRef);
        if (id === (0, resolve_1.normalizeId)(ref)) {
          const { schema } = schOrRef;
          const { schemaId } = this.opts;
          const schId = schema[schemaId];
          if (schId)
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
          return new SchemaEnv({ schema, schemaId, root, baseId });
        }
        return getJsonPointer.call(this, p5, schOrRef);
      }
      exports21.resolveSchema = resolveSchema;
      var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
        "properties",
        "patternProperties",
        "enum",
        "dependencies",
        "definitions"
      ]);
      function getJsonPointer(parsedRef, { baseId, schema, root }) {
        var _a;
        if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
          return;
        for (const part of parsedRef.fragment.slice(1).split("/")) {
          if (typeof schema === "boolean")
            return;
          const partSchema = schema[(0, util_1.unescapeFragment)(part)];
          if (partSchema === void 0)
            return;
          schema = partSchema;
          const schId = typeof schema === "object" && schema[this.opts.schemaId];
          if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
          }
        }
        let env3;
        if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
          const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
          env3 = resolveSchema.call(this, root, $ref);
        }
        const { schemaId } = this.opts;
        env3 = env3 || new SchemaEnv({ schema, schemaId, root, baseId });
        if (env3.schema !== env3.root.schema)
          return env3;
        return void 0;
      }
    }
  });

  // ../../node_modules/ajv/dist/refs/data.json
  var require_data = __commonJS({
    "../../node_modules/ajv/dist/refs/data.json"(exports21, module) {
      module.exports = {
        $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
        description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
        type: "object",
        required: ["$data"],
        properties: {
          $data: {
            type: "string",
            anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
          }
        },
        additionalProperties: false
      };
    }
  });

  // ../../node_modules/fast-uri/lib/scopedChars.js
  var require_scopedChars = __commonJS({
    "../../node_modules/fast-uri/lib/scopedChars.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var HEX = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
      };
      module.exports = {
        HEX
      };
    }
  });

  // ../../node_modules/fast-uri/lib/utils.js
  var require_utils = __commonJS({
    "../../node_modules/fast-uri/lib/utils.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var { HEX } = require_scopedChars();
      var IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
      function normalizeIPv4(host) {
        if (findToken(host, ".") < 3) {
          return { host, isIPV4: false };
        }
        const matches = host.match(IPV4_REG) || [];
        const [address] = matches;
        if (address) {
          return { host: stripLeadingZeros(address, "."), isIPV4: true };
        } else {
          return { host, isIPV4: false };
        }
      }
      function stringArrayToHexStripped(input, keepZero = false) {
        let acc = "";
        let strip = true;
        for (const c5 of input) {
          if (HEX[c5] === void 0) return void 0;
          if (c5 !== "0" && strip === true) strip = false;
          if (!strip) acc += c5;
        }
        if (keepZero && acc.length === 0) acc = "0";
        return acc;
      }
      function getIPV6(input) {
        let tokenCount = 0;
        const output = { error: false, address: "", zone: "" };
        const address = [];
        const buffer2 = [];
        let isZone = false;
        let endipv6Encountered = false;
        let endIpv6 = false;
        function consume() {
          if (buffer2.length) {
            if (isZone === false) {
              const hex = stringArrayToHexStripped(buffer2);
              if (hex !== void 0) {
                address.push(hex);
              } else {
                output.error = true;
                return false;
              }
            }
            buffer2.length = 0;
          }
          return true;
        }
        for (let i5 = 0; i5 < input.length; i5++) {
          const cursor = input[i5];
          if (cursor === "[" || cursor === "]") {
            continue;
          }
          if (cursor === ":") {
            if (endipv6Encountered === true) {
              endIpv6 = true;
            }
            if (!consume()) {
              break;
            }
            tokenCount++;
            address.push(":");
            if (tokenCount > 7) {
              output.error = true;
              break;
            }
            if (i5 - 1 >= 0 && input[i5 - 1] === ":") {
              endipv6Encountered = true;
            }
            continue;
          } else if (cursor === "%") {
            if (!consume()) {
              break;
            }
            isZone = true;
          } else {
            buffer2.push(cursor);
            continue;
          }
        }
        if (buffer2.length) {
          if (isZone) {
            output.zone = buffer2.join("");
          } else if (endIpv6) {
            address.push(buffer2.join(""));
          } else {
            address.push(stringArrayToHexStripped(buffer2));
          }
        }
        output.address = address.join("");
        return output;
      }
      function normalizeIPv6(host) {
        if (findToken(host, ":") < 2) {
          return { host, isIPV6: false };
        }
        const ipv6 = getIPV6(host);
        if (!ipv6.error) {
          let newHost = ipv6.address;
          let escapedHost = ipv6.address;
          if (ipv6.zone) {
            newHost += "%" + ipv6.zone;
            escapedHost += "%25" + ipv6.zone;
          }
          return { host: newHost, escapedHost, isIPV6: true };
        } else {
          return { host, isIPV6: false };
        }
      }
      function stripLeadingZeros(str, token) {
        let out = "";
        let skip = true;
        const l5 = str.length;
        for (let i5 = 0; i5 < l5; i5++) {
          const c5 = str[i5];
          if (c5 === "0" && skip) {
            if (i5 + 1 <= l5 && str[i5 + 1] === token || i5 + 1 === l5) {
              out += c5;
              skip = false;
            }
          } else {
            if (c5 === token) {
              skip = true;
            } else {
              skip = false;
            }
            out += c5;
          }
        }
        return out;
      }
      function findToken(str, token) {
        let ind = 0;
        for (let i5 = 0; i5 < str.length; i5++) {
          if (str[i5] === token) ind++;
        }
        return ind;
      }
      var RDS1 = /^\.\.?\//u;
      var RDS2 = /^\/\.(?:\/|$)/u;
      var RDS3 = /^\/\.\.(?:\/|$)/u;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
      function removeDotSegments(input) {
        const output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            const im = input.match(RDS5);
            if (im) {
              const s5 = im[0];
              input = input.slice(s5.length);
              output.push(s5);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function normalizeComponentEncoding(components, esc) {
        const func = esc !== true ? escape : unescape;
        if (components.scheme !== void 0) {
          components.scheme = func(components.scheme);
        }
        if (components.userinfo !== void 0) {
          components.userinfo = func(components.userinfo);
        }
        if (components.host !== void 0) {
          components.host = func(components.host);
        }
        if (components.path !== void 0) {
          components.path = func(components.path);
        }
        if (components.query !== void 0) {
          components.query = func(components.query);
        }
        if (components.fragment !== void 0) {
          components.fragment = func(components.fragment);
        }
        return components;
      }
      function recomposeAuthority(components) {
        const uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          let host = unescape(components.host);
          const ipV4res = normalizeIPv4(host);
          if (ipV4res.isIPV4) {
            host = ipV4res.host;
          } else {
            const ipV6res = normalizeIPv6(ipV4res.host);
            if (ipV6res.isIPV6 === true) {
              host = `[${ipV6res.escapedHost}]`;
            } else {
              host = components.host;
            }
          }
          uriTokens.push(host);
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      module.exports = {
        recomposeAuthority,
        normalizeComponentEncoding,
        removeDotSegments,
        normalizeIPv4,
        normalizeIPv6,
        stringArrayToHexStripped
      };
    }
  });

  // ../../node_modules/fast-uri/lib/schemes.js
  var require_schemes = __commonJS({
    "../../node_modules/fast-uri/lib/schemes.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
      var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      function httpParse(components) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      }
      function httpSerialize(components) {
        const secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
      function wsParse(wsComponents) {
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      }
      function wsSerialize(wsComponents) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          const [path2, query] = wsComponents.resourceName.split("?");
          wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
      function urnParse(urnComponents, options) {
        if (!urnComponents.path) {
          urnComponents.error = "URN can not be parsed";
          return urnComponents;
        }
        const matches = urnComponents.path.match(URN_REG);
        if (matches) {
          const scheme = options.scheme || urnComponents.scheme || "urn";
          urnComponents.nid = matches[1].toLowerCase();
          urnComponents.nss = matches[2];
          const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
          const schemeHandler = SCHEMES[urnScheme];
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      }
      function urnSerialize(urnComponents, options) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        const nid = urnComponents.nid.toLowerCase();
        const urnScheme = `${scheme}:${options.nid || nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        const uriComponents = urnComponents;
        const nss = urnComponents.nss;
        uriComponents.path = `${nid || options.nid}:${nss}`;
        options.skipEscape = true;
        return uriComponents;
      }
      function urnuuidParse(urnComponents, options) {
        const uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      }
      function urnuuidSerialize(uuidComponents) {
        const urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
      var http = {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      };
      var https = {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      };
      var ws = {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      };
      var wss = {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      };
      var urn = {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      };
      var urnuuid = {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      };
      var SCHEMES = {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      };
      module.exports = SCHEMES;
    }
  });

  // ../../node_modules/fast-uri/index.js
  var require_fast_uri = __commonJS({
    "../../node_modules/fast-uri/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils();
      var SCHEMES = require_schemes();
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse3(uri, options), options);
        } else if (typeof uri === "object") {
          uri = parse3(serialize(uri, options), options);
        }
        return uri;
      }
      function resolve2(baseURI, relativeURI, options) {
        const schemelessOptions = Object.assign({ scheme: "null" }, options);
        const resolved = resolveComponents(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, true);
        return serialize(resolved, { ...schemelessOptions, skipEscape: true });
      }
      function resolveComponents(base, relative, options, skipNormalization) {
        const target = {};
        if (!skipNormalization) {
          base = parse3(serialize(base, options), options);
          relative = parse3(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                  target.path = "/" + relative.path;
                } else if (!base.path) {
                  target.path = relative.path;
                } else {
                  target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
          }
          target.scheme = base.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = unescape(uriA);
          uriA = serialize(normalizeComponentEncoding(parse3(uriA, options), true), { ...options, skipEscape: true });
        } else if (typeof uriA === "object") {
          uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
        }
        if (typeof uriB === "string") {
          uriB = unescape(uriB);
          uriB = serialize(normalizeComponentEncoding(parse3(uriB, options), true), { ...options, skipEscape: true });
        } else if (typeof uriB === "object") {
          uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
        }
        return uriA.toLowerCase() === uriB.toLowerCase();
      }
      function serialize(cmpts, opts) {
        const components = {
          host: cmpts.host,
          scheme: cmpts.scheme,
          userinfo: cmpts.userinfo,
          port: cmpts.port,
          path: cmpts.path,
          query: cmpts.query,
          nid: cmpts.nid,
          nss: cmpts.nss,
          uuid: cmpts.uuid,
          fragment: cmpts.fragment,
          reference: cmpts.reference,
          resourceName: cmpts.resourceName,
          secure: cmpts.secure,
          error: ""
        };
        const options = Object.assign({}, opts);
        const uriTokens = [];
        const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.path !== void 0) {
          if (!options.skipEscape) {
            components.path = escape(components.path);
            if (components.scheme !== void 0) {
              components.path = components.path.split("%3A").join(":");
            }
          } else {
            components.path = unescape(components.path);
          }
        }
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme, ":");
        }
        const authority = recomposeAuthority(components);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          let s5 = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s5 = removeDotSegments(s5);
          }
          if (authority === void 0) {
            s5 = s5.replace(/^\/\//u, "/%2F");
          }
          uriTokens.push(s5);
        }
        if (components.query !== void 0) {
          uriTokens.push("?", components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#", components.fragment);
        }
        return uriTokens.join("");
      }
      var hexLookUp = Array.from({ length: 127 }, (_v, k3) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k3)));
      function nonSimpleDomain(value) {
        let code = 0;
        for (let i5 = 0, len = value.length; i5 < len; ++i5) {
          code = value.charCodeAt(i5);
          if (code > 126 || hexLookUp[code]) {
            return true;
          }
        }
        return false;
      }
      var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
      function parse3(uri, opts) {
        const options = Object.assign({}, opts);
        const parsed = {
          scheme: void 0,
          userinfo: void 0,
          host: "",
          port: void 0,
          path: "",
          query: void 0,
          fragment: void 0
        };
        const gotEncoding = uri.indexOf("%") !== -1;
        let isIP = false;
        if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
        const matches = uri.match(URI_PARSE);
        if (matches) {
          parsed.scheme = matches[1];
          parsed.userinfo = matches[3];
          parsed.host = matches[4];
          parsed.port = parseInt(matches[5], 10);
          parsed.path = matches[6] || "";
          parsed.query = matches[7];
          parsed.fragment = matches[8];
          if (isNaN(parsed.port)) {
            parsed.port = matches[5];
          }
          if (parsed.host) {
            const ipv4result = normalizeIPv4(parsed.host);
            if (ipv4result.isIPV4 === false) {
              const ipv6result = normalizeIPv6(ipv4result.host);
              parsed.host = ipv6result.host.toLowerCase();
              isIP = ipv6result.isIPV6;
            } else {
              parsed.host = ipv4result.host;
              isIP = true;
            }
          }
          if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
            parsed.reference = "same-document";
          } else if (parsed.scheme === void 0) {
            parsed.reference = "relative";
          } else if (parsed.fragment === void 0) {
            parsed.reference = "absolute";
          } else {
            parsed.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
            parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
          }
          const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
              try {
                parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
              } catch (e5) {
                parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e5;
              }
            }
          }
          if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
            if (gotEncoding && parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (gotEncoding && parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
            if (parsed.path) {
              parsed.path = escape(unescape(parsed.path));
            }
            if (parsed.fragment) {
              parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
            }
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(parsed, options);
          }
        } else {
          parsed.error = parsed.error || "URI can not be parsed.";
        }
        return parsed;
      }
      var fastUri = {
        SCHEMES,
        normalize,
        resolve: resolve2,
        resolveComponents,
        equal,
        serialize,
        parse: parse3
      };
      module.exports = fastUri;
      module.exports.default = fastUri;
      module.exports.fastUri = fastUri;
    }
  });

  // ../../node_modules/ajv/dist/runtime/uri.js
  var require_uri = __commonJS({
    "../../node_modules/ajv/dist/runtime/uri.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var uri = require_fast_uri();
      uri.code = 'require("ajv/dist/runtime/uri").default';
      exports21.default = uri;
    }
  });

  // ../../node_modules/ajv/dist/core.js
  var require_core = __commonJS({
    "../../node_modules/ajv/dist/core.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.CodeGen = exports21.Name = exports21.nil = exports21.stringify = exports21.str = exports21._ = exports21.KeywordCxt = void 0;
      var validate_1 = require_validate();
      Object.defineProperty(exports21, "KeywordCxt", { enumerable: true, get: function() {
        return validate_1.KeywordCxt;
      } });
      var codegen_1 = require_codegen();
      Object.defineProperty(exports21, "_", { enumerable: true, get: function() {
        return codegen_1._;
      } });
      Object.defineProperty(exports21, "str", { enumerable: true, get: function() {
        return codegen_1.str;
      } });
      Object.defineProperty(exports21, "stringify", { enumerable: true, get: function() {
        return codegen_1.stringify;
      } });
      Object.defineProperty(exports21, "nil", { enumerable: true, get: function() {
        return codegen_1.nil;
      } });
      Object.defineProperty(exports21, "Name", { enumerable: true, get: function() {
        return codegen_1.Name;
      } });
      Object.defineProperty(exports21, "CodeGen", { enumerable: true, get: function() {
        return codegen_1.CodeGen;
      } });
      var validation_error_1 = require_validation_error();
      var ref_error_1 = require_ref_error();
      var rules_1 = require_rules();
      var compile_1 = require_compile();
      var codegen_2 = require_codegen();
      var resolve_1 = require_resolve();
      var dataType_1 = require_dataType();
      var util_1 = require_util();
      var $dataRefSchema = require_data();
      var uri_1 = require_uri();
      var defaultRegExp = (str, flags) => new RegExp(str, flags);
      defaultRegExp.code = "new RegExp";
      var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
      var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error"
      ]);
      var removedOptions = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now."
      };
      var deprecatedOptions = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
      };
      var MAX_EXPRESSION = 200;
      function requiredOptions(o5) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        const s5 = o5.strict;
        const _optz = (_a = o5.code) === null || _a === void 0 ? void 0 : _a.optimize;
        const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
        const regExp = (_c = (_b = o5.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
        const uriResolver = (_d = o5.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
        return {
          strictSchema: (_f = (_e = o5.strictSchema) !== null && _e !== void 0 ? _e : s5) !== null && _f !== void 0 ? _f : true,
          strictNumbers: (_h = (_g = o5.strictNumbers) !== null && _g !== void 0 ? _g : s5) !== null && _h !== void 0 ? _h : true,
          strictTypes: (_k = (_j = o5.strictTypes) !== null && _j !== void 0 ? _j : s5) !== null && _k !== void 0 ? _k : "log",
          strictTuples: (_m = (_l = o5.strictTuples) !== null && _l !== void 0 ? _l : s5) !== null && _m !== void 0 ? _m : "log",
          strictRequired: (_p = (_o = o5.strictRequired) !== null && _o !== void 0 ? _o : s5) !== null && _p !== void 0 ? _p : false,
          code: o5.code ? { ...o5.code, optimize, regExp } : { optimize, regExp },
          loopRequired: (_q = o5.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
          loopEnum: (_r = o5.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
          meta: (_s = o5.meta) !== null && _s !== void 0 ? _s : true,
          messages: (_t = o5.messages) !== null && _t !== void 0 ? _t : true,
          inlineRefs: (_u = o5.inlineRefs) !== null && _u !== void 0 ? _u : true,
          schemaId: (_v = o5.schemaId) !== null && _v !== void 0 ? _v : "$id",
          addUsedSchema: (_w = o5.addUsedSchema) !== null && _w !== void 0 ? _w : true,
          validateSchema: (_x = o5.validateSchema) !== null && _x !== void 0 ? _x : true,
          validateFormats: (_y = o5.validateFormats) !== null && _y !== void 0 ? _y : true,
          unicodeRegExp: (_z = o5.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
          int32range: (_0 = o5.int32range) !== null && _0 !== void 0 ? _0 : true,
          uriResolver
        };
      }
      var Ajv = class {
        constructor(opts = {}) {
          this.schemas = {};
          this.refs = {};
          this.formats = {};
          this._compilations = /* @__PURE__ */ new Set();
          this._loading = {};
          this._cache = /* @__PURE__ */ new Map();
          opts = this.opts = { ...opts, ...requiredOptions(opts) };
          const { es5, lines } = this.opts.code;
          this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
          this.logger = getLogger(opts.logger);
          const formatOpt = opts.validateFormats;
          opts.validateFormats = false;
          this.RULES = (0, rules_1.getRules)();
          checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
          checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
          this._metaOpts = getMetaSchemaOptions.call(this);
          if (opts.formats)
            addInitialFormats.call(this);
          this._addVocabularies();
          this._addDefaultMetaSchema();
          if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
          if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
          addInitialSchemas.call(this);
          opts.validateFormats = formatOpt;
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          const { $data, meta, schemaId } = this.opts;
          let _dataRefSchema = $dataRefSchema;
          if (schemaId === "id") {
            _dataRefSchema = { ...$dataRefSchema };
            _dataRefSchema.id = _dataRefSchema.$id;
            delete _dataRefSchema.$id;
          }
          if (meta && $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
        }
        defaultMeta() {
          const { meta, schemaId } = this.opts;
          return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
        }
        validate(schemaKeyRef, data) {
          let v5;
          if (typeof schemaKeyRef == "string") {
            v5 = this.getSchema(schemaKeyRef);
            if (!v5)
              throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
          } else {
            v5 = this.compile(schemaKeyRef);
          }
          const valid = v5(data);
          if (!("$async" in v5))
            this.errors = v5.errors;
          return valid;
        }
        compile(schema, _meta) {
          const sch = this._addSchema(schema, _meta);
          return sch.validate || this._compileSchemaEnv(sch);
        }
        compileAsync(schema, meta) {
          if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
          }
          const { loadSchema } = this.opts;
          return runCompileAsync.call(this, schema, meta);
          async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
          }
          async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
              await runCompileAsync.call(this, { $ref }, true);
            }
          }
          async function _compileAsync(sch) {
            try {
              return this._compileSchemaEnv(sch);
            } catch (e5) {
              if (!(e5 instanceof ref_error_1.default))
                throw e5;
              checkLoaded.call(this, e5);
              await loadMissingSchema.call(this, e5.missingSchema);
              return _compileAsync.call(this, sch);
            }
          }
          function checkLoaded({ missingSchema: ref, missingRef }) {
            if (this.refs[ref]) {
              throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
            }
          }
          async function loadMissingSchema(ref) {
            const _schema = await _loadSchema.call(this, ref);
            if (!this.refs[ref])
              await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref])
              this.addSchema(_schema, ref, meta);
          }
          async function _loadSchema(ref) {
            const p5 = this._loading[ref];
            if (p5)
              return p5;
            try {
              return await (this._loading[ref] = loadSchema(ref));
            } finally {
              delete this._loading[ref];
            }
          }
        }
        // Adds schema to the instance
        addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
          if (Array.isArray(schema)) {
            for (const sch of schema)
              this.addSchema(sch, void 0, _meta, _validateSchema);
            return this;
          }
          let id;
          if (typeof schema === "object") {
            const { schemaId } = this.opts;
            id = schema[schemaId];
            if (id !== void 0 && typeof id != "string") {
              throw new Error(`schema ${schemaId} must be string`);
            }
          }
          key = (0, resolve_1.normalizeId)(key || id);
          this._checkUnique(key);
          this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
          return this;
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
          this.addSchema(schema, key, true, _validateSchema);
          return this;
        }
        //  Validate schema against its meta-schema
        validateSchema(schema, throwOrLogError) {
          if (typeof schema == "boolean")
            return true;
          let $schema;
          $schema = schema.$schema;
          if ($schema !== void 0 && typeof $schema != "string") {
            throw new Error("$schema must be a string");
          }
          $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
          if (!$schema) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
          }
          const valid = this.validate($schema, schema);
          if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
              this.logger.error(message);
            else
              throw new Error(message);
          }
          return valid;
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(keyRef) {
          let sch;
          while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
            keyRef = sch;
          if (sch === void 0) {
            const { schemaId } = this.opts;
            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
            sch = compile_1.resolveSchema.call(this, root, keyRef);
            if (!sch)
              return;
            this.refs[keyRef] = sch;
          }
          return sch.validate || this._compileSchemaEnv(sch);
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(schemaKeyRef) {
          if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
          }
          switch (typeof schemaKeyRef) {
            case "undefined":
              this._removeAllSchemas(this.schemas);
              this._removeAllSchemas(this.refs);
              this._cache.clear();
              return this;
            case "string": {
              const sch = getSchEnv.call(this, schemaKeyRef);
              if (typeof sch == "object")
                this._cache.delete(sch.schema);
              delete this.schemas[schemaKeyRef];
              delete this.refs[schemaKeyRef];
              return this;
            }
            case "object": {
              const cacheKey = schemaKeyRef;
              this._cache.delete(cacheKey);
              let id = schemaKeyRef[this.opts.schemaId];
              if (id) {
                id = (0, resolve_1.normalizeId)(id);
                delete this.schemas[id];
                delete this.refs[id];
              }
              return this;
            }
            default:
              throw new Error("ajv.removeSchema: invalid parameter");
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(definitions) {
          for (const def of definitions)
            this.addKeyword(def);
          return this;
        }
        addKeyword(kwdOrDef, def) {
          let keyword;
          if (typeof kwdOrDef == "string") {
            keyword = kwdOrDef;
            if (typeof def == "object") {
              this.logger.warn("these parameters are deprecated, see docs for addKeyword");
              def.keyword = keyword;
            }
          } else if (typeof kwdOrDef == "object" && def === void 0) {
            def = kwdOrDef;
            keyword = def.keyword;
            if (Array.isArray(keyword) && !keyword.length) {
              throw new Error("addKeywords: keyword must be string or non-empty array");
            }
          } else {
            throw new Error("invalid addKeywords parameters");
          }
          checkKeyword.call(this, keyword, def);
          if (!def) {
            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
            return this;
          }
          keywordMetaschema.call(this, def);
          const definition = {
            ...def,
            type: (0, dataType_1.getJSONTypes)(def.type),
            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
          };
          (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k3) => addRule.call(this, k3, definition) : (k3) => definition.type.forEach((t5) => addRule.call(this, k3, definition, t5)));
          return this;
        }
        getKeyword(keyword) {
          const rule = this.RULES.all[keyword];
          return typeof rule == "object" ? rule.definition : !!rule;
        }
        // Remove keyword
        removeKeyword(keyword) {
          const { RULES } = this;
          delete RULES.keywords[keyword];
          delete RULES.all[keyword];
          for (const group of RULES.rules) {
            const i5 = group.rules.findIndex((rule) => rule.keyword === keyword);
            if (i5 >= 0)
              group.rules.splice(i5, 1);
          }
          return this;
        }
        // Add format
        addFormat(name2, format3) {
          if (typeof format3 == "string")
            format3 = new RegExp(format3);
          this.formats[name2] = format3;
          return this;
        }
        errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
          if (!errors || errors.length === 0)
            return "No errors";
          return errors.map((e5) => `${dataVar}${e5.instancePath} ${e5.message}`).reduce((text, msg) => text + separator + msg);
        }
        $dataMetaSchema(metaSchema, keywordsJsonPointers) {
          const rules = this.RULES.all;
          metaSchema = JSON.parse(JSON.stringify(metaSchema));
          for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1);
            let keywords = metaSchema;
            for (const seg of segments)
              keywords = keywords[seg];
            for (const key in rules) {
              const rule = rules[key];
              if (typeof rule != "object")
                continue;
              const { $data } = rule.definition;
              const schema = keywords[key];
              if ($data && schema)
                keywords[key] = schemaOrData(schema);
            }
          }
          return metaSchema;
        }
        _removeAllSchemas(schemas, regex) {
          for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex || regex.test(keyRef)) {
              if (typeof sch == "string") {
                delete schemas[keyRef];
              } else if (sch && !sch.meta) {
                this._cache.delete(sch.schema);
                delete schemas[keyRef];
              }
            }
          }
        }
        _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
          let id;
          const { schemaId } = this.opts;
          if (typeof schema == "object") {
            id = schema[schemaId];
          } else {
            if (this.opts.jtd)
              throw new Error("schema must be object");
            else if (typeof schema != "boolean")
              throw new Error("schema must be object or boolean");
          }
          let sch = this._cache.get(schema);
          if (sch !== void 0)
            return sch;
          baseId = (0, resolve_1.normalizeId)(id || baseId);
          const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
          sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
          this._cache.set(sch.schema, sch);
          if (addSchema && !baseId.startsWith("#")) {
            if (baseId)
              this._checkUnique(baseId);
            this.refs[baseId] = sch;
          }
          if (validateSchema)
            this.validateSchema(schema, true);
          return sch;
        }
        _checkUnique(id) {
          if (this.schemas[id] || this.refs[id]) {
            throw new Error(`schema with key or id "${id}" already exists`);
          }
        }
        _compileSchemaEnv(sch) {
          if (sch.meta)
            this._compileMetaSchema(sch);
          else
            compile_1.compileSchema.call(this, sch);
          if (!sch.validate)
            throw new Error("ajv implementation error");
          return sch.validate;
        }
        _compileMetaSchema(sch) {
          const currentOpts = this.opts;
          this.opts = this._metaOpts;
          try {
            compile_1.compileSchema.call(this, sch);
          } finally {
            this.opts = currentOpts;
          }
        }
      };
      Ajv.ValidationError = validation_error_1.default;
      Ajv.MissingRefError = ref_error_1.default;
      exports21.default = Ajv;
      function checkOptions(checkOpts, options, msg, log2 = "error") {
        for (const key in checkOpts) {
          const opt = key;
          if (opt in options)
            this.logger[log2](`${msg}: option ${key}. ${checkOpts[opt]}`);
        }
      }
      function getSchEnv(keyRef) {
        keyRef = (0, resolve_1.normalizeId)(keyRef);
        return this.schemas[keyRef] || this.refs[keyRef];
      }
      function addInitialSchemas() {
        const optsSchemas = this.opts.schemas;
        if (!optsSchemas)
          return;
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
      }
      function addInitialFormats() {
        for (const name2 in this.opts.formats) {
          const format3 = this.opts.formats[name2];
          if (format3)
            this.addFormat(name2, format3);
        }
      }
      function addInitialKeywords(defs) {
        if (Array.isArray(defs)) {
          this.addVocabulary(defs);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const keyword in defs) {
          const def = defs[keyword];
          if (!def.keyword)
            def.keyword = keyword;
          this.addKeyword(def);
        }
      }
      function getMetaSchemaOptions() {
        const metaOpts = { ...this.opts };
        for (const opt of META_IGNORE_OPTIONS)
          delete metaOpts[opt];
        return metaOpts;
      }
      var noLogs = { log() {
      }, warn() {
      }, error() {
      } };
      function getLogger(logger) {
        if (logger === false)
          return noLogs;
        if (logger === void 0)
          return console;
        if (logger.log && logger.warn && logger.error)
          return logger;
        throw new Error("logger must implement log, warn and error methods");
      }
      var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
      function checkKeyword(keyword, def) {
        const { RULES } = this;
        (0, util_1.eachItem)(keyword, (kwd) => {
          if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
          if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
        });
        if (!def)
          return;
        if (def.$data && !("code" in def || "validate" in def)) {
          throw new Error('$data keyword must have "code" or "validate" function');
        }
      }
      function addRule(keyword, definition, dataType) {
        var _a;
        const post = definition === null || definition === void 0 ? void 0 : definition.post;
        if (dataType && post)
          throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES } = this;
        let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t5 }) => t5 === dataType);
        if (!ruleGroup) {
          ruleGroup = { type: dataType, rules: [] };
          RULES.rules.push(ruleGroup);
        }
        RULES.keywords[keyword] = true;
        if (!definition)
          return;
        const rule = {
          keyword,
          definition: {
            ...definition,
            type: (0, dataType_1.getJSONTypes)(definition.type),
            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
          }
        };
        if (definition.before)
          addBeforeRule.call(this, ruleGroup, rule, definition.before);
        else
          ruleGroup.rules.push(rule);
        RULES.all[keyword] = rule;
        (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
      }
      function addBeforeRule(ruleGroup, rule, before) {
        const i5 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
        if (i5 >= 0) {
          ruleGroup.rules.splice(i5, 0, rule);
        } else {
          ruleGroup.rules.push(rule);
          this.logger.warn(`rule ${before} is not defined`);
        }
      }
      function keywordMetaschema(def) {
        let { metaSchema } = def;
        if (metaSchema === void 0)
          return;
        if (def.$data && this.opts.$data)
          metaSchema = schemaOrData(metaSchema);
        def.validateSchema = this.compile(metaSchema, true);
      }
      var $dataRef = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      };
      function schemaOrData(schema) {
        return { anyOf: [schema, $dataRef] };
      }
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/core/id.js
  var require_id = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/core/id.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var def = {
        keyword: "id",
        code() {
          throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/core/ref.js
  var require_ref = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/core/ref.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.callRef = exports21.getValidate = void 0;
      var ref_error_1 = require_ref_error();
      var code_1 = require_code2();
      var codegen_1 = require_codegen();
      var names_1 = require_names();
      var compile_1 = require_compile();
      var util_1 = require_util();
      var def = {
        keyword: "$ref",
        schemaType: "string",
        code(cxt) {
          const { gen, schema: $ref, it } = cxt;
          const { baseId, schemaEnv: env3, validateName, opts, self: self2 } = it;
          const { root } = env3;
          if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
            return callRootRef();
          const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
          if (schOrEnv === void 0)
            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
          if (schOrEnv instanceof compile_1.SchemaEnv)
            return callValidate(schOrEnv);
          return inlineRefSchema(schOrEnv);
          function callRootRef() {
            if (env3 === root)
              return callRef(cxt, validateName, env3, env3.$async);
            const rootName = gen.scopeValue("root", { ref: root });
            return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
          }
          function callValidate(sch) {
            const v5 = getValidate(cxt, sch);
            callRef(cxt, v5, sch, sch.$async);
          }
          function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
              schema: sch,
              dataTypes: [],
              schemaPath: codegen_1.nil,
              topSchemaRef: schName,
              errSchemaPath: $ref
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
          }
        }
      };
      function getValidate(cxt, sch) {
        const { gen } = cxt;
        return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
      }
      exports21.getValidate = getValidate;
      function callRef(cxt, v5, sch, $async) {
        const { gen, it } = cxt;
        const { allErrors, schemaEnv: env3, opts } = it;
        const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
        if ($async)
          callAsyncRef();
        else
          callSyncRef();
        function callAsyncRef() {
          if (!env3.$async)
            throw new Error("async schema referenced by sync schema");
          const valid = gen.let("valid");
          gen.try(() => {
            gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v5, passCxt)}`);
            addEvaluatedFrom(v5);
            if (!allErrors)
              gen.assign(valid, true);
          }, (e5) => {
            gen.if((0, codegen_1._)`!(${e5} instanceof ${it.ValidationError})`, () => gen.throw(e5));
            addErrorsFrom(e5);
            if (!allErrors)
              gen.assign(valid, false);
          });
          cxt.ok(valid);
        }
        function callSyncRef() {
          cxt.result((0, code_1.callValidateCode)(cxt, v5, passCxt), () => addEvaluatedFrom(v5), () => addErrorsFrom(v5));
        }
        function addErrorsFrom(source) {
          const errs = (0, codegen_1._)`${source}.errors`;
          gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
          gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        }
        function addEvaluatedFrom(source) {
          var _a;
          if (!it.opts.unevaluated)
            return;
          const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
          if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
              if (schEvaluated.props !== void 0) {
                it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
              }
            } else {
              const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
              it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
            }
          }
          if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
              if (schEvaluated.items !== void 0) {
                it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
              }
            } else {
              const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
              it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
            }
          }
        }
      }
      exports21.callRef = callRef;
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/core/index.js
  var require_core2 = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/core/index.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var id_1 = require_id();
      var ref_1 = require_ref();
      var core = [
        "$schema",
        "$id",
        "$defs",
        "$vocabulary",
        { keyword: "$comment" },
        "definitions",
        id_1.default,
        ref_1.default
      ];
      exports21.default = core;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/validation/limitNumber.js
  var require_limitNumber = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var ops = codegen_1.operators;
      var KWDs = {
        maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
        minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
        exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
        exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
      };
      var error = {
        message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
        params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
      };
      var def = {
        keyword: Object.keys(KWDs),
        type: "number",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt;
          cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/validation/multipleOf.js
  var require_multipleOf = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var error = {
        message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
        params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
      };
      var def = {
        keyword: "multipleOf",
        type: "number",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, it } = cxt;
          const prec = it.opts.multipleOfPrecision;
          const res = gen.let("res");
          const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
          cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/runtime/ucs2length.js
  var require_ucs2length = __commonJS({
    "../../node_modules/ajv/dist/runtime/ucs2length.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      function ucs2length(str) {
        const len = str.length;
        let length = 0;
        let pos = 0;
        let value;
        while (pos < len) {
          length++;
          value = str.charCodeAt(pos++);
          if (value >= 55296 && value <= 56319 && pos < len) {
            value = str.charCodeAt(pos);
            if ((value & 64512) === 56320)
              pos++;
          }
        }
        return length;
      }
      exports21.default = ucs2length;
      ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/validation/limitLength.js
  var require_limitLength = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var ucs2length_1 = require_ucs2length();
      var error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === "maxLength" ? "more" : "fewer";
          return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      };
      var def = {
        keyword: ["maxLength", "minLength"],
        type: "string",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode, it } = cxt;
          const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
          const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
          cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/validation/pattern.js
  var require_pattern = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var code_1 = require_code2();
      var codegen_1 = require_codegen();
      var error = {
        message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
        params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
      };
      var def = {
        keyword: "pattern",
        type: "string",
        schemaType: "string",
        $data: true,
        error,
        code(cxt) {
          const { data, $data, schema, schemaCode, it } = cxt;
          const u5 = it.opts.unicodeRegExp ? "u" : "";
          const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u5}))` : (0, code_1.usePattern)(cxt, schema);
          cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/validation/limitProperties.js
  var require_limitProperties = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === "maxProperties" ? "more" : "fewer";
          return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      };
      var def = {
        keyword: ["maxProperties", "minProperties"],
        type: "object",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt;
          const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
          cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/validation/required.js
  var require_required = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/validation/required.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var code_1 = require_code2();
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
        params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
      };
      var def = {
        keyword: "required",
        type: "object",
        schemaType: "array",
        $data: true,
        error,
        code(cxt) {
          const { gen, schema, schemaCode, data, $data, it } = cxt;
          const { opts } = it;
          if (!$data && schema.length === 0)
            return;
          const useLoop = schema.length >= opts.loopRequired;
          if (it.allErrors)
            allErrorsMode();
          else
            exitOnErrorMode();
          if (opts.strictRequired) {
            const props = cxt.parentSchema.properties;
            const { definedProperties } = cxt.it;
            for (const requiredKey of schema) {
              if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
                const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
              }
            }
          }
          function allErrorsMode() {
            if (useLoop || $data) {
              cxt.block$data(codegen_1.nil, loopAllRequired);
            } else {
              for (const prop of schema) {
                (0, code_1.checkReportMissingProp)(cxt, prop);
              }
            }
          }
          function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
              const valid = gen.let("valid", true);
              cxt.block$data(valid, () => loopUntilMissing(missing, valid));
              cxt.ok(valid);
            } else {
              gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
              (0, code_1.reportMissingProp)(cxt, missing);
              gen.else();
            }
          }
          function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
              cxt.setParams({ missingProperty: prop });
              gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
            });
          }
          function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
              gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.error();
                gen.break();
              });
            }, codegen_1.nil);
          }
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/validation/limitItems.js
  var require_limitItems = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === "maxItems" ? "more" : "fewer";
          return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      };
      var def = {
        keyword: ["maxItems", "minItems"],
        type: "array",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt;
          const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
          cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/runtime/equal.js
  var require_equal = __commonJS({
    "../../node_modules/ajv/dist/runtime/equal.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var equal = require_fast_deep_equal();
      equal.code = 'require("ajv/dist/runtime/equal").default';
      exports21.default = equal;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
  var require_uniqueItems = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var dataType_1 = require_dataType();
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var equal_1 = require_equal();
      var error = {
        message: ({ params: { i: i5, j: j3 } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j3} and ${i5} are identical)`,
        params: ({ params: { i: i5, j: j3 } }) => (0, codegen_1._)`{i: ${i5}, j: ${j3}}`
      };
      var def = {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
          if (!$data && !schema)
            return;
          const valid = gen.let("valid");
          const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
          cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
          cxt.ok(valid);
          function validateUniqueItems() {
            const i5 = gen.let("i", (0, codegen_1._)`${data}.length`);
            const j3 = gen.let("j");
            cxt.setParams({ i: i5, j: j3 });
            gen.assign(valid, true);
            gen.if((0, codegen_1._)`${i5} > 1`, () => (canOptimize() ? loopN : loopN2)(i5, j3));
          }
          function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t5) => t5 === "object" || t5 === "array");
          }
          function loopN(i5, j3) {
            const item = gen.name("item");
            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", (0, codegen_1._)`{}`);
            gen.for((0, codegen_1._)`;${i5}--;`, () => {
              gen.let(item, (0, codegen_1._)`${data}[${i5}]`);
              gen.if(wrongType, (0, codegen_1._)`continue`);
              if (itemTypes.length > 1)
                gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
              gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
                gen.assign(j3, (0, codegen_1._)`${indices}[${item}]`);
                cxt.error();
                gen.assign(valid, false).break();
              }).code((0, codegen_1._)`${indices}[${item}] = ${i5}`);
            });
          }
          function loopN2(i5, j3) {
            const eql = (0, util_1.useFunc)(gen, equal_1.default);
            const outer = gen.name("outer");
            gen.label(outer).for((0, codegen_1._)`;${i5}--;`, () => gen.for((0, codegen_1._)`${j3} = ${i5}; ${j3}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i5}], ${data}[${j3}])`, () => {
              cxt.error();
              gen.assign(valid, false).break(outer);
            })));
          }
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/validation/const.js
  var require_const = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/validation/const.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var equal_1 = require_equal();
      var error = {
        message: "must be equal to constant",
        params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
      };
      var def = {
        keyword: "const",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schemaCode, schema } = cxt;
          if ($data || schema && typeof schema == "object") {
            cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
          } else {
            cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
          }
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/validation/enum.js
  var require_enum = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/validation/enum.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var equal_1 = require_equal();
      var error = {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
      };
      var def = {
        keyword: "enum",
        schemaType: "array",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, schemaCode, it } = cxt;
          if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
          const useLoop = schema.length >= it.opts.loopEnum;
          let eql;
          const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
          let valid;
          if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
          } else {
            if (!Array.isArray(schema))
              throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = (0, codegen_1.or)(...schema.map((_x, i5) => equalCode(vSchema, i5)));
          }
          cxt.pass(valid);
          function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v5) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v5})`, () => gen.assign(valid, true).break()));
          }
          function equalCode(vSchema, i5) {
            const sch = schema[i5];
            return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i5}])` : (0, codegen_1._)`${data} === ${sch}`;
          }
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/validation/index.js
  var require_validation = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/validation/index.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var limitNumber_1 = require_limitNumber();
      var multipleOf_1 = require_multipleOf();
      var limitLength_1 = require_limitLength();
      var pattern_1 = require_pattern();
      var limitProperties_1 = require_limitProperties();
      var required_1 = require_required();
      var limitItems_1 = require_limitItems();
      var uniqueItems_1 = require_uniqueItems();
      var const_1 = require_const();
      var enum_1 = require_enum();
      var validation = [
        // number
        limitNumber_1.default,
        multipleOf_1.default,
        // string
        limitLength_1.default,
        pattern_1.default,
        // object
        limitProperties_1.default,
        required_1.default,
        // array
        limitItems_1.default,
        uniqueItems_1.default,
        // any
        { keyword: "type", schemaType: ["string", "array"] },
        { keyword: "nullable", schemaType: "boolean" },
        const_1.default,
        enum_1.default
      ];
      exports21.default = validation;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
  var require_additionalItems = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.validateAdditionalItems = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
      };
      var def = {
        keyword: "additionalItems",
        type: "array",
        schemaType: ["boolean", "object"],
        before: "uniqueItems",
        error,
        code(cxt) {
          const { parentSchema, it } = cxt;
          const { items } = parentSchema;
          if (!Array.isArray(items)) {
            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
          }
          validateAdditionalItems(cxt, items);
        }
      };
      function validateAdditionalItems(cxt, items) {
        const { gen, schema, data, keyword, it } = cxt;
        it.items = true;
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        if (schema === false) {
          cxt.setParams({ len: items.length });
          cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
        } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
          const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
          gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
          cxt.ok(valid);
        }
        function validateItems(valid) {
          gen.forRange("i", items.length, len, (i5) => {
            cxt.subschema({ keyword, dataProp: i5, dataPropType: util_1.Type.Num }, valid);
            if (!it.allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          });
        }
      }
      exports21.validateAdditionalItems = validateAdditionalItems;
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/items.js
  var require_items = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/items.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.validateTuple = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var code_1 = require_code2();
      var def = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "array", "boolean"],
        before: "uniqueItems",
        code(cxt) {
          const { schema, it } = cxt;
          if (Array.isArray(schema))
            return validateTuple(cxt, "additionalItems", schema);
          it.items = true;
          if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
          cxt.ok((0, code_1.validateArray)(cxt));
        }
      };
      function validateTuple(cxt, extraItems, schArr = cxt.schema) {
        const { gen, parentSchema, data, keyword, it } = cxt;
        checkStrictTuple(parentSchema);
        if (it.opts.unevaluated && schArr.length && it.items !== true) {
          it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
        }
        const valid = gen.name("valid");
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        schArr.forEach((sch, i5) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          gen.if((0, codegen_1._)`${len} > ${i5}`, () => cxt.subschema({
            keyword,
            schemaProp: i5,
            dataProp: i5
          }, valid));
          cxt.ok(valid);
        });
        function checkStrictTuple(sch) {
          const { opts, errSchemaPath } = it;
          const l5 = schArr.length;
          const fullTuple = l5 === sch.minItems && (l5 === sch.maxItems || sch[extraItems] === false);
          if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword}" is ${l5}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
          }
        }
      }
      exports21.validateTuple = validateTuple;
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
  var require_prefixItems = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var items_1 = require_items();
      var def = {
        keyword: "prefixItems",
        type: "array",
        schemaType: ["array"],
        before: "uniqueItems",
        code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/items2020.js
  var require_items2020 = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var code_1 = require_code2();
      var additionalItems_1 = require_additionalItems();
      var error = {
        message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
      };
      var def = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        error,
        code(cxt) {
          const { schema, parentSchema, it } = cxt;
          const { prefixItems } = parentSchema;
          it.items = true;
          if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
          if (prefixItems)
            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
          else
            cxt.ok((0, code_1.validateArray)(cxt));
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/contains.js
  var require_contains = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
        params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
      };
      var def = {
        keyword: "contains",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt;
          let min;
          let max;
          const { minContains, maxContains } = parentSchema;
          if (it.opts.next) {
            min = minContains === void 0 ? 1 : minContains;
            max = maxContains;
          } else {
            min = 1;
          }
          const len = gen.const("len", (0, codegen_1._)`${data}.length`);
          cxt.setParams({ min, max });
          if (max === void 0 && min === 0) {
            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
          }
          if (max !== void 0 && min > max) {
            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
          }
          if ((0, util_1.alwaysValidSchema)(it, schema)) {
            let cond = (0, codegen_1._)`${len} >= ${min}`;
            if (max !== void 0)
              cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
          }
          it.items = true;
          const valid = gen.name("valid");
          if (max === void 0 && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
          } else if (min === 0) {
            gen.let(valid, true);
            if (max !== void 0)
              gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
          } else {
            gen.let(valid, false);
            validateItemsWithCount();
          }
          cxt.result(valid, () => cxt.reset());
          function validateItemsWithCount() {
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
          }
          function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i5) => {
              cxt.subschema({
                keyword: "contains",
                dataProp: i5,
                dataPropType: util_1.Type.Num,
                compositeRule: true
              }, _valid);
              block();
            });
          }
          function checkLimits(count) {
            gen.code((0, codegen_1._)`${count}++`);
            if (max === void 0) {
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
            } else {
              gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
              if (min === 1)
                gen.assign(valid, true);
              else
                gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
            }
          }
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/dependencies.js
  var require_dependencies = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.validateSchemaDeps = exports21.validatePropertyDeps = exports21.error = void 0;
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var code_1 = require_code2();
      exports21.error = {
        message: ({ params: { property, depsCount, deps } }) => {
          const property_ies = depsCount === 1 ? "property" : "properties";
          return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
        },
        params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
        // TODO change to reference
      };
      var def = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: exports21.error,
        code(cxt) {
          const [propDeps, schDeps] = splitDependencies(cxt);
          validatePropertyDeps(cxt, propDeps);
          validateSchemaDeps(cxt, schDeps);
        }
      };
      function splitDependencies({ schema }) {
        const propertyDeps = {};
        const schemaDeps = {};
        for (const key in schema) {
          if (key === "__proto__")
            continue;
          const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
          deps[key] = schema[key];
        }
        return [propertyDeps, schemaDeps];
      }
      function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
        const { gen, data, it } = cxt;
        if (Object.keys(propertyDeps).length === 0)
          return;
        const missing = gen.let("missing");
        for (const prop in propertyDeps) {
          const deps = propertyDeps[prop];
          if (deps.length === 0)
            continue;
          const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
          cxt.setParams({
            property: prop,
            depsCount: deps.length,
            deps: deps.join(", ")
          });
          if (it.allErrors) {
            gen.if(hasProperty, () => {
              for (const depProp of deps) {
                (0, code_1.checkReportMissingProp)(cxt, depProp);
              }
            });
          } else {
            gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
      }
      exports21.validatePropertyDeps = validatePropertyDeps;
      function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
        const { gen, data, keyword, it } = cxt;
        const valid = gen.name("valid");
        for (const prop in schemaDeps) {
          if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
            continue;
          gen.if(
            (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
            () => {
              const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
              cxt.mergeValidEvaluated(schCxt, valid);
            },
            () => gen.var(valid, true)
            // TODO var
          );
          cxt.ok(valid);
        }
      }
      exports21.validateSchemaDeps = validateSchemaDeps;
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
  var require_propertyNames = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: "property name must be valid",
        params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
      };
      var def = {
        keyword: "propertyNames",
        type: "object",
        schemaType: ["object", "boolean"],
        error,
        code(cxt) {
          const { gen, schema, data, it } = cxt;
          if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
          const valid = gen.name("valid");
          gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
              keyword: "propertyNames",
              data: key,
              dataTypes: ["string"],
              propertyName: key,
              compositeRule: true
            }, valid);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error(true);
              if (!it.allErrors)
                gen.break();
            });
          });
          cxt.ok(valid);
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
  var require_additionalProperties = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var code_1 = require_code2();
      var codegen_1 = require_codegen();
      var names_1 = require_names();
      var util_1 = require_util();
      var error = {
        message: "must NOT have additional properties",
        params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
      };
      var def = {
        keyword: "additionalProperties",
        type: ["object"],
        schemaType: ["boolean", "object"],
        allowUndefined: true,
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, errsCount, it } = cxt;
          if (!errsCount)
            throw new Error("ajv implementation error");
          const { allErrors, opts } = it;
          it.props = true;
          if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
            return;
          const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
          const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
          checkAdditionalProperties();
          cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
          function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
              if (!props.length && !patProps.length)
                additionalPropertyCode(key);
              else
                gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
          }
          function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
              const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
              definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
            } else if (props.length) {
              definedProp = (0, codegen_1.or)(...props.map((p5) => (0, codegen_1._)`${key} === ${p5}`));
            } else {
              definedProp = codegen_1.nil;
            }
            if (patProps.length) {
              definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p5) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p5)}.test(${key})`));
            }
            return (0, codegen_1.not)(definedProp);
          }
          function deleteAdditional(key) {
            gen.code((0, codegen_1._)`delete ${data}[${key}]`);
          }
          function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
              deleteAdditional(key);
              return;
            }
            if (schema === false) {
              cxt.setParams({ additionalProperty: key });
              cxt.error();
              if (!allErrors)
                gen.break();
              return;
            }
            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
              const valid = gen.name("valid");
              if (opts.removeAdditional === "failing") {
                applyAdditionalSchema(key, valid, false);
                gen.if((0, codegen_1.not)(valid), () => {
                  cxt.reset();
                  deleteAdditional(key);
                });
              } else {
                applyAdditionalSchema(key, valid);
                if (!allErrors)
                  gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            }
          }
          function applyAdditionalSchema(key, valid, errors) {
            const subschema = {
              keyword: "additionalProperties",
              dataProp: key,
              dataPropType: util_1.Type.Str
            };
            if (errors === false) {
              Object.assign(subschema, {
                compositeRule: true,
                createErrors: false,
                allErrors: false
              });
            }
            cxt.subschema(subschema, valid);
          }
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/properties.js
  var require_properties = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var validate_1 = require_validate();
      var code_1 = require_code2();
      var util_1 = require_util();
      var additionalProperties_1 = require_additionalProperties();
      var def = {
        keyword: "properties",
        type: "object",
        schemaType: "object",
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt;
          if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
          }
          const allProps = (0, code_1.allSchemaProperties)(schema);
          for (const prop of allProps) {
            it.definedProperties.add(prop);
          }
          if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
          }
          const properties = allProps.filter((p5) => !(0, util_1.alwaysValidSchema)(it, schema[p5]));
          if (properties.length === 0)
            return;
          const valid = gen.name("valid");
          for (const prop of properties) {
            if (hasDefault(prop)) {
              applyPropertySchema(prop);
            } else {
              gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
              applyPropertySchema(prop);
              if (!it.allErrors)
                gen.else().var(valid, true);
              gen.endIf();
            }
            cxt.it.definedProperties.add(prop);
            cxt.ok(valid);
          }
          function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
          }
          function applyPropertySchema(prop) {
            cxt.subschema({
              keyword: "properties",
              schemaProp: prop,
              dataProp: prop
            }, valid);
          }
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
  var require_patternProperties = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var code_1 = require_code2();
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var util_2 = require_util();
      var def = {
        keyword: "patternProperties",
        type: "object",
        schemaType: "object",
        code(cxt) {
          const { gen, schema, data, parentSchema, it } = cxt;
          const { opts } = it;
          const patterns = (0, code_1.allSchemaProperties)(schema);
          const alwaysValidPatterns = patterns.filter((p5) => (0, util_1.alwaysValidSchema)(it, schema[p5]));
          if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
            return;
          }
          const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
          const valid = gen.name("valid");
          if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
          }
          const { props } = it;
          validatePatternProperties();
          function validatePatternProperties() {
            for (const pat of patterns) {
              if (checkProperties)
                checkMatchingProperties(pat);
              if (it.allErrors) {
                validateProperties(pat);
              } else {
                gen.var(valid, true);
                validateProperties(pat);
                gen.if(valid);
              }
            }
          }
          function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
              if (new RegExp(pat).test(prop)) {
                (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
              }
            }
          }
          function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
              gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
                const alwaysValid = alwaysValidPatterns.includes(pat);
                if (!alwaysValid) {
                  cxt.subschema({
                    keyword: "patternProperties",
                    schemaProp: pat,
                    dataProp: key,
                    dataPropType: util_2.Type.Str
                  }, valid);
                }
                if (it.opts.unevaluated && props !== true) {
                  gen.assign((0, codegen_1._)`${props}[${key}]`, true);
                } else if (!alwaysValid && !it.allErrors) {
                  gen.if((0, codegen_1.not)(valid), () => gen.break());
                }
              });
            });
          }
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/not.js
  var require_not = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/not.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var util_1 = require_util();
      var def = {
        keyword: "not",
        schemaType: ["object", "boolean"],
        trackErrors: true,
        code(cxt) {
          const { gen, schema, it } = cxt;
          if ((0, util_1.alwaysValidSchema)(it, schema)) {
            cxt.fail();
            return;
          }
          const valid = gen.name("valid");
          cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, valid);
          cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
        },
        error: { message: "must NOT be valid" }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/anyOf.js
  var require_anyOf = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var code_1 = require_code2();
      var def = {
        keyword: "anyOf",
        schemaType: "array",
        trackErrors: true,
        code: code_1.validateUnion,
        error: { message: "must match a schema in anyOf" }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/oneOf.js
  var require_oneOf = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: "must match exactly one schema in oneOf",
        params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
      };
      var def = {
        keyword: "oneOf",
        schemaType: "array",
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, it } = cxt;
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          if (it.opts.discriminator && parentSchema.discriminator)
            return;
          const schArr = schema;
          const valid = gen.let("valid", false);
          const passing = gen.let("passing", null);
          const schValid = gen.name("_valid");
          cxt.setParams({ passing });
          gen.block(validateOneOf);
          cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
          function validateOneOf() {
            schArr.forEach((sch, i5) => {
              let schCxt;
              if ((0, util_1.alwaysValidSchema)(it, sch)) {
                gen.var(schValid, true);
              } else {
                schCxt = cxt.subschema({
                  keyword: "oneOf",
                  schemaProp: i5,
                  compositeRule: true
                }, schValid);
              }
              if (i5 > 0) {
                gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i5}]`).else();
              }
              gen.if(schValid, () => {
                gen.assign(valid, true);
                gen.assign(passing, i5);
                if (schCxt)
                  cxt.mergeEvaluated(schCxt, codegen_1.Name);
              });
            });
          }
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/allOf.js
  var require_allOf = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var util_1 = require_util();
      var def = {
        keyword: "allOf",
        schemaType: "array",
        code(cxt) {
          const { gen, schema, it } = cxt;
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const valid = gen.name("valid");
          schema.forEach((sch, i5) => {
            if ((0, util_1.alwaysValidSchema)(it, sch))
              return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i5 }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
          });
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/if.js
  var require_if = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/if.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var util_1 = require_util();
      var error = {
        message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
        params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
      };
      var def = {
        keyword: "if",
        schemaType: ["object", "boolean"],
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, parentSchema, it } = cxt;
          if (parentSchema.then === void 0 && parentSchema.else === void 0) {
            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
          }
          const hasThen = hasSchema(it, "then");
          const hasElse = hasSchema(it, "else");
          if (!hasThen && !hasElse)
            return;
          const valid = gen.let("valid", true);
          const schValid = gen.name("_valid");
          validateIf();
          cxt.reset();
          if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
          } else if (hasThen) {
            gen.if(schValid, validateClause("then"));
          } else {
            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
          }
          cxt.pass(valid, () => cxt.error(true));
          function validateIf() {
            const schCxt = cxt.subschema({
              keyword: "if",
              compositeRule: true,
              createErrors: false,
              allErrors: false
            }, schValid);
            cxt.mergeEvaluated(schCxt);
          }
          function validateClause(keyword, ifClause) {
            return () => {
              const schCxt = cxt.subschema({ keyword }, schValid);
              gen.assign(valid, schValid);
              cxt.mergeValidEvaluated(schCxt, valid);
              if (ifClause)
                gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
              else
                cxt.setParams({ ifClause: keyword });
            };
          }
        }
      };
      function hasSchema(it, keyword) {
        const schema = it.schema[keyword];
        return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
      }
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/thenElse.js
  var require_thenElse = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var util_1 = require_util();
      var def = {
        keyword: ["then", "else"],
        schemaType: ["object", "boolean"],
        code({ keyword, parentSchema, it }) {
          if (parentSchema.if === void 0)
            (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/applicator/index.js
  var require_applicator = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/applicator/index.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var additionalItems_1 = require_additionalItems();
      var prefixItems_1 = require_prefixItems();
      var items_1 = require_items();
      var items2020_1 = require_items2020();
      var contains_1 = require_contains();
      var dependencies_1 = require_dependencies();
      var propertyNames_1 = require_propertyNames();
      var additionalProperties_1 = require_additionalProperties();
      var properties_1 = require_properties();
      var patternProperties_1 = require_patternProperties();
      var not_1 = require_not();
      var anyOf_1 = require_anyOf();
      var oneOf_1 = require_oneOf();
      var allOf_1 = require_allOf();
      var if_1 = require_if();
      var thenElse_1 = require_thenElse();
      function getApplicator(draft2020 = false) {
        const applicator = [
          // any
          not_1.default,
          anyOf_1.default,
          oneOf_1.default,
          allOf_1.default,
          if_1.default,
          thenElse_1.default,
          // object
          propertyNames_1.default,
          additionalProperties_1.default,
          dependencies_1.default,
          properties_1.default,
          patternProperties_1.default
        ];
        if (draft2020)
          applicator.push(prefixItems_1.default, items2020_1.default);
        else
          applicator.push(additionalItems_1.default, items_1.default);
        applicator.push(contains_1.default);
        return applicator;
      }
      exports21.default = getApplicator;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/format/format.js
  var require_format = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/format/format.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var error = {
        message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
        params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
      };
      var def = {
        keyword: "format",
        type: ["number", "string"],
        schemaType: "string",
        $data: true,
        error,
        code(cxt, ruleType) {
          const { gen, data, $data, schema, schemaCode, it } = cxt;
          const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
          if (!opts.validateFormats)
            return;
          if ($data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format3 = gen.let("format");
            gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format3, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format3, fDef));
            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
            function unknownFmt() {
              if (opts.strictSchema === false)
                return codegen_1.nil;
              return (0, codegen_1._)`${schemaCode} && !${format3}`;
            }
            function invalidFmt() {
              const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format3}(${data}) : ${format3}(${data}))` : (0, codegen_1._)`${format3}(${data})`;
              const validData = (0, codegen_1._)`(typeof ${format3} == "function" ? ${callFormat} : ${format3}.test(${data}))`;
              return (0, codegen_1._)`${format3} && ${format3} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
          }
          function validateFormat() {
            const formatDef = self2.formats[schema];
            if (!formatDef) {
              unknownFormat();
              return;
            }
            if (formatDef === true)
              return;
            const [fmtType, format3, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
              cxt.pass(validCondition());
            function unknownFormat() {
              if (opts.strictSchema === false) {
                self2.logger.warn(unknownMsg());
                return;
              }
              throw new Error(unknownMsg());
              function unknownMsg() {
                return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
              }
            }
            function getFormat(fmtDef) {
              const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
              const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
              if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
              }
              return ["string", fmtDef, fmt];
            }
            function validCondition() {
              if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                if (!schemaEnv.$async)
                  throw new Error("async format in sync schema");
                return (0, codegen_1._)`await ${fmtRef}(${data})`;
              }
              return typeof format3 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
            }
          }
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/format/index.js
  var require_format2 = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/format/index.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var format_1 = require_format();
      var format3 = [format_1.default];
      exports21.default = format3;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/metadata.js
  var require_metadata = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/metadata.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.contentVocabulary = exports21.metadataVocabulary = void 0;
      exports21.metadataVocabulary = [
        "title",
        "description",
        "default",
        "deprecated",
        "readOnly",
        "writeOnly",
        "examples"
      ];
      exports21.contentVocabulary = [
        "contentMediaType",
        "contentEncoding",
        "contentSchema"
      ];
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/draft7.js
  var require_draft7 = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/draft7.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var core_1 = require_core2();
      var validation_1 = require_validation();
      var applicator_1 = require_applicator();
      var format_1 = require_format2();
      var metadata_1 = require_metadata();
      var draft7Vocabularies = [
        core_1.default,
        validation_1.default,
        (0, applicator_1.default)(),
        format_1.default,
        metadata_1.metadataVocabulary,
        metadata_1.contentVocabulary
      ];
      exports21.default = draft7Vocabularies;
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/discriminator/types.js
  var require_types = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.DiscrError = void 0;
      var DiscrError;
      (function(DiscrError2) {
        DiscrError2["Tag"] = "tag";
        DiscrError2["Mapping"] = "mapping";
      })(DiscrError || (exports21.DiscrError = DiscrError = {}));
    }
  });

  // ../../node_modules/ajv/dist/vocabularies/discriminator/index.js
  var require_discriminator = __commonJS({
    "../../node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var codegen_1 = require_codegen();
      var types_1 = require_types();
      var compile_1 = require_compile();
      var ref_error_1 = require_ref_error();
      var util_1 = require_util();
      var error = {
        message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
        params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
      };
      var def = {
        keyword: "discriminator",
        type: "object",
        schemaType: "object",
        error,
        code(cxt) {
          const { gen, data, schema, parentSchema, it } = cxt;
          const { oneOf } = parentSchema;
          if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
          }
          const tagName = schema.propertyName;
          if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
          if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
          if (!oneOf)
            throw new Error("discriminator: requires oneOf keyword");
          const valid = gen.let("valid", false);
          const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
          gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
          cxt.ok(valid);
          function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
              gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
              gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
            gen.endIf();
          }
          function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
          }
          function getMapping() {
            var _a;
            const oneOfMapping = {};
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i5 = 0; i5 < oneOf.length; i5++) {
              let sch = oneOf[i5];
              if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
                const ref = sch.$ref;
                sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
                if (sch instanceof compile_1.SchemaEnv)
                  sch = sch.schema;
                if (sch === void 0)
                  throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
              }
              const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
              if (typeof propSch != "object") {
                throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
              }
              tagRequired = tagRequired && (topRequired || hasRequired(sch));
              addMappings(propSch, i5);
            }
            if (!tagRequired)
              throw new Error(`discriminator: "${tagName}" must be required`);
            return oneOfMapping;
            function hasRequired({ required }) {
              return Array.isArray(required) && required.includes(tagName);
            }
            function addMappings(sch, i5) {
              if (sch.const) {
                addMapping(sch.const, i5);
              } else if (sch.enum) {
                for (const tagValue of sch.enum) {
                  addMapping(tagValue, i5);
                }
              } else {
                throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
              }
            }
            function addMapping(tagValue, i5) {
              if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                throw new Error(`discriminator: "${tagName}" values must be unique strings`);
              }
              oneOfMapping[tagValue] = i5;
            }
          }
        }
      };
      exports21.default = def;
    }
  });

  // ../../node_modules/ajv/dist/refs/json-schema-draft-07.json
  var require_json_schema_draft_07 = __commonJS({
    "../../node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports21, module) {
      module.exports = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "http://json-schema.org/draft-07/schema#",
        title: "Core schema meta-schema",
        definitions: {
          schemaArray: {
            type: "array",
            minItems: 1,
            items: { $ref: "#" }
          },
          nonNegativeInteger: {
            type: "integer",
            minimum: 0
          },
          nonNegativeIntegerDefault0: {
            allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
          },
          simpleTypes: {
            enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
          },
          stringArray: {
            type: "array",
            items: { type: "string" },
            uniqueItems: true,
            default: []
          }
        },
        type: ["object", "boolean"],
        properties: {
          $id: {
            type: "string",
            format: "uri-reference"
          },
          $schema: {
            type: "string",
            format: "uri"
          },
          $ref: {
            type: "string",
            format: "uri-reference"
          },
          $comment: {
            type: "string"
          },
          title: {
            type: "string"
          },
          description: {
            type: "string"
          },
          default: true,
          readOnly: {
            type: "boolean",
            default: false
          },
          examples: {
            type: "array",
            items: true
          },
          multipleOf: {
            type: "number",
            exclusiveMinimum: 0
          },
          maximum: {
            type: "number"
          },
          exclusiveMaximum: {
            type: "number"
          },
          minimum: {
            type: "number"
          },
          exclusiveMinimum: {
            type: "number"
          },
          maxLength: { $ref: "#/definitions/nonNegativeInteger" },
          minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          pattern: {
            type: "string",
            format: "regex"
          },
          additionalItems: { $ref: "#" },
          items: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
            default: true
          },
          maxItems: { $ref: "#/definitions/nonNegativeInteger" },
          minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          uniqueItems: {
            type: "boolean",
            default: false
          },
          contains: { $ref: "#" },
          maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
          minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          required: { $ref: "#/definitions/stringArray" },
          additionalProperties: { $ref: "#" },
          definitions: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          properties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          patternProperties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            propertyNames: { format: "regex" },
            default: {}
          },
          dependencies: {
            type: "object",
            additionalProperties: {
              anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
            }
          },
          propertyNames: { $ref: "#" },
          const: true,
          enum: {
            type: "array",
            items: true,
            minItems: 1,
            uniqueItems: true
          },
          type: {
            anyOf: [
              { $ref: "#/definitions/simpleTypes" },
              {
                type: "array",
                items: { $ref: "#/definitions/simpleTypes" },
                minItems: 1,
                uniqueItems: true
              }
            ]
          },
          format: { type: "string" },
          contentMediaType: { type: "string" },
          contentEncoding: { type: "string" },
          if: { $ref: "#" },
          then: { $ref: "#" },
          else: { $ref: "#" },
          allOf: { $ref: "#/definitions/schemaArray" },
          anyOf: { $ref: "#/definitions/schemaArray" },
          oneOf: { $ref: "#/definitions/schemaArray" },
          not: { $ref: "#" }
        },
        default: true
      };
    }
  });

  // ../../node_modules/ajv/dist/ajv.js
  var require_ajv = __commonJS({
    "../../node_modules/ajv/dist/ajv.js"(exports21, module) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.MissingRefError = exports21.ValidationError = exports21.CodeGen = exports21.Name = exports21.nil = exports21.stringify = exports21.str = exports21._ = exports21.KeywordCxt = exports21.Ajv = void 0;
      var core_1 = require_core();
      var draft7_1 = require_draft7();
      var discriminator_1 = require_discriminator();
      var draft7MetaSchema = require_json_schema_draft_07();
      var META_SUPPORT_DATA = ["/properties"];
      var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
      var Ajv = class extends core_1.default {
        _addVocabularies() {
          super._addVocabularies();
          draft7_1.default.forEach((v5) => this.addVocabulary(v5));
          if (this.opts.discriminator)
            this.addKeyword(discriminator_1.default);
        }
        _addDefaultMetaSchema() {
          super._addDefaultMetaSchema();
          if (!this.opts.meta)
            return;
          const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
          this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
          this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
        }
      };
      exports21.Ajv = Ajv;
      module.exports = exports21 = Ajv;
      module.exports.Ajv = Ajv;
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.default = Ajv;
      var validate_1 = require_validate();
      Object.defineProperty(exports21, "KeywordCxt", { enumerable: true, get: function() {
        return validate_1.KeywordCxt;
      } });
      var codegen_1 = require_codegen();
      Object.defineProperty(exports21, "_", { enumerable: true, get: function() {
        return codegen_1._;
      } });
      Object.defineProperty(exports21, "str", { enumerable: true, get: function() {
        return codegen_1.str;
      } });
      Object.defineProperty(exports21, "stringify", { enumerable: true, get: function() {
        return codegen_1.stringify;
      } });
      Object.defineProperty(exports21, "nil", { enumerable: true, get: function() {
        return codegen_1.nil;
      } });
      Object.defineProperty(exports21, "Name", { enumerable: true, get: function() {
        return codegen_1.Name;
      } });
      Object.defineProperty(exports21, "CodeGen", { enumerable: true, get: function() {
        return codegen_1.CodeGen;
      } });
      var validation_error_1 = require_validation_error();
      Object.defineProperty(exports21, "ValidationError", { enumerable: true, get: function() {
        return validation_error_1.default;
      } });
      var ref_error_1 = require_ref_error();
      Object.defineProperty(exports21, "MissingRefError", { enumerable: true, get: function() {
        return ref_error_1.default;
      } });
    }
  });

  // ../../node_modules/ajv-formats/dist/formats.js
  var require_formats = __commonJS({
    "../../node_modules/ajv-formats/dist/formats.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.formatNames = exports21.fastFormats = exports21.fullFormats = void 0;
      function fmtDef(validate, compare) {
        return { validate, compare };
      }
      exports21.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: fmtDef(date, compareDate),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: fmtDef(getTime(true), compareTime),
        "date-time": fmtDef(getDateTime(true), compareDateTime),
        "iso-time": fmtDef(getTime(), compareIsoTime),
        "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte,
        // signed 32 bit integer
        int32: { type: "number", validate: validateInt32 },
        // signed 64 bit integer
        int64: { type: "number", validate: validateInt64 },
        // C-type float
        float: { type: "number", validate: validateNumber },
        // C-type double
        double: { type: "number", validate: validateNumber },
        // hint to the UI to hide input strings
        password: true,
        // unchecked string payload
        binary: true
      };
      exports21.fastFormats = {
        ...exports21.fullFormats,
        date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
        time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
        "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
        "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
        "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      };
      exports21.formatNames = Object.keys(exports21.fullFormats);
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
      var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function date(str) {
        const matches = DATE.exec(str);
        if (!matches)
          return false;
        const year = +matches[1];
        const month = +matches[2];
        const day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
      }
      function compareDate(d1, d22) {
        if (!(d1 && d22))
          return void 0;
        if (d1 > d22)
          return 1;
        if (d1 < d22)
          return -1;
        return 0;
      }
      var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
      function getTime(strictTimeZone) {
        return function time(str) {
          const matches = TIME.exec(str);
          if (!matches)
            return false;
          const hr = +matches[1];
          const min = +matches[2];
          const sec = +matches[3];
          const tz = matches[4];
          const tzSign = matches[5] === "-" ? -1 : 1;
          const tzH = +(matches[6] || 0);
          const tzM = +(matches[7] || 0);
          if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
            return false;
          if (hr <= 23 && min <= 59 && sec < 60)
            return true;
          const utcMin = min - tzM * tzSign;
          const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
          return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
        };
      }
      function compareTime(s1, s22) {
        if (!(s1 && s22))
          return void 0;
        const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
        const t22 = (/* @__PURE__ */ new Date("2020-01-01T" + s22)).valueOf();
        if (!(t1 && t22))
          return void 0;
        return t1 - t22;
      }
      function compareIsoTime(t1, t22) {
        if (!(t1 && t22))
          return void 0;
        const a1 = TIME.exec(t1);
        const a22 = TIME.exec(t22);
        if (!(a1 && a22))
          return void 0;
        t1 = a1[1] + a1[2] + a1[3];
        t22 = a22[1] + a22[2] + a22[3];
        if (t1 > t22)
          return 1;
        if (t1 < t22)
          return -1;
        return 0;
      }
      var DATE_TIME_SEPARATOR = /t|\s/i;
      function getDateTime(strictTimeZone) {
        const time = getTime(strictTimeZone);
        return function date_time(str) {
          const dateTime = str.split(DATE_TIME_SEPARATOR);
          return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
        };
      }
      function compareDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const d1 = new Date(dt1).valueOf();
        const d22 = new Date(dt2).valueOf();
        if (!(d1 && d22))
          return void 0;
        return d1 - d22;
      }
      function compareIsoDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
        const [d22, t22] = dt2.split(DATE_TIME_SEPARATOR);
        const res = compareDate(d1, d22);
        if (res === void 0)
          return void 0;
        return res || compareTime(t1, t22);
      }
      var NOT_URI_FRAGMENT = /\/|:/;
      var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function uri(str) {
        return NOT_URI_FRAGMENT.test(str) && URI.test(str);
      }
      var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
      function byte(str) {
        BYTE.lastIndex = 0;
        return BYTE.test(str);
      }
      var MIN_INT32 = -(2 ** 31);
      var MAX_INT32 = 2 ** 31 - 1;
      function validateInt32(value) {
        return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
      }
      function validateInt64(value) {
        return Number.isInteger(value);
      }
      function validateNumber() {
        return true;
      }
      var Z_ANCHOR = /[^\\]\\Z/;
      function regex(str) {
        if (Z_ANCHOR.test(str))
          return false;
        try {
          new RegExp(str);
          return true;
        } catch (e5) {
          return false;
        }
      }
    }
  });

  // ../../node_modules/ajv-formats/dist/limit.js
  var require_limit = __commonJS({
    "../../node_modules/ajv-formats/dist/limit.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.formatLimitDefinition = void 0;
      var ajv_1 = require_ajv();
      var codegen_1 = require_codegen();
      var ops = codegen_1.operators;
      var KWDs = {
        formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
        formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
        formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
      };
      var error = {
        message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
        params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
      };
      exports21.formatLimitDefinition = {
        keyword: Object.keys(KWDs),
        type: "string",
        schemaType: "string",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, keyword, it } = cxt;
          const { opts, self: self2 } = it;
          if (!opts.validateFormats)
            return;
          const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
          if (fCxt.$data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
          }
          function validateFormat() {
            const format3 = fCxt.schema;
            const fmtDef = self2.formats[format3];
            if (!fmtDef || fmtDef === true)
              return;
            if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
              throw new Error(`"${keyword}": format "${format3}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
              key: format3,
              ref: fmtDef,
              code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format3)}` : void 0
            });
            cxt.fail$data(compareCode(fmt));
          }
          function compareCode(fmt) {
            return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
          }
        },
        dependencies: ["format"]
      };
      var formatLimitPlugin = (ajv) => {
        ajv.addKeyword(exports21.formatLimitDefinition);
        return ajv;
      };
      exports21.default = formatLimitPlugin;
    }
  });

  // ../../node_modules/ajv-formats/dist/index.js
  var require_dist = __commonJS({
    "../../node_modules/ajv-formats/dist/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var formats_1 = require_formats();
      var limit_1 = require_limit();
      var codegen_1 = require_codegen();
      var fullName = new codegen_1.Name("fullFormats");
      var fastName = new codegen_1.Name("fastFormats");
      var formatsPlugin = (ajv, opts = { keywords: true }) => {
        if (Array.isArray(opts)) {
          addFormats(ajv, opts, formats_1.fullFormats, fullName);
          return ajv;
        }
        const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
        const list = opts.formats || formats_1.formatNames;
        addFormats(ajv, list, formats, exportName);
        if (opts.keywords)
          (0, limit_1.default)(ajv);
        return ajv;
      };
      formatsPlugin.get = (name2, mode = "full") => {
        const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
        const f5 = formats[name2];
        if (!f5)
          throw new Error(`Unknown format "${name2}"`);
        return f5;
      };
      function addFormats(ajv, list, fs, exportName) {
        var _a;
        var _b;
        (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
        for (const f5 of list)
          ajv.addFormat(f5, fs[f5]);
      }
      module.exports = exports21 = formatsPlugin;
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.default = formatsPlugin;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-CkFCi-G1.js
  function dew3() {
    if (_dewExec3) return exports4;
    _dewExec3 = true;
    if (typeof Object.create === "function") {
      exports4 = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      exports4 = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    return exports4;
  }
  var exports4, _dewExec3;
  var init_chunk_CkFCi_G1 = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-CkFCi-G1.js"() {
      init_buffer2();
      exports4 = {};
      _dewExec3 = false;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-tHuMsdT0.js
  function o() {
    o.init.call(this);
  }
  function u(e5) {
    if ("function" != typeof e5) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e5);
  }
  function f(e5) {
    return void 0 === e5._maxListeners ? o.defaultMaxListeners : e5._maxListeners;
  }
  function v(e5, t5, n5, r5) {
    var i5, o5, s5, v5;
    if (u(n5), void 0 === (o5 = e5._events) ? (o5 = e5._events = /* @__PURE__ */ Object.create(null), e5._eventsCount = 0) : (void 0 !== o5.newListener && (e5.emit("newListener", t5, n5.listener ? n5.listener : n5), o5 = e5._events), s5 = o5[t5]), void 0 === s5) s5 = o5[t5] = n5, ++e5._eventsCount;
    else if ("function" == typeof s5 ? s5 = o5[t5] = r5 ? [n5, s5] : [s5, n5] : r5 ? s5.unshift(n5) : s5.push(n5), (i5 = f(e5)) > 0 && s5.length > i5 && !s5.warned) {
      s5.warned = true;
      var a5 = new Error("Possible EventEmitter memory leak detected. " + s5.length + " " + String(t5) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a5.name = "MaxListenersExceededWarning", a5.emitter = e5, a5.type = t5, a5.count = s5.length, v5 = a5, console && console.warn && console.warn(v5);
    }
    return e5;
  }
  function a() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function l(e5, t5, n5) {
    var r5 = { fired: false, wrapFn: void 0, target: e5, type: t5, listener: n5 }, i5 = a.bind(r5);
    return i5.listener = n5, r5.wrapFn = i5, i5;
  }
  function h(e5, t5, n5) {
    var r5 = e5._events;
    if (void 0 === r5) return [];
    var i5 = r5[t5];
    return void 0 === i5 ? [] : "function" == typeof i5 ? n5 ? [i5.listener || i5] : [i5] : n5 ? function(e6) {
      for (var t6 = new Array(e6.length), n6 = 0; n6 < t6.length; ++n6) t6[n6] = e6[n6].listener || e6[n6];
      return t6;
    }(i5) : c(i5, i5.length);
  }
  function p(e5) {
    var t5 = this._events;
    if (void 0 !== t5) {
      var n5 = t5[e5];
      if ("function" == typeof n5) return 1;
      if (void 0 !== n5) return n5.length;
    }
    return 0;
  }
  function c(e5, t5) {
    for (var n5 = new Array(t5), r5 = 0; r5 < t5; ++r5) n5[r5] = e5[r5];
    return n5;
  }
  var e, t, n, r, i, s, y;
  var init_chunk_tHuMsdT0 = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-tHuMsdT0.js"() {
      init_buffer2();
      n = "object" == typeof Reflect ? Reflect : null;
      r = n && "function" == typeof n.apply ? n.apply : function(e5, t5, n5) {
        return Function.prototype.apply.call(e5, t5, n5);
      };
      t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e5) {
        return Object.getOwnPropertyNames(e5).concat(Object.getOwnPropertySymbols(e5));
      } : function(e5) {
        return Object.getOwnPropertyNames(e5);
      };
      i = Number.isNaN || function(e5) {
        return e5 != e5;
      };
      e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
      s = 10;
      Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
        return s;
      }, set: function(e5) {
        if ("number" != typeof e5 || e5 < 0 || i(e5)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e5 + ".");
        s = e5;
      } }), o.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, o.prototype.setMaxListeners = function(e5) {
        if ("number" != typeof e5 || e5 < 0 || i(e5)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e5 + ".");
        return this._maxListeners = e5, this;
      }, o.prototype.getMaxListeners = function() {
        return f(this);
      }, o.prototype.emit = function(e5) {
        for (var t5 = [], n5 = 1; n5 < arguments.length; n5++) t5.push(arguments[n5]);
        var i5 = "error" === e5, o5 = this._events;
        if (void 0 !== o5) i5 = i5 && void 0 === o5.error;
        else if (!i5) return false;
        if (i5) {
          var s5;
          if (t5.length > 0 && (s5 = t5[0]), s5 instanceof Error) throw s5;
          var u5 = new Error("Unhandled error." + (s5 ? " (" + s5.message + ")" : ""));
          throw u5.context = s5, u5;
        }
        var f5 = o5[e5];
        if (void 0 === f5) return false;
        if ("function" == typeof f5) r(f5, this, t5);
        else {
          var v5 = f5.length, a5 = c(f5, v5);
          for (n5 = 0; n5 < v5; ++n5) r(a5[n5], this, t5);
        }
        return true;
      }, o.prototype.addListener = function(e5, t5) {
        return v(this, e5, t5, false);
      }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e5, t5) {
        return v(this, e5, t5, true);
      }, o.prototype.once = function(e5, t5) {
        return u(t5), this.on(e5, l(this, e5, t5)), this;
      }, o.prototype.prependOnceListener = function(e5, t5) {
        return u(t5), this.prependListener(e5, l(this, e5, t5)), this;
      }, o.prototype.removeListener = function(e5, t5) {
        var n5, r5, i5, o5, s5;
        if (u(t5), void 0 === (r5 = this._events)) return this;
        if (void 0 === (n5 = r5[e5])) return this;
        if (n5 === t5 || n5.listener === t5) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r5[e5], r5.removeListener && this.emit("removeListener", e5, n5.listener || t5));
        else if ("function" != typeof n5) {
          for (i5 = -1, o5 = n5.length - 1; o5 >= 0; o5--) if (n5[o5] === t5 || n5[o5].listener === t5) {
            s5 = n5[o5].listener, i5 = o5;
            break;
          }
          if (i5 < 0) return this;
          0 === i5 ? n5.shift() : !function(e6, t6) {
            for (; t6 + 1 < e6.length; t6++) e6[t6] = e6[t6 + 1];
            e6.pop();
          }(n5, i5), 1 === n5.length && (r5[e5] = n5[0]), void 0 !== r5.removeListener && this.emit("removeListener", e5, s5 || t5);
        }
        return this;
      }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e5) {
        var t5, n5, r5;
        if (void 0 === (n5 = this._events)) return this;
        if (void 0 === n5.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n5[e5] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n5[e5]), this;
        if (0 === arguments.length) {
          var i5, o5 = Object.keys(n5);
          for (r5 = 0; r5 < o5.length; ++r5) "removeListener" !== (i5 = o5[r5]) && this.removeAllListeners(i5);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (t5 = n5[e5])) this.removeListener(e5, t5);
        else if (void 0 !== t5) for (r5 = t5.length - 1; r5 >= 0; r5--) this.removeListener(e5, t5[r5]);
        return this;
      }, o.prototype.listeners = function(e5) {
        return h(this, e5, true);
      }, o.prototype.rawListeners = function(e5) {
        return h(this, e5, false);
      }, o.listenerCount = function(e5, t5) {
        return "function" == typeof e5.listenerCount ? e5.listenerCount(t5) : p.call(e5, t5);
      }, o.prototype.listenerCount = p, o.prototype.eventNames = function() {
        return this._eventsCount > 0 ? t(this._events) : [];
      };
      y = e;
      y.EventEmitter;
      y.defaultMaxListeners;
      y.init;
      y.listenerCount;
      y.EventEmitter;
      y.defaultMaxListeners;
      y.init;
      y.listenerCount;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-DtDiafJB.js
  var init_chunk_DtDiafJB = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-DtDiafJB.js"() {
      init_buffer2();
      init_chunk_tHuMsdT0();
      y.once = function(emitter, event) {
        return new Promise((resolve2, reject) => {
          function eventListener(...args) {
            if (errorListener !== void 0) {
              emitter.removeListener("error", errorListener);
            }
            resolve2(args);
          }
          let errorListener;
          if (event !== "error") {
            errorListener = (err) => {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          emitter.once(event, eventListener);
        });
      };
      y.on = function(emitter, event) {
        const unconsumedEventValues = [];
        const unconsumedPromises = [];
        let error = null;
        let finished2 = false;
        const iterator = {
          async next() {
            const value = unconsumedEventValues.shift();
            if (value) {
              return createIterResult(value, false);
            }
            if (error) {
              const p5 = Promise.reject(error);
              error = null;
              return p5;
            }
            if (finished2) {
              return createIterResult(void 0, true);
            }
            return new Promise((resolve2, reject) => unconsumedPromises.push({ resolve: resolve2, reject }));
          },
          async return() {
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
            finished2 = true;
            for (const promise of unconsumedPromises) {
              promise.resolve(createIterResult(void 0, true));
            }
            return createIterResult(void 0, true);
          },
          throw(err) {
            error = err;
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
        emitter.on(event, eventHandler);
        emitter.on("error", errorHandler);
        return iterator;
        function eventHandler(...args) {
          const promise = unconsumedPromises.shift();
          if (promise) {
            promise.resolve(createIterResult(args, false));
          } else {
            unconsumedEventValues.push(args);
          }
        }
        function errorHandler(err) {
          finished2 = true;
          const toError = unconsumedPromises.shift();
          if (toError) {
            toError.reject(err);
          } else {
            error = err;
          }
          iterator.return();
        }
      };
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-D3uu3VYh.js
  function i$2() {
    throw new Error("setTimeout has not been defined");
  }
  function u$2() {
    throw new Error("clearTimeout has not been defined");
  }
  function c$2(e5) {
    if (t$3 === setTimeout) return setTimeout(e5, 0);
    if ((t$3 === i$2 || !t$3) && setTimeout) return t$3 = setTimeout, setTimeout(e5, 0);
    try {
      return t$3(e5, 0);
    } catch (n5) {
      try {
        return t$3.call(null, e5, 0);
      } catch (n6) {
        return t$3.call(this || r$2, e5, 0);
      }
    }
  }
  function h$1() {
    f$1 && l$2 && (f$1 = false, l$2.length ? s$1 = l$2.concat(s$1) : a$1 = -1, s$1.length && d$1());
  }
  function d$1() {
    if (!f$1) {
      var e5 = c$2(h$1);
      f$1 = true;
      for (var t5 = s$1.length; t5; ) {
        for (l$2 = s$1, s$1 = []; ++a$1 < t5; ) l$2 && l$2[a$1].run();
        a$1 = -1, t5 = s$1.length;
      }
      l$2 = null, f$1 = false, function(e6) {
        if (n$2 === clearTimeout) return clearTimeout(e6);
        if ((n$2 === u$2 || !n$2) && clearTimeout) return n$2 = clearTimeout, clearTimeout(e6);
        try {
          n$2(e6);
        } catch (t6) {
          try {
            return n$2.call(null, e6);
          } catch (t7) {
            return n$2.call(this || r$2, e6);
          }
        }
      }(e5);
    }
  }
  function m$1(e5, t5) {
    (this || r$2).fun = e5, (this || r$2).array = t5;
  }
  function p$1() {
  }
  function c$1(e5) {
    return e5.call.bind(e5);
  }
  function O(e5, t5) {
    if ("object" != typeof e5) return false;
    try {
      return t5(e5), true;
    } catch (e6) {
      return false;
    }
  }
  function S(e5) {
    return l$1 && y2 ? void 0 !== b(e5) : B(e5) || k(e5) || E(e5) || D(e5) || U(e5) || P(e5) || x(e5) || I(e5) || M(e5) || z(e5) || F(e5);
  }
  function B(e5) {
    return l$1 && y2 ? "Uint8Array" === b(e5) : "[object Uint8Array]" === m(e5) || u$1(e5) && void 0 !== e5.buffer;
  }
  function k(e5) {
    return l$1 && y2 ? "Uint8ClampedArray" === b(e5) : "[object Uint8ClampedArray]" === m(e5);
  }
  function E(e5) {
    return l$1 && y2 ? "Uint16Array" === b(e5) : "[object Uint16Array]" === m(e5);
  }
  function D(e5) {
    return l$1 && y2 ? "Uint32Array" === b(e5) : "[object Uint32Array]" === m(e5);
  }
  function U(e5) {
    return l$1 && y2 ? "Int8Array" === b(e5) : "[object Int8Array]" === m(e5);
  }
  function P(e5) {
    return l$1 && y2 ? "Int16Array" === b(e5) : "[object Int16Array]" === m(e5);
  }
  function x(e5) {
    return l$1 && y2 ? "Int32Array" === b(e5) : "[object Int32Array]" === m(e5);
  }
  function I(e5) {
    return l$1 && y2 ? "Float32Array" === b(e5) : "[object Float32Array]" === m(e5);
  }
  function M(e5) {
    return l$1 && y2 ? "Float64Array" === b(e5) : "[object Float64Array]" === m(e5);
  }
  function z(e5) {
    return l$1 && y2 ? "BigInt64Array" === b(e5) : "[object BigInt64Array]" === m(e5);
  }
  function F(e5) {
    return l$1 && y2 ? "BigUint64Array" === b(e5) : "[object BigUint64Array]" === m(e5);
  }
  function T(e5) {
    return "[object Map]" === m(e5);
  }
  function N(e5) {
    return "[object Set]" === m(e5);
  }
  function W(e5) {
    return "[object WeakMap]" === m(e5);
  }
  function $(e5) {
    return "[object WeakSet]" === m(e5);
  }
  function C(e5) {
    return "[object ArrayBuffer]" === m(e5);
  }
  function V(e5) {
    return "undefined" != typeof ArrayBuffer && (C.working ? C(e5) : e5 instanceof ArrayBuffer);
  }
  function G(e5) {
    return "[object DataView]" === m(e5);
  }
  function R(e5) {
    return "undefined" != typeof DataView && (G.working ? G(e5) : e5 instanceof DataView);
  }
  function J(e5) {
    return "[object SharedArrayBuffer]" === m(e5);
  }
  function _(e5) {
    return "undefined" != typeof SharedArrayBuffer && (J.working ? J(e5) : e5 instanceof SharedArrayBuffer);
  }
  function H(e5) {
    return O(e5, h2);
  }
  function Z(e5) {
    return O(e5, j);
  }
  function q(e5) {
    return O(e5, A);
  }
  function K(e5) {
    return s2 && O(e5, w);
  }
  function L(e5) {
    return p2 && O(e5, v2);
  }
  function oe(e5, t5) {
    var r5 = { seen: [], stylize: fe };
    return arguments.length >= 3 && (r5.depth = arguments[2]), arguments.length >= 4 && (r5.colors = arguments[3]), ye(t5) ? r5.showHidden = t5 : t5 && X._extend(r5, t5), be(r5.showHidden) && (r5.showHidden = false), be(r5.depth) && (r5.depth = 2), be(r5.colors) && (r5.colors = false), be(r5.customInspect) && (r5.customInspect = true), r5.colors && (r5.stylize = ue), ae(r5, e5, r5.depth);
  }
  function ue(e5, t5) {
    var r5 = oe.styles[t5];
    return r5 ? "\x1B[" + oe.colors[r5][0] + "m" + e5 + "\x1B[" + oe.colors[r5][1] + "m" : e5;
  }
  function fe(e5, t5) {
    return e5;
  }
  function ae(e5, t5, r5) {
    if (e5.customInspect && t5 && we(t5.inspect) && t5.inspect !== X.inspect && (!t5.constructor || t5.constructor.prototype !== t5)) {
      var n5 = t5.inspect(r5, e5);
      return ge(n5) || (n5 = ae(e5, n5, r5)), n5;
    }
    var i5 = function(e6, t6) {
      if (be(t6)) return e6.stylize("undefined", "undefined");
      if (ge(t6)) {
        var r6 = "'" + JSON.stringify(t6).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e6.stylize(r6, "string");
      }
      if (de(t6)) return e6.stylize("" + t6, "number");
      if (ye(t6)) return e6.stylize("" + t6, "boolean");
      if (le(t6)) return e6.stylize("null", "null");
    }(e5, t5);
    if (i5) return i5;
    var o5 = Object.keys(t5), u5 = function(e6) {
      var t6 = {};
      return e6.forEach(function(e7, r6) {
        t6[e7] = true;
      }), t6;
    }(o5);
    if (e5.showHidden && (o5 = Object.getOwnPropertyNames(t5)), Ae(t5) && (o5.indexOf("message") >= 0 || o5.indexOf("description") >= 0)) return ce(t5);
    if (0 === o5.length) {
      if (we(t5)) {
        var f5 = t5.name ? ": " + t5.name : "";
        return e5.stylize("[Function" + f5 + "]", "special");
      }
      if (me(t5)) return e5.stylize(RegExp.prototype.toString.call(t5), "regexp");
      if (je(t5)) return e5.stylize(Date.prototype.toString.call(t5), "date");
      if (Ae(t5)) return ce(t5);
    }
    var a5, c5 = "", s5 = false, p5 = ["{", "}"];
    (pe(t5) && (s5 = true, p5 = ["[", "]"]), we(t5)) && (c5 = " [Function" + (t5.name ? ": " + t5.name : "") + "]");
    return me(t5) && (c5 = " " + RegExp.prototype.toString.call(t5)), je(t5) && (c5 = " " + Date.prototype.toUTCString.call(t5)), Ae(t5) && (c5 = " " + ce(t5)), 0 !== o5.length || s5 && 0 != t5.length ? r5 < 0 ? me(t5) ? e5.stylize(RegExp.prototype.toString.call(t5), "regexp") : e5.stylize("[Object]", "special") : (e5.seen.push(t5), a5 = s5 ? function(e6, t6, r6, n6, i6) {
      for (var o6 = [], u6 = 0, f6 = t6.length; u6 < f6; ++u6) ke(t6, String(u6)) ? o6.push(se(e6, t6, r6, n6, String(u6), true)) : o6.push("");
      return i6.forEach(function(i7) {
        i7.match(/^\d+$/) || o6.push(se(e6, t6, r6, n6, i7, true));
      }), o6;
    }(e5, t5, r5, u5, o5) : o5.map(function(n6) {
      return se(e5, t5, r5, u5, n6, s5);
    }), e5.seen.pop(), function(e6, t6, r6) {
      var n6 = 0;
      if (e6.reduce(function(e7, t7) {
        return n6++, t7.indexOf("\n") >= 0 && n6++, e7 + t7.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60) return r6[0] + ("" === t6 ? "" : t6 + "\n ") + " " + e6.join(",\n  ") + " " + r6[1];
      return r6[0] + t6 + " " + e6.join(", ") + " " + r6[1];
    }(a5, c5, p5)) : p5[0] + c5 + p5[1];
  }
  function ce(e5) {
    return "[" + Error.prototype.toString.call(e5) + "]";
  }
  function se(e5, t5, r5, n5, i5, o5) {
    var u5, f5, a5;
    if ((a5 = Object.getOwnPropertyDescriptor(t5, i5) || { value: t5[i5] }).get ? f5 = a5.set ? e5.stylize("[Getter/Setter]", "special") : e5.stylize("[Getter]", "special") : a5.set && (f5 = e5.stylize("[Setter]", "special")), ke(n5, i5) || (u5 = "[" + i5 + "]"), f5 || (e5.seen.indexOf(a5.value) < 0 ? (f5 = le(r5) ? ae(e5, a5.value, null) : ae(e5, a5.value, r5 - 1)).indexOf("\n") > -1 && (f5 = o5 ? f5.split("\n").map(function(e6) {
      return "  " + e6;
    }).join("\n").substr(2) : "\n" + f5.split("\n").map(function(e6) {
      return "   " + e6;
    }).join("\n")) : f5 = e5.stylize("[Circular]", "special")), be(u5)) {
      if (o5 && i5.match(/^\d+$/)) return f5;
      (u5 = JSON.stringify("" + i5)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u5 = u5.substr(1, u5.length - 2), u5 = e5.stylize(u5, "name")) : (u5 = u5.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u5 = e5.stylize(u5, "string"));
    }
    return u5 + ": " + f5;
  }
  function pe(e5) {
    return Array.isArray(e5);
  }
  function ye(e5) {
    return "boolean" == typeof e5;
  }
  function le(e5) {
    return null === e5;
  }
  function de(e5) {
    return "number" == typeof e5;
  }
  function ge(e5) {
    return "string" == typeof e5;
  }
  function be(e5) {
    return void 0 === e5;
  }
  function me(e5) {
    return he(e5) && "[object RegExp]" === ve(e5);
  }
  function he(e5) {
    return "object" == typeof e5 && null !== e5;
  }
  function je(e5) {
    return he(e5) && "[object Date]" === ve(e5);
  }
  function Ae(e5) {
    return he(e5) && ("[object Error]" === ve(e5) || e5 instanceof Error);
  }
  function we(e5) {
    return "function" == typeof e5;
  }
  function ve(e5) {
    return Object.prototype.toString.call(e5);
  }
  function Oe(e5) {
    return e5 < 10 ? "0" + e5.toString(10) : e5.toString(10);
  }
  function Be() {
    var e5 = /* @__PURE__ */ new Date(), t5 = [Oe(e5.getHours()), Oe(e5.getMinutes()), Oe(e5.getSeconds())].join(":");
    return [e5.getDate(), Se[e5.getMonth()], t5].join(" ");
  }
  function ke(e5, t5) {
    return Object.prototype.hasOwnProperty.call(e5, t5);
  }
  function De(e5, t5) {
    if (!e5) {
      var r5 = new Error("Promise was rejected with a falsy value");
      r5.reason = e5, e5 = r5;
    }
    return t5(e5);
  }
  var e$2, t$3, n$2, r$2, o$3, l$2, s$1, f$1, a$1, T$1, t2, e2, o2, n2, r2, l2, t$1, o$1, n$1, e$1, r$1, c2, u2, i2, t$2, i$1, o$2, u$1, f2, a2, s2, p2, y2, l$1, d, m, h2, j, A, Q, X, Y, ee, te, re, ne, ie, Se, Ee, promisify;
  var init_chunk_D3uu3VYh = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-D3uu3VYh.js"() {
      init_buffer2();
      r$2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
      o$3 = e$2 = {};
      !function() {
        try {
          t$3 = "function" == typeof setTimeout ? setTimeout : i$2;
        } catch (e5) {
          t$3 = i$2;
        }
        try {
          n$2 = "function" == typeof clearTimeout ? clearTimeout : u$2;
        } catch (e5) {
          n$2 = u$2;
        }
      }();
      s$1 = [];
      f$1 = false;
      a$1 = -1;
      o$3.nextTick = function(e5) {
        var t5 = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var n5 = 1; n5 < arguments.length; n5++) t5[n5 - 1] = arguments[n5];
        s$1.push(new m$1(e5, t5)), 1 !== s$1.length || f$1 || c$2(d$1);
      }, m$1.prototype.run = function() {
        (this || r$2).fun.apply(null, (this || r$2).array);
      }, o$3.title = "browser", o$3.browser = true, o$3.env = {}, o$3.argv = [], o$3.version = "", o$3.versions = {}, o$3.on = p$1, o$3.addListener = p$1, o$3.once = p$1, o$3.off = p$1, o$3.removeListener = p$1, o$3.removeAllListeners = p$1, o$3.emit = p$1, o$3.prependListener = p$1, o$3.prependOnceListener = p$1, o$3.listeners = function(e5) {
        return [];
      }, o$3.binding = function(e5) {
        throw new Error("process.binding is not supported");
      }, o$3.cwd = function() {
        return "/";
      }, o$3.chdir = function(e5) {
        throw new Error("process.chdir is not supported");
      }, o$3.umask = function() {
        return 0;
      };
      T$1 = e$2;
      T$1.addListener;
      T$1.argv;
      T$1.binding;
      T$1.browser;
      T$1.chdir;
      T$1.cwd;
      T$1.emit;
      T$1.env;
      T$1.listeners;
      T$1.nextTick;
      T$1.off;
      T$1.on;
      T$1.once;
      T$1.prependListener;
      T$1.prependOnceListener;
      T$1.removeAllListeners;
      T$1.removeListener;
      T$1.title;
      T$1.umask;
      T$1.version;
      T$1.versions;
      t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
      e2 = Object.prototype.toString;
      o2 = function(o5) {
        return !(t2 && o5 && "object" == typeof o5 && Symbol.toStringTag in o5) && "[object Arguments]" === e2.call(o5);
      };
      n2 = function(t5) {
        return !!o2(t5) || null !== t5 && "object" == typeof t5 && "number" == typeof t5.length && t5.length >= 0 && "[object Array]" !== e2.call(t5) && "[object Function]" === e2.call(t5.callee);
      };
      r2 = function() {
        return o2(arguments);
      }();
      o2.isLegacyArguments = n2;
      l2 = r2 ? o2 : n2;
      t$1 = Object.prototype.toString;
      o$1 = Function.prototype.toString;
      n$1 = /^\s*(?:function)?\*/;
      e$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
      r$1 = Object.getPrototypeOf;
      c2 = function() {
        if (!e$1) return false;
        try {
          return Function("return function*() {}")();
        } catch (t5) {
        }
      }();
      u2 = c2 ? r$1(c2) : {};
      i2 = function(c5) {
        return "function" == typeof c5 && (!!n$1.test(o$1.call(c5)) || (e$1 ? r$1(c5) === u2 : "[object GeneratorFunction]" === t$1.call(c5)));
      };
      t$2 = "function" == typeof Object.create ? function(t5, e5) {
        e5 && (t5.super_ = e5, t5.prototype = Object.create(e5.prototype, { constructor: { value: t5, enumerable: false, writable: true, configurable: true } }));
      } : function(t5, e5) {
        if (e5) {
          t5.super_ = e5;
          var o5 = function() {
          };
          o5.prototype = e5.prototype, t5.prototype = new o5(), t5.prototype.constructor = t5;
        }
      };
      i$1 = function(e5) {
        return e5 && "object" == typeof e5 && "function" == typeof e5.copy && "function" == typeof e5.fill && "function" == typeof e5.readUInt8;
      };
      o$2 = {};
      u$1 = i$1;
      f2 = l2;
      a2 = i2;
      s2 = "undefined" != typeof BigInt;
      p2 = "undefined" != typeof Symbol;
      y2 = p2 && void 0 !== Symbol.toStringTag;
      l$1 = "undefined" != typeof Uint8Array;
      d = "undefined" != typeof ArrayBuffer;
      if (l$1 && y2) var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
      m = c$1(Object.prototype.toString);
      h2 = c$1(Number.prototype.valueOf);
      j = c$1(String.prototype.valueOf);
      A = c$1(Boolean.prototype.valueOf);
      if (s2) var w = c$1(BigInt.prototype.valueOf);
      if (p2) var v2 = c$1(Symbol.prototype.valueOf);
      o$2.isArgumentsObject = f2, o$2.isGeneratorFunction = a2, o$2.isPromise = function(e5) {
        return "undefined" != typeof Promise && e5 instanceof Promise || null !== e5 && "object" == typeof e5 && "function" == typeof e5.then && "function" == typeof e5.catch;
      }, o$2.isArrayBufferView = function(e5) {
        return d && ArrayBuffer.isView ? ArrayBuffer.isView(e5) : S(e5) || R(e5);
      }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T.working = "undefined" != typeof Map && T(/* @__PURE__ */ new Map()), o$2.isMap = function(e5) {
        return "undefined" != typeof Map && (T.working ? T(e5) : e5 instanceof Map);
      }, N.working = "undefined" != typeof Set && N(/* @__PURE__ */ new Set()), o$2.isSet = function(e5) {
        return "undefined" != typeof Set && (N.working ? N(e5) : e5 instanceof Set);
      }, W.working = "undefined" != typeof WeakMap && W(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(e5) {
        return "undefined" != typeof WeakMap && (W.working ? W(e5) : e5 instanceof WeakMap);
      }, $.working = "undefined" != typeof WeakSet && $(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(e5) {
        return $(e5);
      }, C.working = "undefined" != typeof ArrayBuffer && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = "undefined" != typeof SharedArrayBuffer && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e5) {
        return "[object AsyncFunction]" === m(e5);
      }, o$2.isMapIterator = function(e5) {
        return "[object Map Iterator]" === m(e5);
      }, o$2.isSetIterator = function(e5) {
        return "[object Set Iterator]" === m(e5);
      }, o$2.isGeneratorObject = function(e5) {
        return "[object Generator]" === m(e5);
      }, o$2.isWebAssemblyCompiledModule = function(e5) {
        return "[object WebAssembly.Module]" === m(e5);
      }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e5) {
        return H(e5) || Z(e5) || q(e5) || K(e5) || L(e5);
      }, o$2.isAnyArrayBuffer = function(e5) {
        return l$1 && (V(e5) || _(e5));
      }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e5) {
        Object.defineProperty(o$2, e5, { enumerable: false, value: function() {
          throw new Error(e5 + " is not supported in userland");
        } });
      });
      Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
      X = {};
      Y = T$1;
      ee = Object.getOwnPropertyDescriptors || function(e5) {
        for (var t5 = Object.keys(e5), r5 = {}, n5 = 0; n5 < t5.length; n5++) r5[t5[n5]] = Object.getOwnPropertyDescriptor(e5, t5[n5]);
        return r5;
      };
      te = /%[sdj%]/g;
      X.format = function(e5) {
        if (!ge(e5)) {
          for (var t5 = [], r5 = 0; r5 < arguments.length; r5++) t5.push(oe(arguments[r5]));
          return t5.join(" ");
        }
        r5 = 1;
        for (var n5 = arguments, i5 = n5.length, o5 = String(e5).replace(te, function(e6) {
          if ("%%" === e6) return "%";
          if (r5 >= i5) return e6;
          switch (e6) {
            case "%s":
              return String(n5[r5++]);
            case "%d":
              return Number(n5[r5++]);
            case "%j":
              try {
                return JSON.stringify(n5[r5++]);
              } catch (e7) {
                return "[Circular]";
              }
            default:
              return e6;
          }
        }), u5 = n5[r5]; r5 < i5; u5 = n5[++r5]) le(u5) || !he(u5) ? o5 += " " + u5 : o5 += " " + oe(u5);
        return o5;
      }, X.deprecate = function(e5, t5) {
        if (void 0 !== Y && true === Y.noDeprecation) return e5;
        if (void 0 === Y) return function() {
          return X.deprecate(e5, t5).apply(this || Q, arguments);
        };
        var r5 = false;
        return function() {
          if (!r5) {
            if (Y.throwDeprecation) throw new Error(t5);
            Y.traceDeprecation ? console.trace(t5) : console.error(t5), r5 = true;
          }
          return e5.apply(this || Q, arguments);
        };
      };
      re = {};
      ne = /^$/;
      if (Y.env.NODE_DEBUG) {
        ie = Y.env.NODE_DEBUG;
        ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
      }
      X.debuglog = function(e5) {
        if (e5 = e5.toUpperCase(), !re[e5]) if (ne.test(e5)) {
          var t5 = Y.pid;
          re[e5] = function() {
            var r5 = X.format.apply(X, arguments);
            console.error("%s %d: %s", e5, t5, r5);
          };
        } else re[e5] = function() {
        };
        return re[e5];
      }, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e5) {
        return null == e5;
      }, X.isNumber = de, X.isString = ge, X.isSymbol = function(e5) {
        return "symbol" == typeof e5;
      }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e5) {
        return null === e5 || "boolean" == typeof e5 || "number" == typeof e5 || "string" == typeof e5 || "symbol" == typeof e5 || void 0 === e5;
      }, X.isBuffer = i$1;
      Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      X.log = function() {
        console.log("%s - %s", Be(), X.format.apply(X, arguments));
      }, X.inherits = t$2, X._extend = function(e5, t5) {
        if (!t5 || !he(t5)) return e5;
        for (var r5 = Object.keys(t5), n5 = r5.length; n5--; ) e5[r5[n5]] = t5[r5[n5]];
        return e5;
      };
      Ee = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
      X.promisify = function(e5) {
        if ("function" != typeof e5) throw new TypeError('The "original" argument must be of type Function');
        if (Ee && e5[Ee]) {
          var t5;
          if ("function" != typeof (t5 = e5[Ee])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty(t5, Ee, { value: t5, enumerable: false, writable: false, configurable: true }), t5;
        }
        function t5() {
          for (var t6, r5, n5 = new Promise(function(e6, n6) {
            t6 = e6, r5 = n6;
          }), i5 = [], o5 = 0; o5 < arguments.length; o5++) i5.push(arguments[o5]);
          i5.push(function(e6, n6) {
            e6 ? r5(e6) : t6(n6);
          });
          try {
            e5.apply(this || Q, i5);
          } catch (e6) {
            r5(e6);
          }
          return n5;
        }
        return Object.setPrototypeOf(t5, Object.getPrototypeOf(e5)), Ee && Object.defineProperty(t5, Ee, { value: t5, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t5, ee(e5));
      }, X.promisify.custom = Ee, X.callbackify = function(e5) {
        if ("function" != typeof e5) throw new TypeError('The "original" argument must be of type Function');
        function t5() {
          for (var t6 = [], r5 = 0; r5 < arguments.length; r5++) t6.push(arguments[r5]);
          var n5 = t6.pop();
          if ("function" != typeof n5) throw new TypeError("The last argument must be of type Function");
          var i5 = this || Q, o5 = function() {
            return n5.apply(i5, arguments);
          };
          e5.apply(this || Q, t6).then(function(e6) {
            Y.nextTick(o5.bind(null, null, e6));
          }, function(e6) {
            Y.nextTick(De.bind(null, e6, o5));
          });
        }
        return Object.setPrototypeOf(t5, Object.getPrototypeOf(e5)), Object.defineProperties(t5, ee(e5)), t5;
      };
      X._extend;
      X.callbackify;
      X.debuglog;
      X.deprecate;
      X.format;
      X.inherits;
      X.inspect;
      X.isArray;
      X.isBoolean;
      X.isBuffer;
      X.isDate;
      X.isError;
      X.isFunction;
      X.isNull;
      X.isNullOrUndefined;
      X.isNumber;
      X.isObject;
      X.isPrimitive;
      X.isRegExp;
      X.isString;
      X.isSymbol;
      X.isUndefined;
      X.log;
      X.promisify;
      X._extend;
      X.callbackify;
      X.debuglog;
      X.deprecate;
      X.format;
      X.inherits;
      X.inspect;
      X.isArray;
      X.isBoolean;
      X.isBuffer;
      X.isDate;
      X.isError;
      X.isFunction;
      X.isNull;
      X.isNullOrUndefined;
      X.isNumber;
      X.isObject;
      X.isPrimitive;
      X.isRegExp;
      X.isString;
      X.isSymbol;
      X.isUndefined;
      X.log;
      promisify = X.promisify;
      X.types;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-CbQqNoLO.js
  var promisify2;
  var init_chunk_CbQqNoLO = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-CbQqNoLO.js"() {
      init_buffer2();
      init_chunk_D3uu3VYh();
      X._extend;
      X.callbackify;
      X.debuglog;
      X.deprecate;
      X.format;
      X.inherits;
      X.inspect;
      X.isArray;
      X.isBoolean;
      X.isBuffer;
      X.isDate;
      X.isError;
      X.isFunction;
      X.isNull;
      X.isNullOrUndefined;
      X.isNumber;
      X.isObject;
      X.isPrimitive;
      X.isRegExp;
      X.isString;
      X.isSymbol;
      X.isUndefined;
      X.log;
      promisify2 = X.promisify;
      X.types;
      X.TextEncoder = globalThis.TextEncoder;
      X.TextDecoder = globalThis.TextDecoder;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-DEMDiNwt.js
  function unimplemented(name2) {
    throw new Error("Node.js process " + name2 + " is not supported by JSPM core outside of Node.js");
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue)
      return;
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length)
      drainQueue();
  }
  function drainQueue() {
    if (draining)
      return;
    var timeout = setTimeout(cleanUpNextTick, 0);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue)
          currentQueue[queueIndex].run();
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i5 = 1; i5 < arguments.length; i5++)
        args[i5 - 1] = arguments[i5];
    }
    queue.push(new Item2(fun, args));
    if (queue.length === 1 && !draining)
      setTimeout(drainQueue, 0);
  }
  function Item2(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  function _linkedBinding(name2) {
    unimplemented("_linkedBinding");
  }
  function dlopen(name2) {
    unimplemented("dlopen");
  }
  function _getActiveRequests() {
    return [];
  }
  function _getActiveHandles() {
    return [];
  }
  function assert(condition, message) {
    if (!condition) throw new Error(message || "assertion error");
  }
  function hasUncaughtExceptionCaptureCallback() {
    return false;
  }
  function uptime2() {
    return _performance2.now() / 1e3;
  }
  function hrtime2(previousTimestamp) {
    var baseNow = Math.floor((Date.now() - _performance2.now()) * 1e-3);
    var clocktime = _performance2.now() * 1e-3;
    var seconds = Math.floor(clocktime) + baseNow;
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += nanoPerSec2;
      }
    }
    return [seconds, nanoseconds];
  }
  function on() {
    return process2;
  }
  function listeners(name2) {
    return [];
  }
  var queue, draining, currentQueue, queueIndex, title, arch2, platform2, env2, argv, execArgv, version2, versions, emitWarning, binding, umask, cwd, chdir, release2, _rawDebug, moduleLoadList, domain, _exiting, config, reallyExit, _kill, cpuUsage, resourceUsage, memoryUsage, kill, exit, openStdin, allowedNodeEnvironmentFlags, features, _fatalExceptions, setUncaughtExceptionCaptureCallback, _tickCallback, _debugProcess, _debugEnd, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, stdout, stderr, stdin, abort, pid, ppid, execPath, debugPort, argv0, _preload_modules, setSourceMapsEnabled, _performance2, nowOffset, nanoPerSec2, _maxListeners, _events, _eventsCount, addListener, once, off, removeListener, removeAllListeners, emit, prependListener, prependOnceListener, process2;
  var init_chunk_DEMDiNwt = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-DEMDiNwt.js"() {
      init_buffer2();
      queue = [];
      draining = false;
      queueIndex = -1;
      Item2.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      arch2 = "x64";
      platform2 = "browser";
      env2 = {
        PATH: "/usr/bin",
        LANG: navigator.language + ".UTF-8",
        PWD: "/",
        HOME: "/home",
        TMP: "/tmp"
      };
      argv = ["/usr/bin/node"];
      execArgv = [];
      version2 = "v16.8.0";
      versions = {};
      emitWarning = function(message, type2) {
        console.warn((type2 ? type2 + ": " : "") + message);
      };
      binding = function(name2) {
        unimplemented("binding");
      };
      umask = function(mask) {
        return 0;
      };
      cwd = function() {
        return "/";
      };
      chdir = function(dir) {
      };
      release2 = {
        name: "node",
        sourceUrl: "",
        headersUrl: "",
        libUrl: ""
      };
      _rawDebug = noop;
      moduleLoadList = [];
      domain = {};
      _exiting = false;
      config = {};
      reallyExit = noop;
      _kill = noop;
      cpuUsage = function() {
        return {};
      };
      resourceUsage = cpuUsage;
      memoryUsage = cpuUsage;
      kill = noop;
      exit = noop;
      openStdin = noop;
      allowedNodeEnvironmentFlags = {};
      features = {
        inspector: false,
        debug: false,
        uv: false,
        ipv6: false,
        tls_alpn: false,
        tls_sni: false,
        tls_ocsp: false,
        tls: false,
        cached_builtins: true
      };
      _fatalExceptions = noop;
      setUncaughtExceptionCaptureCallback = noop;
      _tickCallback = noop;
      _debugProcess = noop;
      _debugEnd = noop;
      _startProfilerIdleNotifier = noop;
      _stopProfilerIdleNotifier = noop;
      stdout = void 0;
      stderr = void 0;
      stdin = void 0;
      abort = noop;
      pid = 2;
      ppid = 1;
      execPath = "/bin/usr/node";
      debugPort = 9229;
      argv0 = "node";
      _preload_modules = [];
      setSourceMapsEnabled = noop;
      _performance2 = {
        now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
        timing: typeof performance !== "undefined" ? performance.timing : void 0
      };
      if (_performance2.now === void 0) {
        nowOffset = Date.now();
        if (_performance2.timing && _performance2.timing.navigationStart) {
          nowOffset = _performance2.timing.navigationStart;
        }
        _performance2.now = () => Date.now() - nowOffset;
      }
      nanoPerSec2 = 1e9;
      hrtime2.bigint = function(time) {
        var diff = hrtime2(time);
        if (typeof BigInt === "undefined") {
          return diff[0] * nanoPerSec2 + diff[1];
        }
        return BigInt(diff[0] * nanoPerSec2) + BigInt(diff[1]);
      };
      _maxListeners = 10;
      _events = {};
      _eventsCount = 0;
      addListener = on;
      once = on;
      off = on;
      removeListener = on;
      removeAllListeners = on;
      emit = noop;
      prependListener = on;
      prependOnceListener = on;
      process2 = {
        version: version2,
        versions,
        arch: arch2,
        platform: platform2,
        release: release2,
        _rawDebug,
        moduleLoadList,
        binding,
        _linkedBinding,
        _events,
        _eventsCount,
        _maxListeners,
        on,
        addListener,
        once,
        off,
        removeListener,
        removeAllListeners,
        emit,
        prependListener,
        prependOnceListener,
        listeners,
        domain,
        _exiting,
        config,
        dlopen,
        uptime: uptime2,
        _getActiveRequests,
        _getActiveHandles,
        reallyExit,
        _kill,
        cpuUsage,
        resourceUsage,
        memoryUsage,
        kill,
        exit,
        openStdin,
        allowedNodeEnvironmentFlags,
        assert,
        features,
        _fatalExceptions,
        setUncaughtExceptionCaptureCallback,
        hasUncaughtExceptionCaptureCallback,
        emitWarning,
        nextTick,
        _tickCallback,
        _debugProcess,
        _debugEnd,
        _startProfilerIdleNotifier,
        _stopProfilerIdleNotifier,
        stdout,
        stdin,
        stderr,
        abort,
        umask,
        chdir,
        cwd,
        env: env2,
        title,
        argv,
        execArgv,
        pid,
        ppid,
        execPath,
        debugPort,
        hrtime: hrtime2,
        argv0,
        _preload_modules,
        setSourceMapsEnabled
      };
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-BsRZ0PEC.js
  function dew4() {
    if (_dewExec4) return exports5;
    _dewExec4 = true;
    exports5 = deprecate2;
    function deprecate2(fn, msg) {
      if (config2("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config2("throwDeprecation")) {
            throw new Error(msg);
          } else if (config2("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this || _global, arguments);
      }
      return deprecated;
    }
    function config2(name2) {
      try {
        if (!_global.localStorage) return false;
      } catch (_3) {
        return false;
      }
      var val = _global.localStorage[name2];
      if (null == val) return false;
      return String(val).toLowerCase() === "true";
    }
    return exports5;
  }
  var exports5, _dewExec4, _global;
  var init_chunk_BsRZ0PEC = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-BsRZ0PEC.js"() {
      init_buffer2();
      exports5 = {};
      _dewExec4 = false;
      _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-CcCWfKp1.js
  function dew$12() {
    if (_dewExec$12) return exports$22;
    _dewExec$12 = true;
    var buffer2 = dew();
    var Buffer3 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      exports$22 = buffer2;
    } else {
      copyProps(buffer2, exports$22);
      exports$22.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
    return exports$22;
  }
  function dew5() {
    if (_dewExec5) return exports$13;
    _dewExec5 = true;
    var Buffer3 = dew$12().Buffer;
    var isEncoding = Buffer3.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports$13.StringDecoder = StringDecoder2;
    function StringDecoder2(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder2.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r5;
      var i5;
      if (this.lastNeed) {
        r5 = this.fillLast(buf);
        if (r5 === void 0) return "";
        i5 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i5 = 0;
      }
      if (i5 < buf.length) return r5 ? r5 + this.text(buf, i5) : this.text(buf, i5);
      return r5 || "";
    };
    StringDecoder2.prototype.end = utf8End;
    StringDecoder2.prototype.text = utf8Text;
    StringDecoder2.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i5) {
      var j3 = buf.length - 1;
      if (j3 < i5) return 0;
      var nb = utf8CheckByte(buf[j3]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j3 < i5 || nb === -2) return 0;
      nb = utf8CheckByte(buf[j3]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j3 < i5 || nb === -2) return 0;
      nb = utf8CheckByte(buf[j3]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p5) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p5 = this.lastTotal - this.lastNeed;
      var r5 = utf8CheckExtraBytes(this, buf);
      if (r5 !== void 0) return r5;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p5, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p5, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i5) {
      var total = utf8CheckIncomplete(this, buf, i5);
      if (!this.lastNeed) return buf.toString("utf8", i5);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i5, end);
    }
    function utf8End(buf) {
      var r5 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r5 + "\uFFFD";
      return r5;
    }
    function utf16Text(buf, i5) {
      if ((buf.length - i5) % 2 === 0) {
        var r5 = buf.toString("utf16le", i5);
        if (r5) {
          var c5 = r5.charCodeAt(r5.length - 1);
          if (c5 >= 55296 && c5 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r5.slice(0, -1);
          }
        }
        return r5;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i5, buf.length - 1);
    }
    function utf16End(buf) {
      var r5 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r5 + this.lastChar.toString("utf16le", 0, end);
      }
      return r5;
    }
    function base64Text(buf, i5) {
      var n5 = (buf.length - i5) % 3;
      if (n5 === 0) return buf.toString("base64", i5);
      this.lastNeed = 3 - n5;
      this.lastTotal = 3;
      if (n5 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i5, buf.length - n5);
    }
    function base64End(buf) {
      var r5 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r5 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r5;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
    return exports$13;
  }
  var exports$22, _dewExec$12, exports$13, _dewExec5, exports6, StringDecoder;
  var init_chunk_CcCWfKp1 = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-CcCWfKp1.js"() {
      init_buffer2();
      init_chunk_DtuTasat();
      exports$22 = {};
      _dewExec$12 = false;
      exports$13 = {};
      _dewExec5 = false;
      exports6 = dew5();
      exports6["StringDecoder"];
      StringDecoder = exports6.StringDecoder;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-b0rmRow7.js
  function dew6() {
    if (_dewExec6) return exports7;
    _dewExec6 = true;
    var process4 = exports7 = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e5) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e5) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e5) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e6) {
          return cachedSetTimeout.call(this || _global2, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e5) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e6) {
          return cachedClearTimeout.call(this || _global2, marker);
        }
      }
    }
    var queue2 = [];
    var draining2 = false;
    var currentQueue2;
    var queueIndex2 = -1;
    function cleanUpNextTick2() {
      if (!draining2 || !currentQueue2) {
        return;
      }
      draining2 = false;
      if (currentQueue2.length) {
        queue2 = currentQueue2.concat(queue2);
      } else {
        queueIndex2 = -1;
      }
      if (queue2.length) {
        drainQueue2();
      }
    }
    function drainQueue2() {
      if (draining2) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick2);
      draining2 = true;
      var len = queue2.length;
      while (len) {
        currentQueue2 = queue2;
        queue2 = [];
        while (++queueIndex2 < len) {
          if (currentQueue2) {
            currentQueue2[queueIndex2].run();
          }
        }
        queueIndex2 = -1;
        len = queue2.length;
      }
      currentQueue2 = null;
      draining2 = false;
      runClearTimeout(timeout);
    }
    process4.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i5 = 1; i5 < arguments.length; i5++) {
          args[i5 - 1] = arguments[i5];
        }
      }
      queue2.push(new Item3(fun, args));
      if (queue2.length === 1 && !draining2) {
        runTimeout(drainQueue2);
      }
    };
    function Item3(fun, array) {
      (this || _global2).fun = fun;
      (this || _global2).array = array;
    }
    Item3.prototype.run = function() {
      (this || _global2).fun.apply(null, (this || _global2).array);
    };
    process4.title = "browser";
    process4.browser = true;
    process4.env = {};
    process4.argv = [];
    process4.version = "";
    process4.versions = {};
    function noop2() {
    }
    process4.on = noop2;
    process4.addListener = noop2;
    process4.once = noop2;
    process4.off = noop2;
    process4.removeListener = noop2;
    process4.removeAllListeners = noop2;
    process4.emit = noop2;
    process4.prependListener = noop2;
    process4.prependOnceListener = noop2;
    process4.listeners = function(name2) {
      return [];
    };
    process4.binding = function(name2) {
      throw new Error("process.binding is not supported");
    };
    process4.cwd = function() {
      return "/";
    };
    process4.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process4.umask = function() {
      return 0;
    };
    return exports7;
  }
  var exports7, _dewExec6, _global2, process3;
  var init_chunk_b0rmRow7 = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-b0rmRow7.js"() {
      init_buffer2();
      exports7 = {};
      _dewExec6 = false;
      _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      process3 = dew6();
      process3.platform = "browser";
      process3.addListener;
      process3.argv;
      process3.binding;
      process3.browser;
      process3.chdir;
      process3.cwd;
      process3.emit;
      process3.env;
      process3.listeners;
      process3.nextTick;
      process3.off;
      process3.on;
      process3.once;
      process3.prependListener;
      process3.prependOnceListener;
      process3.removeAllListeners;
      process3.removeListener;
      process3.title;
      process3.umask;
      process3.version;
      process3.versions;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-DHWh-hmB.js
  function dew$13() {
    if (_dewExec$13) return exports$14;
    _dewExec$13 = true;
    var process$1 = process3;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i5 = 0; i5 <= path2.length; ++i5) {
        if (i5 < path2.length) code = path2.charCodeAt(i5);
        else if (code === 47) break;
        else code = 47;
        if (code === 47) {
          if (lastSlash === i5 - 1 || dots === 1) ;
          else if (lastSlash !== i5 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i5;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i5;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0) res += "/..";
              else res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0) res += "/" + path2.slice(lastSlash + 1, i5);
            else res = path2.slice(lastSlash + 1, i5);
            lastSegmentLength = i5 - lastSlash - 1;
          }
          lastSlash = i5;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve2() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd2;
        for (var i5 = arguments.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
          var path2;
          if (i5 >= 0) path2 = arguments[i5];
          else {
            if (cwd2 === void 0) cwd2 = process$1.cwd();
            path2 = cwd2;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0) return "/" + resolvedPath;
          else return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var isAbsolute = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute);
        if (path2.length === 0 && !isAbsolute) path2 = ".";
        if (path2.length > 0 && trailingSeparator) path2 += "/";
        if (isAbsolute) return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0) return ".";
        var joined;
        for (var i5 = 0; i5 < arguments.length; ++i5) {
          var arg = arguments[i5];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0) joined = arg;
            else joined += "/" + arg;
          }
        }
        if (joined === void 0) return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47) break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i5 = 0;
        for (; i5 <= length; ++i5) {
          if (i5 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i5) === 47) {
                return to.slice(toStart + i5 + 1);
              } else if (i5 === 0) {
                return to.slice(toStart + i5);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i5) === 47) {
                lastCommonSep = i5;
              } else if (i5 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i5);
          var toCode = to.charCodeAt(toStart + i5);
          if (fromCode !== toCode) break;
          else if (fromCode === 47) lastCommonSep = i5;
        }
        var out = "";
        for (i5 = fromStart + lastCommonSep + 1; i5 <= fromEnd; ++i5) {
          if (i5 === fromEnd || from.charCodeAt(i5) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
          }
        }
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47) ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path2) {
        return path2;
      },
      dirname: function dirname(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var code = path2.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i5 = path2.length - 1; i5 >= 1; --i5) {
          code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              end = i5;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path2.slice(0, end);
      },
      basename: function basename(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i5;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i5 = path2.length - 1; i5 >= 0; --i5) {
            var code = path2.charCodeAt(i5);
            if (code === 47) {
              if (!matchedSlash) {
                start = i5 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i5 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i5;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i5 = path2.length - 1; i5 >= 0; --i5) {
            if (path2.charCodeAt(i5) === 47) {
              if (!matchedSlash) {
                start = i5 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i5 + 1;
            }
          }
          if (end === -1) return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i5 = path2.length - 1; i5 >= 0; --i5) {
          var code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i5 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i5;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format3(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse3(path2) {
        assertPath(path2);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path2.length === 0) return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i5 = path2.length - 1;
        var preDotState = 0;
        for (; i5 >= start; --i5) {
          code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i5 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i5;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end);
            else ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    exports$14 = posix;
    return exports$14;
  }
  function i$12(t5) {
    throw new RangeError(r$22[t5]);
  }
  function f$12(t5, o5) {
    const n5 = t5.split("@");
    let r5 = "";
    n5.length > 1 && (r5 = n5[0] + "@", t5 = n5[1]);
    const c5 = function(t6, o6) {
      const n6 = [];
      let e5 = t6.length;
      for (; e5--; ) n6[e5] = o6(t6[e5]);
      return n6;
    }((t5 = t5.replace(e$22, ".")).split("."), o5).join(".");
    return r5 + c5;
  }
  function l$12(t5) {
    const o5 = [];
    let n5 = 0;
    const e5 = t5.length;
    for (; n5 < e5; ) {
      const r5 = t5.charCodeAt(n5++);
      if (r5 >= 55296 && r5 <= 56319 && n5 < e5) {
        const e6 = t5.charCodeAt(n5++);
        56320 == (64512 & e6) ? o5.push(((1023 & r5) << 10) + (1023 & e6) + 65536) : (o5.push(r5), n5--);
      } else o5.push(r5);
    }
    return o5;
  }
  function e$12(e5, n5) {
    return Object.prototype.hasOwnProperty.call(e5, n5);
  }
  function r3() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  function O2(t5, s5, h5) {
    if (t5 && a3.isObject(t5) && t5 instanceof r3) return t5;
    var e5 = new r3();
    return e5.parse(t5, s5, h5), e5;
  }
  function dew7() {
    if (_dewExec7) return exports8;
    _dewExec7 = true;
    var process4 = T$1;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i5 = 0; i5 <= path2.length; ++i5) {
        if (i5 < path2.length) code = path2.charCodeAt(i5);
        else if (code === 47) break;
        else code = 47;
        if (code === 47) {
          if (lastSlash === i5 - 1 || dots === 1) ;
          else if (lastSlash !== i5 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i5;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i5;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0) res += "/..";
              else res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0) res += "/" + path2.slice(lastSlash + 1, i5);
            else res = path2.slice(lastSlash + 1, i5);
            lastSegmentLength = i5 - lastSlash - 1;
          }
          lastSlash = i5;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve2() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd2;
        for (var i5 = arguments.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
          var path2;
          if (i5 >= 0) path2 = arguments[i5];
          else {
            if (cwd2 === void 0) cwd2 = process4.cwd();
            path2 = cwd2;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0) return "/" + resolvedPath;
          else return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var isAbsolute = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute);
        if (path2.length === 0 && !isAbsolute) path2 = ".";
        if (path2.length > 0 && trailingSeparator) path2 += "/";
        if (isAbsolute) return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0) return ".";
        var joined;
        for (var i5 = 0; i5 < arguments.length; ++i5) {
          var arg = arguments[i5];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0) joined = arg;
            else joined += "/" + arg;
          }
        }
        if (joined === void 0) return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47) break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i5 = 0;
        for (; i5 <= length; ++i5) {
          if (i5 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i5) === 47) {
                return to.slice(toStart + i5 + 1);
              } else if (i5 === 0) {
                return to.slice(toStart + i5);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i5) === 47) {
                lastCommonSep = i5;
              } else if (i5 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i5);
          var toCode = to.charCodeAt(toStart + i5);
          if (fromCode !== toCode) break;
          else if (fromCode === 47) lastCommonSep = i5;
        }
        var out = "";
        for (i5 = fromStart + lastCommonSep + 1; i5 <= fromEnd; ++i5) {
          if (i5 === fromEnd || from.charCodeAt(i5) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
          }
        }
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47) ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path2) {
        return path2;
      },
      dirname: function dirname(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var code = path2.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i5 = path2.length - 1; i5 >= 1; --i5) {
          code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              end = i5;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path2.slice(0, end);
      },
      basename: function basename(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i5;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i5 = path2.length - 1; i5 >= 0; --i5) {
            var code = path2.charCodeAt(i5);
            if (code === 47) {
              if (!matchedSlash) {
                start = i5 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i5 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i5;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i5 = path2.length - 1; i5 >= 0; --i5) {
            if (path2.charCodeAt(i5) === 47) {
              if (!matchedSlash) {
                start = i5 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i5 + 1;
            }
          }
          if (end === -1) return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i5 = path2.length - 1; i5 >= 0; --i5) {
          var code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i5 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i5;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format3(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse3(path2) {
        assertPath(path2);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path2.length === 0) return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i5 = path2.length - 1;
        var preDotState = 0;
        for (; i5 >= start; --i5) {
          code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i5 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i5;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end);
            else ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    exports8 = posix;
    return exports8;
  }
  function fileURLToPath$1(path2) {
    if (typeof path2 === "string") path2 = new URL(path2);
    else if (!(path2 instanceof URL)) {
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    }
    if (path2.protocol !== "file:") {
      throw new Deno.errors.InvalidData("invalid url scheme");
    }
    return isWindows$1 ? getPathFromURLWin$1(path2) : getPathFromURLPosix$1(path2);
  }
  function getPathFromURLWin$1(url) {
    const hostname2 = url.hostname;
    let pathname = url.pathname;
    for (let n5 = 0; n5 < pathname.length; n5++) {
      if (pathname[n5] === "%") {
        const third = pathname.codePointAt(n5 + 2) || 32;
        if (pathname[n5 + 1] === "2" && third === 102 || // 2f 2F /
        pathname[n5 + 1] === "5" && third === 99) {
          throw new Deno.errors.InvalidData(
            "must not include encoded \\ or / characters"
          );
        }
      }
    }
    pathname = pathname.replace(forwardSlashRegEx$1, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname2 !== "") {
      return `\\\\${hostname2}${pathname}`;
    } else {
      const letter = pathname.codePointAt(1) | 32;
      const sep = pathname[2];
      if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
      sep !== ":") {
        throw new Deno.errors.InvalidData("file url path must be absolute");
      }
      return pathname.slice(1);
    }
  }
  function getPathFromURLPosix$1(url) {
    if (url.hostname !== "") {
      throw new Deno.errors.InvalidData("invalid file url hostname");
    }
    const pathname = url.pathname;
    for (let n5 = 0; n5 < pathname.length; n5++) {
      if (pathname[n5] === "%") {
        const third = pathname.codePointAt(n5 + 2) || 32;
        if (pathname[n5 + 1] === "2" && third === 102) {
          throw new Deno.errors.InvalidData(
            "must not include encoded / characters"
          );
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFileURL$1(filepath) {
    let resolved = path.resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
      resolved += "/";
    }
    const outURL = new URL("file://");
    if (resolved.includes("%")) resolved = resolved.replace(percentRegEx$1, "%25");
    if (!isWindows$1 && resolved.includes("\\")) {
      resolved = resolved.replace(backslashRegEx$1, "%5C");
    }
    if (resolved.includes("\n")) resolved = resolved.replace(newlineRegEx$1, "%0A");
    if (resolved.includes("\r")) {
      resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
    }
    if (resolved.includes("	")) resolved = resolved.replace(tabRegEx$1, "%09");
    outURL.pathname = resolved;
    return outURL;
  }
  function fileURLToPath(path2) {
    if (typeof path2 === "string") path2 = new URL(path2);
    else if (!(path2 instanceof URL)) {
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    }
    if (path2.protocol !== "file:") {
      throw new Deno.errors.InvalidData("invalid url scheme");
    }
    return isWindows ? getPathFromURLWin(path2) : getPathFromURLPosix(path2);
  }
  function getPathFromURLWin(url) {
    const hostname2 = url.hostname;
    let pathname = url.pathname;
    for (let n5 = 0; n5 < pathname.length; n5++) {
      if (pathname[n5] === "%") {
        const third = pathname.codePointAt(n5 + 2) || 32;
        if (pathname[n5 + 1] === "2" && third === 102 || // 2f 2F /
        pathname[n5 + 1] === "5" && third === 99) {
          throw new Deno.errors.InvalidData(
            "must not include encoded \\ or / characters"
          );
        }
      }
    }
    pathname = pathname.replace(forwardSlashRegEx, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname2 !== "") {
      return `\\\\${hostname2}${pathname}`;
    } else {
      const letter = pathname.codePointAt(1) | 32;
      const sep = pathname[2];
      if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
      sep !== ":") {
        throw new Deno.errors.InvalidData("file url path must be absolute");
      }
      return pathname.slice(1);
    }
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      throw new Deno.errors.InvalidData("invalid file url hostname");
    }
    const pathname = url.pathname;
    for (let n5 = 0; n5 < pathname.length; n5++) {
      if (pathname[n5] === "%") {
        const third = pathname.codePointAt(n5 + 2) || 32;
        if (pathname[n5 + 1] === "2" && third === 102) {
          throw new Deno.errors.InvalidData(
            "must not include encoded / characters"
          );
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFileURL(filepath) {
    let resolved = exports$23.resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports$23.sep) {
      resolved += "/";
    }
    const outURL = new URL("file://");
    if (resolved.includes("%")) resolved = resolved.replace(percentRegEx, "%25");
    if (!isWindows && resolved.includes("\\")) {
      resolved = resolved.replace(backslashRegEx, "%5C");
    }
    if (resolved.includes("\n")) resolved = resolved.replace(newlineRegEx, "%0A");
    if (resolved.includes("\r")) {
      resolved = resolved.replace(carriageReturnRegEx, "%0D");
    }
    if (resolved.includes("	")) resolved = resolved.replace(tabRegEx, "%09");
    outURL.pathname = resolved;
    return outURL;
  }
  var exports$14, _dewExec$13, exports$23, t$12, o$22, n$22, e$22, r$22, c$12, s3, u$12, a$12, d2, h$12, p$12, n$12, r$12, t3, o$12, h3, e3, a3, o3, n3, i3, l3, p3, c3, u3, f3, m2, v3, g2, y3, b2, exports8, _dewExec7, path, processPlatform$1, CHAR_BACKWARD_SLASH$1, CHAR_FORWARD_SLASH$1, CHAR_LOWERCASE_A$1, CHAR_LOWERCASE_Z$1, isWindows$1, forwardSlashRegEx$1, percentRegEx$1, backslashRegEx$1, newlineRegEx$1, carriageReturnRegEx$1, tabRegEx$1, processPlatform, CHAR_BACKWARD_SLASH, CHAR_FORWARD_SLASH, CHAR_LOWERCASE_A, CHAR_LOWERCASE_Z, isWindows, forwardSlashRegEx, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx;
  var init_chunk_DHWh_hmB = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-DHWh-hmB.js"() {
      init_buffer2();
      init_chunk_D3uu3VYh();
      init_chunk_b0rmRow7();
      exports$14 = {};
      _dewExec$13 = false;
      exports$23 = dew$13();
      t$12 = 2147483647;
      o$22 = /^xn--/;
      n$22 = /[^\0-\x7E]/;
      e$22 = /[\x2E\u3002\uFF0E\uFF61]/g;
      r$22 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
      c$12 = Math.floor;
      s3 = String.fromCharCode;
      u$12 = function(t5, o5) {
        return t5 + 22 + 75 * (t5 < 26) - ((0 != o5) << 5);
      };
      a$12 = function(t5, o5, n5) {
        let e5 = 0;
        for (t5 = n5 ? c$12(t5 / 700) : t5 >> 1, t5 += c$12(t5 / o5); t5 > 455; e5 += 36) t5 = c$12(t5 / 35);
        return c$12(e5 + 36 * t5 / (t5 + 38));
      };
      d2 = function(o5) {
        const n5 = [], e5 = o5.length;
        let r5 = 0, s5 = 128, f5 = 72, l5 = o5.lastIndexOf("-");
        l5 < 0 && (l5 = 0);
        for (let t5 = 0; t5 < l5; ++t5) o5.charCodeAt(t5) >= 128 && i$12("not-basic"), n5.push(o5.charCodeAt(t5));
        for (let d4 = l5 > 0 ? l5 + 1 : 0; d4 < e5; ) {
          let l6 = r5;
          for (let n6 = 1, s6 = 36; ; s6 += 36) {
            d4 >= e5 && i$12("invalid-input");
            const l7 = (u5 = o5.charCodeAt(d4++)) - 48 < 10 ? u5 - 22 : u5 - 65 < 26 ? u5 - 65 : u5 - 97 < 26 ? u5 - 97 : 36;
            (l7 >= 36 || l7 > c$12((t$12 - r5) / n6)) && i$12("overflow"), r5 += l7 * n6;
            const a5 = s6 <= f5 ? 1 : s6 >= f5 + 26 ? 26 : s6 - f5;
            if (l7 < a5) break;
            const h6 = 36 - a5;
            n6 > c$12(t$12 / h6) && i$12("overflow"), n6 *= h6;
          }
          const h5 = n5.length + 1;
          f5 = a$12(r5 - l6, h5, 0 == l6), c$12(r5 / h5) > t$12 - s5 && i$12("overflow"), s5 += c$12(r5 / h5), r5 %= h5, n5.splice(r5++, 0, s5);
        }
        var u5;
        return String.fromCodePoint(...n5);
      };
      h$12 = function(o5) {
        const n5 = [];
        let e5 = (o5 = l$12(o5)).length, r5 = 128, f5 = 0, d4 = 72;
        for (const t5 of o5) t5 < 128 && n5.push(s3(t5));
        let h5 = n5.length, p5 = h5;
        for (h5 && n5.push("-"); p5 < e5; ) {
          let e6 = t$12;
          for (const t5 of o5) t5 >= r5 && t5 < e6 && (e6 = t5);
          const l5 = p5 + 1;
          e6 - r5 > c$12((t$12 - f5) / l5) && i$12("overflow"), f5 += (e6 - r5) * l5, r5 = e6;
          for (const e7 of o5) if (e7 < r5 && ++f5 > t$12 && i$12("overflow"), e7 == r5) {
            let t5 = f5;
            for (let o6 = 36; ; o6 += 36) {
              const e8 = o6 <= d4 ? 1 : o6 >= d4 + 26 ? 26 : o6 - d4;
              if (t5 < e8) break;
              const r6 = t5 - e8, i5 = 36 - e8;
              n5.push(s3(u$12(e8 + r6 % i5, 0))), t5 = c$12(r6 / i5);
            }
            n5.push(s3(u$12(t5, 0))), d4 = a$12(f5, l5, p5 == h5), f5 = 0, ++p5;
          }
          ++f5, ++r5;
        }
        return n5.join("");
      };
      p$12 = { version: "2.1.0", ucs2: { decode: l$12, encode: (t5) => String.fromCodePoint(...t5) }, decode: d2, encode: h$12, toASCII: function(t5) {
        return f$12(t5, function(t6) {
          return n$22.test(t6) ? "xn--" + h$12(t6) : t6;
        });
      }, toUnicode: function(t5) {
        return f$12(t5, function(t6) {
          return o$22.test(t6) ? d2(t6.slice(4).toLowerCase()) : t6;
        });
      } };
      n$12 = function(n5, r5, t5, o5) {
        r5 = r5 || "&", t5 = t5 || "=";
        var a5 = {};
        if ("string" != typeof n5 || 0 === n5.length) return a5;
        var u5 = /\+/g;
        n5 = n5.split(r5);
        var c5 = 1e3;
        o5 && "number" == typeof o5.maxKeys && (c5 = o5.maxKeys);
        var i5 = n5.length;
        c5 > 0 && i5 > c5 && (i5 = c5);
        for (var s5 = 0; s5 < i5; ++s5) {
          var p5, f5, d4, y5, m4 = n5[s5].replace(u5, "%20"), l5 = m4.indexOf(t5);
          l5 >= 0 ? (p5 = m4.substr(0, l5), f5 = m4.substr(l5 + 1)) : (p5 = m4, f5 = ""), d4 = decodeURIComponent(p5), y5 = decodeURIComponent(f5), e$12(a5, d4) ? Array.isArray(a5[d4]) ? a5[d4].push(y5) : a5[d4] = [a5[d4], y5] : a5[d4] = y5;
        }
        return a5;
      };
      r$12 = function(e5) {
        switch (typeof e5) {
          case "string":
            return e5;
          case "boolean":
            return e5 ? "true" : "false";
          case "number":
            return isFinite(e5) ? e5 : "";
          default:
            return "";
        }
      };
      t3 = function(e5, n5, t5, o5) {
        return n5 = n5 || "&", t5 = t5 || "=", null === e5 && (e5 = void 0), "object" == typeof e5 ? Object.keys(e5).map(function(o6) {
          var a5 = encodeURIComponent(r$12(o6)) + t5;
          return Array.isArray(e5[o6]) ? e5[o6].map(function(e6) {
            return a5 + encodeURIComponent(r$12(e6));
          }).join(n5) : a5 + encodeURIComponent(r$12(e5[o6]));
        }).join(n5) : o5 ? encodeURIComponent(r$12(o5)) + t5 + encodeURIComponent(r$12(e5)) : "";
      };
      o$12 = {};
      o$12.decode = o$12.parse = n$12, o$12.encode = o$12.stringify = t3;
      o$12.decode;
      o$12.encode;
      o$12.parse;
      o$12.stringify;
      h3 = {};
      e3 = p$12;
      a3 = { isString: function(t5) {
        return "string" == typeof t5;
      }, isObject: function(t5) {
        return "object" == typeof t5 && null !== t5;
      }, isNull: function(t5) {
        return null === t5;
      }, isNullOrUndefined: function(t5) {
        return null == t5;
      } };
      h3.parse = O2, h3.resolve = function(t5, s5) {
        return O2(t5, false, true).resolve(s5);
      }, h3.resolveObject = function(t5, s5) {
        return t5 ? O2(t5, false, true).resolveObject(s5) : s5;
      }, h3.format = function(t5) {
        a3.isString(t5) && (t5 = O2(t5));
        return t5 instanceof r3 ? t5.format() : r3.prototype.format.call(t5);
      }, h3.Url = r3;
      o3 = /^([a-z0-9.+-]+:)/i;
      n3 = /:[0-9]*$/;
      i3 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
      l3 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
      p3 = ["'"].concat(l3);
      c3 = ["%", "/", "?", ";", "#"].concat(p3);
      u3 = ["/", "?", "#"];
      f3 = /^[+a-z0-9A-Z_-]{0,63}$/;
      m2 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
      v3 = { javascript: true, "javascript:": true };
      g2 = { javascript: true, "javascript:": true };
      y3 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
      b2 = o$12;
      r3.prototype.parse = function(t5, s5, h5) {
        if (!a3.isString(t5)) throw new TypeError("Parameter 'url' must be a string, not " + typeof t5);
        var r5 = t5.indexOf("?"), n5 = -1 !== r5 && r5 < t5.indexOf("#") ? "?" : "#", l5 = t5.split(n5);
        l5[0] = l5[0].replace(/\\/g, "/");
        var O4 = t5 = l5.join(n5);
        if (O4 = O4.trim(), !h5 && 1 === t5.split("#").length) {
          var d4 = i3.exec(O4);
          if (d4) return this.path = O4, this.href = O4, this.pathname = d4[1], d4[2] ? (this.search = d4[2], this.query = s5 ? b2.parse(this.search.substr(1)) : this.search.substr(1)) : s5 && (this.search = "", this.query = {}), this;
        }
        var j3 = o3.exec(O4);
        if (j3) {
          var q2 = (j3 = j3[0]).toLowerCase();
          this.protocol = q2, O4 = O4.substr(j3.length);
        }
        if (h5 || j3 || O4.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var x3 = "//" === O4.substr(0, 2);
          !x3 || j3 && g2[j3] || (O4 = O4.substr(2), this.slashes = true);
        }
        if (!g2[j3] && (x3 || j3 && !y3[j3])) {
          for (var A3, C3, I3 = -1, w3 = 0; w3 < u3.length; w3++) {
            -1 !== (N3 = O4.indexOf(u3[w3])) && (-1 === I3 || N3 < I3) && (I3 = N3);
          }
          -1 !== (C3 = -1 === I3 ? O4.lastIndexOf("@") : O4.lastIndexOf("@", I3)) && (A3 = O4.slice(0, C3), O4 = O4.slice(C3 + 1), this.auth = decodeURIComponent(A3)), I3 = -1;
          for (w3 = 0; w3 < c3.length; w3++) {
            var N3;
            -1 !== (N3 = O4.indexOf(c3[w3])) && (-1 === I3 || N3 < I3) && (I3 = N3);
          }
          -1 === I3 && (I3 = O4.length), this.host = O4.slice(0, I3), O4 = O4.slice(I3), this.parseHost(), this.hostname = this.hostname || "";
          var U3 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
          if (!U3) for (var k3 = this.hostname.split(/\./), S3 = (w3 = 0, k3.length); w3 < S3; w3++) {
            var R3 = k3[w3];
            if (R3 && !R3.match(f3)) {
              for (var $2 = "", z3 = 0, H2 = R3.length; z3 < H2; z3++) R3.charCodeAt(z3) > 127 ? $2 += "x" : $2 += R3[z3];
              if (!$2.match(f3)) {
                var L3 = k3.slice(0, w3), Z2 = k3.slice(w3 + 1), _3 = R3.match(m2);
                _3 && (L3.push(_3[1]), Z2.unshift(_3[2])), Z2.length && (O4 = "/" + Z2.join(".") + O4), this.hostname = L3.join(".");
                break;
              }
            }
          }
          this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U3 || (this.hostname = e3.toASCII(this.hostname));
          var E3 = this.port ? ":" + this.port : "", P3 = this.hostname || "";
          this.host = P3 + E3, this.href += this.host, U3 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O4[0] && (O4 = "/" + O4));
        }
        if (!v3[q2]) for (w3 = 0, S3 = p3.length; w3 < S3; w3++) {
          var T3 = p3[w3];
          if (-1 !== O4.indexOf(T3)) {
            var B3 = encodeURIComponent(T3);
            B3 === T3 && (B3 = escape(T3)), O4 = O4.split(T3).join(B3);
          }
        }
        var D3 = O4.indexOf("#");
        -1 !== D3 && (this.hash = O4.substr(D3), O4 = O4.slice(0, D3));
        var F3 = O4.indexOf("?");
        if (-1 !== F3 ? (this.search = O4.substr(F3), this.query = O4.substr(F3 + 1), s5 && (this.query = b2.parse(this.query)), O4 = O4.slice(0, F3)) : s5 && (this.search = "", this.query = {}), O4 && (this.pathname = O4), y3[q2] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          E3 = this.pathname || "";
          var G2 = this.search || "";
          this.path = E3 + G2;
        }
        return this.href = this.format(), this;
      }, r3.prototype.format = function() {
        var t5 = this.auth || "";
        t5 && (t5 = (t5 = encodeURIComponent(t5)).replace(/%3A/i, ":"), t5 += "@");
        var s5 = this.protocol || "", h5 = this.pathname || "", e5 = this.hash || "", r5 = false, o5 = "";
        this.host ? r5 = t5 + this.host : this.hostname && (r5 = t5 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r5 += ":" + this.port)), this.query && a3.isObject(this.query) && Object.keys(this.query).length && (o5 = b2.stringify(this.query));
        var n5 = this.search || o5 && "?" + o5 || "";
        return s5 && ":" !== s5.substr(-1) && (s5 += ":"), this.slashes || (!s5 || y3[s5]) && false !== r5 ? (r5 = "//" + (r5 || ""), h5 && "/" !== h5.charAt(0) && (h5 = "/" + h5)) : r5 || (r5 = ""), e5 && "#" !== e5.charAt(0) && (e5 = "#" + e5), n5 && "?" !== n5.charAt(0) && (n5 = "?" + n5), s5 + r5 + (h5 = h5.replace(/[?#]/g, function(t6) {
          return encodeURIComponent(t6);
        })) + (n5 = n5.replace("#", "%23")) + e5;
      }, r3.prototype.resolve = function(t5) {
        return this.resolveObject(O2(t5, false, true)).format();
      }, r3.prototype.resolveObject = function(t5) {
        if (a3.isString(t5)) {
          var s5 = new r3();
          s5.parse(t5, false, true), t5 = s5;
        }
        for (var h5 = new r3(), e5 = Object.keys(this), o5 = 0; o5 < e5.length; o5++) {
          var n5 = e5[o5];
          h5[n5] = this[n5];
        }
        if (h5.hash = t5.hash, "" === t5.href) return h5.href = h5.format(), h5;
        if (t5.slashes && !t5.protocol) {
          for (var i5 = Object.keys(t5), l5 = 0; l5 < i5.length; l5++) {
            var p5 = i5[l5];
            "protocol" !== p5 && (h5[p5] = t5[p5]);
          }
          return y3[h5.protocol] && h5.hostname && !h5.pathname && (h5.path = h5.pathname = "/"), h5.href = h5.format(), h5;
        }
        if (t5.protocol && t5.protocol !== h5.protocol) {
          if (!y3[t5.protocol]) {
            for (var c5 = Object.keys(t5), u5 = 0; u5 < c5.length; u5++) {
              var f5 = c5[u5];
              h5[f5] = t5[f5];
            }
            return h5.href = h5.format(), h5;
          }
          if (h5.protocol = t5.protocol, t5.host || g2[t5.protocol]) h5.pathname = t5.pathname;
          else {
            for (var m4 = (t5.pathname || "").split("/"); m4.length && !(t5.host = m4.shift()); ) ;
            t5.host || (t5.host = ""), t5.hostname || (t5.hostname = ""), "" !== m4[0] && m4.unshift(""), m4.length < 2 && m4.unshift(""), h5.pathname = m4.join("/");
          }
          if (h5.search = t5.search, h5.query = t5.query, h5.host = t5.host || "", h5.auth = t5.auth, h5.hostname = t5.hostname || t5.host, h5.port = t5.port, h5.pathname || h5.search) {
            var v5 = h5.pathname || "", b4 = h5.search || "";
            h5.path = v5 + b4;
          }
          return h5.slashes = h5.slashes || t5.slashes, h5.href = h5.format(), h5;
        }
        var O4 = h5.pathname && "/" === h5.pathname.charAt(0), d4 = t5.host || t5.pathname && "/" === t5.pathname.charAt(0), j3 = d4 || O4 || h5.host && t5.pathname, q2 = j3, x3 = h5.pathname && h5.pathname.split("/") || [], A3 = (m4 = t5.pathname && t5.pathname.split("/") || [], h5.protocol && !y3[h5.protocol]);
        if (A3 && (h5.hostname = "", h5.port = null, h5.host && ("" === x3[0] ? x3[0] = h5.host : x3.unshift(h5.host)), h5.host = "", t5.protocol && (t5.hostname = null, t5.port = null, t5.host && ("" === m4[0] ? m4[0] = t5.host : m4.unshift(t5.host)), t5.host = null), j3 = j3 && ("" === m4[0] || "" === x3[0])), d4) h5.host = t5.host || "" === t5.host ? t5.host : h5.host, h5.hostname = t5.hostname || "" === t5.hostname ? t5.hostname : h5.hostname, h5.search = t5.search, h5.query = t5.query, x3 = m4;
        else if (m4.length) x3 || (x3 = []), x3.pop(), x3 = x3.concat(m4), h5.search = t5.search, h5.query = t5.query;
        else if (!a3.isNullOrUndefined(t5.search)) {
          if (A3) h5.hostname = h5.host = x3.shift(), (U3 = !!(h5.host && h5.host.indexOf("@") > 0) && h5.host.split("@")) && (h5.auth = U3.shift(), h5.host = h5.hostname = U3.shift());
          return h5.search = t5.search, h5.query = t5.query, a3.isNull(h5.pathname) && a3.isNull(h5.search) || (h5.path = (h5.pathname ? h5.pathname : "") + (h5.search ? h5.search : "")), h5.href = h5.format(), h5;
        }
        if (!x3.length) return h5.pathname = null, h5.search ? h5.path = "/" + h5.search : h5.path = null, h5.href = h5.format(), h5;
        for (var C3 = x3.slice(-1)[0], I3 = (h5.host || t5.host || x3.length > 1) && ("." === C3 || ".." === C3) || "" === C3, w3 = 0, N3 = x3.length; N3 >= 0; N3--) "." === (C3 = x3[N3]) ? x3.splice(N3, 1) : ".." === C3 ? (x3.splice(N3, 1), w3++) : w3 && (x3.splice(N3, 1), w3--);
        if (!j3 && !q2) for (; w3--; w3) x3.unshift("..");
        !j3 || "" === x3[0] || x3[0] && "/" === x3[0].charAt(0) || x3.unshift(""), I3 && "/" !== x3.join("/").substr(-1) && x3.push("");
        var U3, k3 = "" === x3[0] || x3[0] && "/" === x3[0].charAt(0);
        A3 && (h5.hostname = h5.host = k3 ? "" : x3.length ? x3.shift() : "", (U3 = !!(h5.host && h5.host.indexOf("@") > 0) && h5.host.split("@")) && (h5.auth = U3.shift(), h5.host = h5.hostname = U3.shift()));
        return (j3 = j3 || h5.host && x3.length) && !k3 && x3.unshift(""), x3.length ? h5.pathname = x3.join("/") : (h5.pathname = null, h5.path = null), a3.isNull(h5.pathname) && a3.isNull(h5.search) || (h5.path = (h5.pathname ? h5.pathname : "") + (h5.search ? h5.search : "")), h5.auth = t5.auth || h5.auth, h5.slashes = h5.slashes || t5.slashes, h5.href = h5.format(), h5;
      }, r3.prototype.parseHost = function() {
        var t5 = this.host, s5 = n3.exec(t5);
        s5 && (":" !== (s5 = s5[0]) && (this.port = s5.substr(1)), t5 = t5.substr(0, t5.length - s5.length)), t5 && (this.hostname = t5);
      };
      h3.Url;
      h3.format;
      h3.resolve;
      h3.resolveObject;
      exports8 = {};
      _dewExec7 = false;
      path = dew7();
      processPlatform$1 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
      h3.URL = typeof URL !== "undefined" ? URL : null;
      h3.pathToFileURL = pathToFileURL$1;
      h3.fileURLToPath = fileURLToPath$1;
      h3.Url;
      h3.format;
      h3.resolve;
      h3.resolveObject;
      h3.URL;
      CHAR_BACKWARD_SLASH$1 = 92;
      CHAR_FORWARD_SLASH$1 = 47;
      CHAR_LOWERCASE_A$1 = 97;
      CHAR_LOWERCASE_Z$1 = 122;
      isWindows$1 = processPlatform$1 === "win32";
      forwardSlashRegEx$1 = /\//g;
      percentRegEx$1 = /%/g;
      backslashRegEx$1 = /\\/g;
      newlineRegEx$1 = /\n/g;
      carriageReturnRegEx$1 = /\r/g;
      tabRegEx$1 = /\t/g;
      processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
      h3.URL = typeof URL !== "undefined" ? URL : null;
      h3.pathToFileURL = pathToFileURL;
      h3.fileURLToPath = fileURLToPath;
      h3.Url;
      h3.format;
      h3.resolve;
      h3.resolveObject;
      h3.parse;
      h3.URL;
      CHAR_BACKWARD_SLASH = 92;
      CHAR_FORWARD_SLASH = 47;
      CHAR_LOWERCASE_A = 97;
      CHAR_LOWERCASE_Z = 122;
      isWindows = processPlatform === "win32";
      forwardSlashRegEx = /\//g;
      percentRegEx = /%/g;
      backslashRegEx = /\\/g;
      newlineRegEx = /\n/g;
      carriageReturnRegEx = /\r/g;
      tabRegEx = /\t/g;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/http.js
  var http_exports = {};
  __export(http_exports, {
    Agent: () => Agent,
    ClientRequest: () => ClientRequest,
    IncomingMessage: () => IncomingMessage,
    METHODS: () => METHODS,
    STATUS_CODES: () => STATUS_CODES,
    default: () => exports9,
    get: () => get,
    globalAgent: () => globalAgent,
    request: () => request
  });
  function dew$k() {
    if (_dewExec$k) return exports$l;
    _dewExec$k = true;
    exports$l.fetch = isFunction2(_global$5.fetch) && isFunction2(_global$5.ReadableStream);
    exports$l.writableStream = isFunction2(_global$5.WritableStream);
    exports$l.abortController = isFunction2(_global$5.AbortController);
    var xhr;
    function getXHR() {
      if (xhr !== void 0) return xhr;
      if (_global$5.XMLHttpRequest) {
        xhr = new _global$5.XMLHttpRequest();
        try {
          xhr.open("GET", _global$5.XDomainRequest ? "/" : "https://example.com");
        } catch (e5) {
          xhr = null;
        }
      } else {
        xhr = null;
      }
      return xhr;
    }
    function checkTypeSupport(type2) {
      var xhr2 = getXHR();
      if (!xhr2) return false;
      try {
        xhr2.responseType = type2;
        return xhr2.responseType === type2;
      } catch (e5) {
      }
      return false;
    }
    exports$l.arraybuffer = exports$l.fetch || checkTypeSupport("arraybuffer");
    exports$l.msstream = !exports$l.fetch && checkTypeSupport("ms-stream");
    exports$l.mozchunkedarraybuffer = !exports$l.fetch && checkTypeSupport("moz-chunked-arraybuffer");
    exports$l.overrideMimeType = exports$l.fetch || (getXHR() ? isFunction2(getXHR().overrideMimeType) : false);
    function isFunction2(value) {
      return typeof value === "function";
    }
    xhr = null;
    return exports$l;
  }
  function dew$j() {
    if (_dewExec$j) return exports$k;
    _dewExec$j = true;
    exports$k = y.EventEmitter;
    return exports$k;
  }
  function dew$i() {
    if (_dewExec$i) return exports$j;
    _dewExec$i = true;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        var source = null != arguments[i5] ? arguments[i5] : {};
        i5 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = dew(), Buffer3 = _require.Buffer;
    var _require2 = X, inspect2 = _require2.inspect;
    var custom = inspect2 && inspect2.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer3.prototype.copy.call(src, target, offset);
    }
    exports$j = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v5) {
          var entry = {
            data: v5,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v5) {
          var entry = {
            data: v5,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s5) {
          if (this.length === 0) return "";
          var p5 = this.head;
          var ret = "" + p5.data;
          while (p5 = p5.next) ret += s5 + p5.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n5) {
          if (this.length === 0) return Buffer3.alloc(0);
          var ret = Buffer3.allocUnsafe(n5 >>> 0);
          var p5 = this.head;
          var i5 = 0;
          while (p5) {
            copyBuffer(p5.data, ret, i5);
            i5 += p5.data.length;
            p5 = p5.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n5, hasStrings) {
          var ret;
          if (n5 < this.head.data.length) {
            ret = this.head.data.slice(0, n5);
            this.head.data = this.head.data.slice(n5);
          } else if (n5 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n5) : this._getBuffer(n5);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n5) {
          var p5 = this.head;
          var c5 = 1;
          var ret = p5.data;
          n5 -= ret.length;
          while (p5 = p5.next) {
            var str = p5.data;
            var nb = n5 > str.length ? str.length : n5;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n5);
            n5 -= nb;
            if (n5 === 0) {
              if (nb === str.length) {
                ++c5;
                if (p5.next) this.head = p5.next;
                else this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = str.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n5) {
          var ret = Buffer3.allocUnsafe(n5);
          var p5 = this.head;
          var c5 = 1;
          p5.data.copy(ret);
          n5 -= p5.data.length;
          while (p5 = p5.next) {
            var buf = p5.data;
            var nb = n5 > buf.length ? buf.length : n5;
            buf.copy(ret, ret.length - n5, 0, nb);
            n5 -= nb;
            if (n5 === 0) {
              if (nb === buf.length) {
                ++c5;
                if (p5.next) this.head = p5.next;
                else this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = buf.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_3, options) {
          return inspect2(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
    return exports$j;
  }
  function dew$h() {
    if (_dewExec$h) return exports$i;
    _dewExec$h = true;
    var process$1 = process2;
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process$1.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process$1.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process$1.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    exports$i = {
      destroy,
      undestroy,
      errorOrDestroy
    };
    return exports$i;
  }
  function dew$g() {
    if (_dewExec$g) return exports$h;
    _dewExec$g = true;
    const codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i5) => String(i5));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(0, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + value + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name2, " argument")) {
        msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type2 = includes(name2, ".") ? "property" : "argument";
        msg = `The "${name2}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    exports$h.codes = codes;
    return exports$h;
  }
  function dew$f() {
    if (_dewExec$f) return exports$g;
    _dewExec$f = true;
    var ERR_INVALID_OPT_VALUE = dew$g().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name2 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name2, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    exports$g = {
      getHighWaterMark
    };
    return exports$g;
  }
  function dew$e() {
    if (_dewExec$e) return exports$f;
    _dewExec$e = true;
    var process$1 = process2;
    exports$f = Writable2;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex2;
    Writable2.WritableState = WritableState;
    var internalUtil = {
      deprecate: dew4()
    };
    var Stream2 = dew$j();
    var Buffer3 = dew().Buffer;
    var OurUint8Array = (typeof _global$4 !== "undefined" ? _global$4 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = dew$h();
    var _require = dew$f(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = dew$g().codes, ERR_INVALID_ARG_TYPE2 = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    dew3()(Writable2, Stream2);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || dew$d();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_3) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable2) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable2(options) {
      Duplex2 = Duplex2 || dew$d();
      var isDuplex = this instanceof Duplex2;
      if (!isDuplex && !realHasInstance.call(Writable2, this)) return new Writable2(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process$1.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer3.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer3.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process$1.nextTick(cb, er);
        process$1.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished2 = needFinish(state) || stream.destroyed;
        if (!finished2 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process$1.nextTick(afterWrite, stream, state, finished2, cb);
        } else {
          afterWrite(stream, state, finished2, cb);
        }
      }
    }
    function afterWrite(stream, state, finished2, cb) {
      if (!finished2) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l5 = state.bufferedRequestCount;
        var buffer2 = new Array(l5);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process$1.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process$1.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    return exports$f;
  }
  function dew$d() {
    if (_dewExec$d) return exports$e;
    _dewExec$d = true;
    var process$1 = process2;
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    exports$e = Duplex2;
    var Readable2 = dew$9();
    var Writable2 = dew$e();
    dew3()(Duplex2, Readable2);
    {
      var keys = objectKeys(Writable2.prototype);
      for (var v5 = 0; v5 < keys.length; v5++) {
        var method = keys[v5];
        if (!Duplex2.prototype[method]) Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    function Duplex2(options) {
      if (!(this instanceof Duplex2)) return new Duplex2(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process$1.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    return exports$e;
  }
  function dew$c() {
    if (_dewExec$c) return exports$d;
    _dewExec$c = true;
    var ERR_STREAM_PREMATURE_CLOSE = dew$g().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once3(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once3(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    exports$d = eos;
    return exports$d;
  }
  function dew$b() {
    if (_dewExec$b) return exports$c;
    _dewExec$b = true;
    var process$1 = process2;
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished2 = dew$c();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult2(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve2 = iter[kLastResolve];
      if (resolve2 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve2(createIterResult2(data, false));
        }
      }
    }
    function onReadable(iter) {
      process$1.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve2, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve2(createIterResult2(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve2, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult2(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve2, reject) {
            process$1.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve2(createIterResult2(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult2(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve2, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve2(createIterResult2(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve2, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult2(data, false));
          } else {
            iterator[kLastResolve] = resolve2;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished2(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve2 = iterator[kLastResolve];
        if (resolve2 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult2(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    exports$c = createReadableStreamAsyncIterator;
    return exports$c;
  }
  function dew$a() {
    if (_dewExec$a) return exports$b;
    _dewExec$a = true;
    exports$b = function() {
      throw new Error("Readable.from is not available in the browser");
    };
    return exports$b;
  }
  function dew$9() {
    if (_dewExec$9) return exports$a;
    _dewExec$9 = true;
    var process$1 = process2;
    exports$a = Readable2;
    var Duplex2;
    Readable2.ReadableState = ReadableState;
    y.EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type2) {
      return emitter.listeners(type2).length;
    };
    var Stream2 = dew$j();
    var Buffer3 = dew().Buffer;
    var OurUint8Array = (typeof _global$3 !== "undefined" ? _global$3 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = X;
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = dew$i();
    var destroyImpl = dew$h();
    var _require = dew$f(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = dew$g().codes, ERR_INVALID_ARG_TYPE2 = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder2;
    var createReadableStreamAsyncIterator;
    var from;
    dew3()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener2(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || dew$d();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder2) StringDecoder2 = exports6.StringDecoder;
        this.decoder = new StringDecoder2(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex2 = Duplex2 || dew$d();
      if (!(this instanceof Readable2)) return new Readable2(options);
      var isDuplex = this instanceof Duplex2;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder2) StringDecoder2 = exports6.StringDecoder;
      var decoder = new StringDecoder2(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p5 = this._readableState.buffer.head;
      var content = "";
      while (p5 !== null) {
        content += decoder.write(p5.data);
        p5 = p5.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n5) {
      if (n5 >= MAX_HWM) {
        n5 = MAX_HWM;
      } else {
        n5--;
        n5 |= n5 >>> 1;
        n5 |= n5 >>> 2;
        n5 |= n5 >>> 4;
        n5 |= n5 >>> 8;
        n5 |= n5 >>> 16;
        n5++;
      }
      return n5;
    }
    function howMuchToRead(n5, state) {
      if (n5 <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n5 !== n5) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n5 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n5);
      if (n5 <= state.length) return n5;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n5) {
      debug("read", n5);
      n5 = parseInt(n5, 10);
      var state = this._readableState;
      var nOrig = n5;
      if (n5 !== 0) state.emittedReadable = false;
      if (n5 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n5 = howMuchToRead(n5, state);
      if (n5 === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n5 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n5 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n5 > 0) ret = fromList(n5, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n5 = 0;
      } else {
        state.length -= n5;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n5 && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process$1.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process$1.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n5) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process$1.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i5 = 0; i5 < len; i5++) dests[i5].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process$1.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process$1.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i5 in stream) {
        if (this[i5] === void 0 && typeof stream[i5] === "function") {
          this[i5] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i5);
        }
      }
      for (var n5 = 0; n5 < kProxyEvents.length; n5++) {
        stream.on(kProxyEvents[n5], this.emit.bind(this, kProxyEvents[n5]));
      }
      this._read = function(n6) {
        debug("wrapped _read", n6);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = dew$b();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState.length;
      }
    });
    function fromList(n5, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n5 || n5 >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n5, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process$1.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from === void 0) {
          from = dew$a();
        }
        return from(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x3) {
      for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
        if (xs[i5] === x3) return i5;
      }
      return -1;
    }
    return exports$a;
  }
  function dew$8() {
    if (_dewExec$8) return exports$9;
    _dewExec$8 = true;
    exports$9 = Transform2;
    var _require$codes = dew$g().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex2 = dew$d();
    dew3()(Transform2, Duplex2);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2)) return new Transform2(options);
      Duplex2.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex2.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n5) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex2.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
    return exports$9;
  }
  function dew$7() {
    if (_dewExec$7) return exports$8;
    _dewExec$7 = true;
    exports$8 = PassThrough2;
    var Transform2 = dew$8();
    dew3()(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2)) return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    return exports$8;
  }
  function dew$6() {
    if (_dewExec$6) return exports$7;
    _dewExec$6 = true;
    var eos;
    function once3(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = dew$g().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once3(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = dew$c();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop2;
      if (typeof streams[streams.length - 1] !== "function") return noop2;
      return streams.pop();
    }
    function pipeline2() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i5) {
        var reading = i5 < streams.length - 1;
        var writing = i5 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    exports$7 = pipeline2;
    return exports$7;
  }
  function dew$5() {
    if (_dewExec$5) return exports$6;
    _dewExec$5 = true;
    exports$6 = exports$6 = dew$9();
    exports$6.Stream = exports$6;
    exports$6.Readable = exports$6;
    exports$6.Writable = dew$e();
    exports$6.Duplex = dew$d();
    exports$6.Transform = dew$8();
    exports$6.PassThrough = dew$7();
    exports$6.finished = dew$c();
    exports$6.pipeline = dew$6();
    return exports$6;
  }
  function dew$4() {
    if (_dewExec$4) return exports$5;
    _dewExec$4 = true;
    var Buffer3 = dew().Buffer;
    var process$1 = process2;
    var capability = dew$k();
    var inherits2 = dew3();
    var stream = dew$5();
    var rStates = exports$5.readyStates = {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    };
    var IncomingMessage3 = exports$5.IncomingMessage = function(xhr, response, mode, resetTimers) {
      var self2 = this || _global$2;
      stream.Readable.call(self2);
      self2._mode = mode;
      self2.headers = {};
      self2.rawHeaders = [];
      self2.trailers = {};
      self2.rawTrailers = [];
      self2.on("end", function() {
        process$1.nextTick(function() {
          self2.emit("close");
        });
      });
      if (mode === "fetch") {
        let read = function() {
          reader.read().then(function(result) {
            if (self2._destroyed) return;
            resetTimers(result.done);
            if (result.done) {
              self2.push(null);
              return;
            }
            self2.push(Buffer3.from(result.value));
            read();
          }).catch(function(err) {
            resetTimers(true);
            if (!self2._destroyed) self2.emit("error", err);
          });
        };
        self2._fetchResponse = response;
        self2.url = response.url;
        self2.statusCode = response.status;
        self2.statusMessage = response.statusText;
        response.headers.forEach(function(header, key) {
          self2.headers[key.toLowerCase()] = header;
          self2.rawHeaders.push(key, header);
        });
        if (capability.writableStream) {
          var writable = new WritableStream({
            write: function(chunk) {
              resetTimers(false);
              return new Promise(function(resolve2, reject) {
                if (self2._destroyed) {
                  reject();
                } else if (self2.push(Buffer3.from(chunk))) {
                  resolve2();
                } else {
                  self2._resumeFetch = resolve2;
                }
              });
            },
            close: function() {
              resetTimers(true);
              if (!self2._destroyed) self2.push(null);
            },
            abort: function(err) {
              resetTimers(true);
              if (!self2._destroyed) self2.emit("error", err);
            }
          });
          try {
            response.body.pipeTo(writable).catch(function(err) {
              resetTimers(true);
              if (!self2._destroyed) self2.emit("error", err);
            });
            return;
          } catch (e5) {
          }
        }
        var reader = response.body.getReader();
        read();
      } else {
        self2._xhr = xhr;
        self2._pos = 0;
        self2.url = xhr.responseURL;
        self2.statusCode = xhr.status;
        self2.statusMessage = xhr.statusText;
        var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
        headers.forEach(function(header) {
          var matches = header.match(/^([^:]+):\s*(.*)/);
          if (matches) {
            var key = matches[1].toLowerCase();
            if (key === "set-cookie") {
              if (self2.headers[key] === void 0) {
                self2.headers[key] = [];
              }
              self2.headers[key].push(matches[2]);
            } else if (self2.headers[key] !== void 0) {
              self2.headers[key] += ", " + matches[2];
            } else {
              self2.headers[key] = matches[2];
            }
            self2.rawHeaders.push(matches[1], matches[2]);
          }
        });
        self2._charset = "x-user-defined";
        if (!capability.overrideMimeType) {
          var mimeType = self2.rawHeaders["mime-type"];
          if (mimeType) {
            var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
            if (charsetMatch) {
              self2._charset = charsetMatch[1].toLowerCase();
            }
          }
          if (!self2._charset) self2._charset = "utf-8";
        }
      }
    };
    inherits2(IncomingMessage3, stream.Readable);
    IncomingMessage3.prototype._read = function() {
      var self2 = this || _global$2;
      var resolve2 = self2._resumeFetch;
      if (resolve2) {
        self2._resumeFetch = null;
        resolve2();
      }
    };
    IncomingMessage3.prototype._onXHRProgress = function(resetTimers) {
      var self2 = this || _global$2;
      var xhr = self2._xhr;
      var response = null;
      switch (self2._mode) {
        case "text":
          response = xhr.responseText;
          if (response.length > self2._pos) {
            var newData = response.substr(self2._pos);
            if (self2._charset === "x-user-defined") {
              var buffer2 = Buffer3.alloc(newData.length);
              for (var i5 = 0; i5 < newData.length; i5++) buffer2[i5] = newData.charCodeAt(i5) & 255;
              self2.push(buffer2);
            } else {
              self2.push(newData, self2._charset);
            }
            self2._pos = response.length;
          }
          break;
        case "arraybuffer":
          if (xhr.readyState !== rStates.DONE || !xhr.response) break;
          response = xhr.response;
          self2.push(Buffer3.from(new Uint8Array(response)));
          break;
        case "moz-chunked-arraybuffer":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING || !response) break;
          self2.push(Buffer3.from(new Uint8Array(response)));
          break;
        case "ms-stream":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING) break;
          var reader = new _global$2.MSStreamReader();
          reader.onprogress = function() {
            if (reader.result.byteLength > self2._pos) {
              self2.push(Buffer3.from(new Uint8Array(reader.result.slice(self2._pos))));
              self2._pos = reader.result.byteLength;
            }
          };
          reader.onload = function() {
            resetTimers(true);
            self2.push(null);
          };
          reader.readAsArrayBuffer(response);
          break;
      }
      if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
        resetTimers(true);
        self2.push(null);
      }
    };
    return exports$5;
  }
  function dew$3() {
    if (_dewExec$3) return exports$4;
    _dewExec$3 = true;
    var Buffer3 = dew().Buffer;
    var process$1 = process2;
    var capability = dew$k();
    var inherits2 = dew3();
    var response = dew$4();
    var stream = dew$5();
    var IncomingMessage3 = response.IncomingMessage;
    var rStates = response.readyStates;
    function decideMode(preferBinary, useFetch) {
      if (capability.fetch && useFetch) {
        return "fetch";
      } else if (capability.mozchunkedarraybuffer) {
        return "moz-chunked-arraybuffer";
      } else if (capability.msstream) {
        return "ms-stream";
      } else if (capability.arraybuffer && preferBinary) {
        return "arraybuffer";
      } else {
        return "text";
      }
    }
    var ClientRequest3 = exports$4 = function(opts) {
      var self2 = this || _global$1;
      stream.Writable.call(self2);
      self2._opts = opts;
      self2._body = [];
      self2._headers = {};
      if (opts.auth) self2.setHeader("Authorization", "Basic " + Buffer3.from(opts.auth).toString("base64"));
      Object.keys(opts.headers).forEach(function(name2) {
        self2.setHeader(name2, opts.headers[name2]);
      });
      var preferBinary;
      var useFetch = true;
      if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
        useFetch = false;
        preferBinary = true;
      } else if (opts.mode === "prefer-streaming") {
        preferBinary = false;
      } else if (opts.mode === "allow-wrong-content-type") {
        preferBinary = !capability.overrideMimeType;
      } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
        preferBinary = true;
      } else {
        throw new Error("Invalid value for opts.mode");
      }
      self2._mode = decideMode(preferBinary, useFetch);
      self2._fetchTimer = null;
      self2._socketTimeout = null;
      self2._socketTimer = null;
      self2.on("finish", function() {
        self2._onFinish();
      });
    };
    inherits2(ClientRequest3, stream.Writable);
    ClientRequest3.prototype.setHeader = function(name2, value) {
      var self2 = this || _global$1;
      var lowerName = name2.toLowerCase();
      if (unsafeHeaders.indexOf(lowerName) !== -1) return;
      self2._headers[lowerName] = {
        name: name2,
        value
      };
    };
    ClientRequest3.prototype.getHeader = function(name2) {
      var header = (this || _global$1)._headers[name2.toLowerCase()];
      if (header) return header.value;
      return null;
    };
    ClientRequest3.prototype.removeHeader = function(name2) {
      var self2 = this || _global$1;
      delete self2._headers[name2.toLowerCase()];
    };
    ClientRequest3.prototype._onFinish = function() {
      var self2 = this || _global$1;
      if (self2._destroyed) return;
      var opts = self2._opts;
      if ("timeout" in opts && opts.timeout !== 0) {
        self2.setTimeout(opts.timeout);
      }
      var headersObj = self2._headers;
      var body = null;
      if (opts.method !== "GET" && opts.method !== "HEAD") {
        body = new Blob(self2._body, {
          type: (headersObj["content-type"] || {}).value || ""
        });
      }
      var headersList = [];
      Object.keys(headersObj).forEach(function(keyName) {
        var name2 = headersObj[keyName].name;
        var value = headersObj[keyName].value;
        if (Array.isArray(value)) {
          value.forEach(function(v5) {
            headersList.push([name2, v5]);
          });
        } else {
          headersList.push([name2, value]);
        }
      });
      if (self2._mode === "fetch") {
        var signal = null;
        if (capability.abortController) {
          var controller = new AbortController();
          signal = controller.signal;
          self2._fetchAbortController = controller;
          if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
            self2._fetchTimer = _global$1.setTimeout(function() {
              self2.emit("requestTimeout");
              if (self2._fetchAbortController) self2._fetchAbortController.abort();
            }, opts.requestTimeout);
          }
        }
        _global$1.fetch(self2._opts.url, {
          method: self2._opts.method,
          headers: headersList,
          body: body || void 0,
          mode: "cors",
          credentials: opts.withCredentials ? "include" : "same-origin",
          signal
        }).then(function(response2) {
          self2._fetchResponse = response2;
          self2._resetTimers(false);
          self2._connect();
        }, function(reason) {
          self2._resetTimers(true);
          if (!self2._destroyed) self2.emit("error", reason);
        });
      } else {
        var xhr = self2._xhr = new _global$1.XMLHttpRequest();
        try {
          xhr.open(self2._opts.method, self2._opts.url, true);
        } catch (err) {
          process$1.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
        if ("responseType" in xhr) xhr.responseType = self2._mode;
        if ("withCredentials" in xhr) xhr.withCredentials = !!opts.withCredentials;
        if (self2._mode === "text" && "overrideMimeType" in xhr) xhr.overrideMimeType("text/plain; charset=x-user-defined");
        if ("requestTimeout" in opts) {
          xhr.timeout = opts.requestTimeout;
          xhr.ontimeout = function() {
            self2.emit("requestTimeout");
          };
        }
        headersList.forEach(function(header) {
          xhr.setRequestHeader(header[0], header[1]);
        });
        self2._response = null;
        xhr.onreadystatechange = function() {
          switch (xhr.readyState) {
            case rStates.LOADING:
            case rStates.DONE:
              self2._onXHRProgress();
              break;
          }
        };
        if (self2._mode === "moz-chunked-arraybuffer") {
          xhr.onprogress = function() {
            self2._onXHRProgress();
          };
        }
        xhr.onerror = function() {
          if (self2._destroyed) return;
          self2._resetTimers(true);
          self2.emit("error", new Error("XHR error"));
        };
        try {
          xhr.send(body);
        } catch (err) {
          process$1.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
      }
    };
    function statusValid(xhr) {
      try {
        var status = xhr.status;
        return status !== null && status !== 0;
      } catch (e5) {
        return false;
      }
    }
    ClientRequest3.prototype._onXHRProgress = function() {
      var self2 = this || _global$1;
      self2._resetTimers(false);
      if (!statusValid(self2._xhr) || self2._destroyed) return;
      if (!self2._response) self2._connect();
      self2._response._onXHRProgress(self2._resetTimers.bind(self2));
    };
    ClientRequest3.prototype._connect = function() {
      var self2 = this || _global$1;
      if (self2._destroyed) return;
      self2._response = new IncomingMessage3(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2));
      self2._response.on("error", function(err) {
        self2.emit("error", err);
      });
      self2.emit("response", self2._response);
    };
    ClientRequest3.prototype._write = function(chunk, encoding, cb) {
      var self2 = this || _global$1;
      self2._body.push(chunk);
      cb();
    };
    ClientRequest3.prototype._resetTimers = function(done) {
      var self2 = this || _global$1;
      _global$1.clearTimeout(self2._socketTimer);
      self2._socketTimer = null;
      if (done) {
        _global$1.clearTimeout(self2._fetchTimer);
        self2._fetchTimer = null;
      } else if (self2._socketTimeout) {
        self2._socketTimer = _global$1.setTimeout(function() {
          self2.emit("timeout");
        }, self2._socketTimeout);
      }
    };
    ClientRequest3.prototype.abort = ClientRequest3.prototype.destroy = function(err) {
      var self2 = this || _global$1;
      self2._destroyed = true;
      self2._resetTimers(true);
      if (self2._response) self2._response._destroyed = true;
      if (self2._xhr) self2._xhr.abort();
      else if (self2._fetchAbortController) self2._fetchAbortController.abort();
      if (err) self2.emit("error", err);
    };
    ClientRequest3.prototype.end = function(data, encoding, cb) {
      var self2 = this || _global$1;
      if (typeof data === "function") {
        cb = data;
        data = void 0;
      }
      stream.Writable.prototype.end.call(self2, data, encoding, cb);
    };
    ClientRequest3.prototype.setTimeout = function(timeout, cb) {
      var self2 = this || _global$1;
      if (cb) self2.once("timeout", cb);
      self2._socketTimeout = timeout;
      self2._resetTimers(false);
    };
    ClientRequest3.prototype.flushHeaders = function() {
    };
    ClientRequest3.prototype.setNoDelay = function() {
    };
    ClientRequest3.prototype.setSocketKeepAlive = function() {
    };
    var unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
    return exports$4;
  }
  function dew$22() {
    if (_dewExec$22) return exports$3;
    _dewExec$22 = true;
    exports$3 = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i5 = 0; i5 < arguments.length; i5++) {
        var source = arguments[i5];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
    return exports$3;
  }
  function dew$14() {
    if (_dewExec$14) return exports$24;
    _dewExec$14 = true;
    exports$24 = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    return exports$24;
  }
  function dew8() {
    if (_dewExec8) return exports$15;
    _dewExec8 = true;
    var ClientRequest3 = dew$3();
    var response = dew$4();
    var extend = dew$22();
    var statusCodes = dew$14();
    var url = h3;
    var http = exports$15;
    http.request = function(opts, cb) {
      if (typeof opts === "string") opts = url.parse(opts);
      else opts = extend(opts);
      var defaultProtocol = _global3.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
      var protocol = opts.protocol || defaultProtocol;
      var host = opts.hostname || opts.host;
      var port = opts.port;
      var path2 = opts.path || "/";
      if (host && host.indexOf(":") !== -1) host = "[" + host + "]";
      opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path2;
      opts.method = (opts.method || "GET").toUpperCase();
      opts.headers = opts.headers || {};
      var req = new ClientRequest3(opts);
      if (cb) req.on("response", cb);
      return req;
    };
    http.get = function get3(opts, cb) {
      var req = http.request(opts, cb);
      req.end();
      return req;
    };
    http.ClientRequest = ClientRequest3;
    http.IncomingMessage = response.IncomingMessage;
    http.Agent = function() {
    };
    http.Agent.defaultMaxSockets = 4;
    http.globalAgent = new http.Agent();
    http.STATUS_CODES = statusCodes;
    http.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
    return exports$15;
  }
  var exports$l, _dewExec$k, _global$5, exports$k, _dewExec$j, exports$j, _dewExec$i, exports$i, _dewExec$h, exports$h, _dewExec$g, exports$g, _dewExec$f, exports$f, _dewExec$e, _global$4, exports$e, _dewExec$d, exports$d, _dewExec$c, exports$c, _dewExec$b, exports$b, _dewExec$a, exports$a, _dewExec$9, _global$3, exports$9, _dewExec$8, exports$8, _dewExec$7, exports$7, _dewExec$6, exports$6, _dewExec$5, exports$5, _dewExec$4, _global$2, exports$4, _dewExec$3, _global$1, exports$3, _dewExec$22, exports$24, _dewExec$14, exports$15, _dewExec8, _global3, exports9, Agent, ClientRequest, IncomingMessage, METHODS, STATUS_CODES, get, globalAgent, request;
  var init_http = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/http.js"() {
      init_buffer2();
      init_chunk_CkFCi_G1();
      init_chunk_DtDiafJB();
      init_chunk_tHuMsdT0();
      init_chunk_DtuTasat();
      init_chunk_CbQqNoLO();
      init_chunk_D3uu3VYh();
      init_chunk_DEMDiNwt();
      init_chunk_BsRZ0PEC();
      init_chunk_CcCWfKp1();
      init_chunk_DHWh_hmB();
      init_chunk_b0rmRow7();
      exports$l = {};
      _dewExec$k = false;
      _global$5 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$k = {};
      _dewExec$j = false;
      exports$j = {};
      _dewExec$i = false;
      exports$i = {};
      _dewExec$h = false;
      exports$h = {};
      _dewExec$g = false;
      exports$g = {};
      _dewExec$f = false;
      exports$f = {};
      _dewExec$e = false;
      _global$4 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$e = {};
      _dewExec$d = false;
      exports$d = {};
      _dewExec$c = false;
      exports$c = {};
      _dewExec$b = false;
      exports$b = {};
      _dewExec$a = false;
      exports$a = {};
      _dewExec$9 = false;
      _global$3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$9 = {};
      _dewExec$8 = false;
      exports$8 = {};
      _dewExec$7 = false;
      exports$7 = {};
      _dewExec$6 = false;
      exports$6 = {};
      _dewExec$5 = false;
      exports$5 = {};
      _dewExec$4 = false;
      _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$4 = {};
      _dewExec$3 = false;
      _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$3 = {};
      _dewExec$22 = false;
      exports$24 = {};
      _dewExec$14 = false;
      exports$15 = {};
      _dewExec8 = false;
      _global3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports9 = dew8();
      Agent = exports9.Agent;
      ClientRequest = exports9.ClientRequest;
      IncomingMessage = exports9.IncomingMessage;
      METHODS = exports9.METHODS;
      STATUS_CODES = exports9.STATUS_CODES;
      get = exports9.get;
      globalAgent = exports9.globalAgent;
      request = exports9.request;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-B738Er4n.js
  function u$22(r5) {
    var t5 = r5.length;
    if (t5 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var e5 = r5.indexOf("=");
    return -1 === e5 && (e5 = t5), [e5, e5 === t5 ? 0 : 4 - e5 % 4];
  }
  function c$13(r5, e5, n5) {
    for (var o5, a5, h5 = [], u5 = e5; u5 < n5; u5 += 3) o5 = (r5[u5] << 16 & 16711680) + (r5[u5 + 1] << 8 & 65280) + (255 & r5[u5 + 2]), h5.push(t$13[(a5 = o5) >> 18 & 63] + t$13[a5 >> 12 & 63] + t$13[a5 >> 6 & 63] + t$13[63 & a5]);
    return h5.join("");
  }
  function f$2(t5) {
    if (t5 > 2147483647) throw new RangeError('The value "' + t5 + '" is invalid for option "size"');
    var r5 = new Uint8Array(t5);
    return Object.setPrototypeOf(r5, u$1$1.prototype), r5;
  }
  function u$1$1(t5, r5, e5) {
    if ("number" == typeof t5) {
      if ("string" == typeof r5) throw new TypeError('The "string" argument must be of type string. Received type number');
      return a$2(t5);
    }
    return s$12(t5, r5, e5);
  }
  function s$12(t5, r5, e5) {
    if ("string" == typeof t5) return function(t6, r6) {
      "string" == typeof r6 && "" !== r6 || (r6 = "utf8");
      if (!u$1$1.isEncoding(r6)) throw new TypeError("Unknown encoding: " + r6);
      var e6 = 0 | y4(t6, r6), n6 = f$2(e6), i6 = n6.write(t6, r6);
      i6 !== e6 && (n6 = n6.slice(0, i6));
      return n6;
    }(t5, r5);
    if (ArrayBuffer.isView(t5)) return p4(t5);
    if (null == t5) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t5);
    if (F2(t5, ArrayBuffer) || t5 && F2(t5.buffer, ArrayBuffer)) return c$1$1(t5, r5, e5);
    if ("undefined" != typeof SharedArrayBuffer && (F2(t5, SharedArrayBuffer) || t5 && F2(t5.buffer, SharedArrayBuffer))) return c$1$1(t5, r5, e5);
    if ("number" == typeof t5) throw new TypeError('The "value" argument must not be of type number. Received type number');
    var n5 = t5.valueOf && t5.valueOf();
    if (null != n5 && n5 !== t5) return u$1$1.from(n5, r5, e5);
    var i5 = function(t6) {
      if (u$1$1.isBuffer(t6)) {
        var r6 = 0 | l$13(t6.length), e6 = f$2(r6);
        return 0 === e6.length || t6.copy(e6, 0, 0, r6), e6;
      }
      if (void 0 !== t6.length) return "number" != typeof t6.length || N2(t6.length) ? f$2(0) : p4(t6);
      if ("Buffer" === t6.type && Array.isArray(t6.data)) return p4(t6.data);
    }(t5);
    if (i5) return i5;
    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t5[Symbol.toPrimitive]) return u$1$1.from(t5[Symbol.toPrimitive]("string"), r5, e5);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t5);
  }
  function h$1$1(t5) {
    if ("number" != typeof t5) throw new TypeError('"size" argument must be of type number');
    if (t5 < 0) throw new RangeError('The value "' + t5 + '" is invalid for option "size"');
  }
  function a$2(t5) {
    return h$1$1(t5), f$2(t5 < 0 ? 0 : 0 | l$13(t5));
  }
  function p4(t5) {
    for (var r5 = t5.length < 0 ? 0 : 0 | l$13(t5.length), e5 = f$2(r5), n5 = 0; n5 < r5; n5 += 1) e5[n5] = 255 & t5[n5];
    return e5;
  }
  function c$1$1(t5, r5, e5) {
    if (r5 < 0 || t5.byteLength < r5) throw new RangeError('"offset" is outside of buffer bounds');
    if (t5.byteLength < r5 + (e5 || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var n5;
    return n5 = void 0 === r5 && void 0 === e5 ? new Uint8Array(t5) : void 0 === e5 ? new Uint8Array(t5, r5) : new Uint8Array(t5, r5, e5), Object.setPrototypeOf(n5, u$1$1.prototype), n5;
  }
  function l$13(t5) {
    if (t5 >= 2147483647) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
    return 0 | t5;
  }
  function y4(t5, r5) {
    if (u$1$1.isBuffer(t5)) return t5.length;
    if (ArrayBuffer.isView(t5) || F2(t5, ArrayBuffer)) return t5.byteLength;
    if ("string" != typeof t5) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t5);
    var e5 = t5.length, n5 = arguments.length > 2 && true === arguments[2];
    if (!n5 && 0 === e5) return 0;
    for (var i5 = false; ; ) switch (r5) {
      case "ascii":
      case "latin1":
      case "binary":
        return e5;
      case "utf8":
      case "utf-8":
        return _2(t5).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * e5;
      case "hex":
        return e5 >>> 1;
      case "base64":
        return z2(t5).length;
      default:
        if (i5) return n5 ? -1 : _2(t5).length;
        r5 = ("" + r5).toLowerCase(), i5 = true;
    }
  }
  function g3(t5, r5, e5) {
    var n5 = false;
    if ((void 0 === r5 || r5 < 0) && (r5 = 0), r5 > this.length) return "";
    if ((void 0 === e5 || e5 > this.length) && (e5 = this.length), e5 <= 0) return "";
    if ((e5 >>>= 0) <= (r5 >>>= 0)) return "";
    for (t5 || (t5 = "utf8"); ; ) switch (t5) {
      case "hex":
        return O3(this, r5, e5);
      case "utf8":
      case "utf-8":
        return I2(this, r5, e5);
      case "ascii":
        return S2(this, r5, e5);
      case "latin1":
      case "binary":
        return R2(this, r5, e5);
      case "base64":
        return T2(this, r5, e5);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return L2(this, r5, e5);
      default:
        if (n5) throw new TypeError("Unknown encoding: " + t5);
        t5 = (t5 + "").toLowerCase(), n5 = true;
    }
  }
  function w2(t5, r5, e5) {
    var n5 = t5[r5];
    t5[r5] = t5[e5], t5[e5] = n5;
  }
  function d3(t5, r5, e5, n5, i5) {
    if (0 === t5.length) return -1;
    if ("string" == typeof e5 ? (n5 = e5, e5 = 0) : e5 > 2147483647 ? e5 = 2147483647 : e5 < -2147483648 && (e5 = -2147483648), N2(e5 = +e5) && (e5 = i5 ? 0 : t5.length - 1), e5 < 0 && (e5 = t5.length + e5), e5 >= t5.length) {
      if (i5) return -1;
      e5 = t5.length - 1;
    } else if (e5 < 0) {
      if (!i5) return -1;
      e5 = 0;
    }
    if ("string" == typeof r5 && (r5 = u$1$1.from(r5, n5)), u$1$1.isBuffer(r5)) return 0 === r5.length ? -1 : v4(t5, r5, e5, n5, i5);
    if ("number" == typeof r5) return r5 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i5 ? Uint8Array.prototype.indexOf.call(t5, r5, e5) : Uint8Array.prototype.lastIndexOf.call(t5, r5, e5) : v4(t5, [r5], e5, n5, i5);
    throw new TypeError("val must be string, number or Buffer");
  }
  function v4(t5, r5, e5, n5, i5) {
    var o5, f5 = 1, u5 = t5.length, s5 = r5.length;
    if (void 0 !== n5 && ("ucs2" === (n5 = String(n5).toLowerCase()) || "ucs-2" === n5 || "utf16le" === n5 || "utf-16le" === n5)) {
      if (t5.length < 2 || r5.length < 2) return -1;
      f5 = 2, u5 /= 2, s5 /= 2, e5 /= 2;
    }
    function h5(t6, r6) {
      return 1 === f5 ? t6[r6] : t6.readUInt16BE(r6 * f5);
    }
    if (i5) {
      var a5 = -1;
      for (o5 = e5; o5 < u5; o5++) if (h5(t5, o5) === h5(r5, -1 === a5 ? 0 : o5 - a5)) {
        if (-1 === a5 && (a5 = o5), o5 - a5 + 1 === s5) return a5 * f5;
      } else -1 !== a5 && (o5 -= o5 - a5), a5 = -1;
    } else for (e5 + s5 > u5 && (e5 = u5 - s5), o5 = e5; o5 >= 0; o5--) {
      for (var p5 = true, c5 = 0; c5 < s5; c5++) if (h5(t5, o5 + c5) !== h5(r5, c5)) {
        p5 = false;
        break;
      }
      if (p5) return o5;
    }
    return -1;
  }
  function b3(t5, r5, e5, n5) {
    e5 = Number(e5) || 0;
    var i5 = t5.length - e5;
    n5 ? (n5 = Number(n5)) > i5 && (n5 = i5) : n5 = i5;
    var o5 = r5.length;
    n5 > o5 / 2 && (n5 = o5 / 2);
    for (var f5 = 0; f5 < n5; ++f5) {
      var u5 = parseInt(r5.substr(2 * f5, 2), 16);
      if (N2(u5)) return f5;
      t5[e5 + f5] = u5;
    }
    return f5;
  }
  function m3(t5, r5, e5, n5) {
    return D2(_2(r5, t5.length - e5), t5, e5, n5);
  }
  function E2(t5, r5, e5, n5) {
    return D2(function(t6) {
      for (var r6 = [], e6 = 0; e6 < t6.length; ++e6) r6.push(255 & t6.charCodeAt(e6));
      return r6;
    }(r5), t5, e5, n5);
  }
  function B2(t5, r5, e5, n5) {
    return E2(t5, r5, e5, n5);
  }
  function A2(t5, r5, e5, n5) {
    return D2(z2(r5), t5, e5, n5);
  }
  function U2(t5, r5, e5, n5) {
    return D2(function(t6, r6) {
      for (var e6, n6, i5, o5 = [], f5 = 0; f5 < t6.length && !((r6 -= 2) < 0); ++f5) e6 = t6.charCodeAt(f5), n6 = e6 >> 8, i5 = e6 % 256, o5.push(i5), o5.push(n6);
      return o5;
    }(r5, t5.length - e5), t5, e5, n5);
  }
  function T2(t5, r5, e5) {
    return 0 === r5 && e5 === t5.length ? n$1$1.fromByteArray(t5) : n$1$1.fromByteArray(t5.slice(r5, e5));
  }
  function I2(t5, r5, e5) {
    e5 = Math.min(t5.length, e5);
    for (var n5 = [], i5 = r5; i5 < e5; ) {
      var o5, f5, u5, s5, h5 = t5[i5], a5 = null, p5 = h5 > 239 ? 4 : h5 > 223 ? 3 : h5 > 191 ? 2 : 1;
      if (i5 + p5 <= e5) switch (p5) {
        case 1:
          h5 < 128 && (a5 = h5);
          break;
        case 2:
          128 == (192 & (o5 = t5[i5 + 1])) && (s5 = (31 & h5) << 6 | 63 & o5) > 127 && (a5 = s5);
          break;
        case 3:
          o5 = t5[i5 + 1], f5 = t5[i5 + 2], 128 == (192 & o5) && 128 == (192 & f5) && (s5 = (15 & h5) << 12 | (63 & o5) << 6 | 63 & f5) > 2047 && (s5 < 55296 || s5 > 57343) && (a5 = s5);
          break;
        case 4:
          o5 = t5[i5 + 1], f5 = t5[i5 + 2], u5 = t5[i5 + 3], 128 == (192 & o5) && 128 == (192 & f5) && 128 == (192 & u5) && (s5 = (15 & h5) << 18 | (63 & o5) << 12 | (63 & f5) << 6 | 63 & u5) > 65535 && s5 < 1114112 && (a5 = s5);
      }
      null === a5 ? (a5 = 65533, p5 = 1) : a5 > 65535 && (a5 -= 65536, n5.push(a5 >>> 10 & 1023 | 55296), a5 = 56320 | 1023 & a5), n5.push(a5), i5 += p5;
    }
    return function(t6) {
      var r6 = t6.length;
      if (r6 <= 4096) return String.fromCharCode.apply(String, t6);
      var e6 = "", n6 = 0;
      for (; n6 < r6; ) e6 += String.fromCharCode.apply(String, t6.slice(n6, n6 += 4096));
      return e6;
    }(n5);
  }
  function S2(t5, r5, e5) {
    var n5 = "";
    e5 = Math.min(t5.length, e5);
    for (var i5 = r5; i5 < e5; ++i5) n5 += String.fromCharCode(127 & t5[i5]);
    return n5;
  }
  function R2(t5, r5, e5) {
    var n5 = "";
    e5 = Math.min(t5.length, e5);
    for (var i5 = r5; i5 < e5; ++i5) n5 += String.fromCharCode(t5[i5]);
    return n5;
  }
  function O3(t5, r5, e5) {
    var n5 = t5.length;
    (!r5 || r5 < 0) && (r5 = 0), (!e5 || e5 < 0 || e5 > n5) && (e5 = n5);
    for (var i5 = "", o5 = r5; o5 < e5; ++o5) i5 += Y2[t5[o5]];
    return i5;
  }
  function L2(t5, r5, e5) {
    for (var n5 = t5.slice(r5, e5), i5 = "", o5 = 0; o5 < n5.length; o5 += 2) i5 += String.fromCharCode(n5[o5] + 256 * n5[o5 + 1]);
    return i5;
  }
  function x2(t5, r5, e5) {
    if (t5 % 1 != 0 || t5 < 0) throw new RangeError("offset is not uint");
    if (t5 + r5 > e5) throw new RangeError("Trying to access beyond buffer length");
  }
  function C2(t5, r5, e5, n5, i5, o5) {
    if (!u$1$1.isBuffer(t5)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r5 > i5 || r5 < o5) throw new RangeError('"value" argument is out of bounds');
    if (e5 + n5 > t5.length) throw new RangeError("Index out of range");
  }
  function P2(t5, r5, e5, n5, i5, o5) {
    if (e5 + n5 > t5.length) throw new RangeError("Index out of range");
    if (e5 < 0) throw new RangeError("Index out of range");
  }
  function k2(t5, r5, e5, n5, o5) {
    return r5 = +r5, e5 >>>= 0, o5 || P2(t5, 0, e5, 4), i$13.write(t5, r5, e5, n5, 23, 4), e5 + 4;
  }
  function M2(t5, r5, e5, n5, o5) {
    return r5 = +r5, e5 >>>= 0, o5 || P2(t5, 0, e5, 8), i$13.write(t5, r5, e5, n5, 52, 8), e5 + 8;
  }
  function _2(t5, r5) {
    var e5;
    r5 = r5 || 1 / 0;
    for (var n5 = t5.length, i5 = null, o5 = [], f5 = 0; f5 < n5; ++f5) {
      if ((e5 = t5.charCodeAt(f5)) > 55295 && e5 < 57344) {
        if (!i5) {
          if (e5 > 56319) {
            (r5 -= 3) > -1 && o5.push(239, 191, 189);
            continue;
          }
          if (f5 + 1 === n5) {
            (r5 -= 3) > -1 && o5.push(239, 191, 189);
            continue;
          }
          i5 = e5;
          continue;
        }
        if (e5 < 56320) {
          (r5 -= 3) > -1 && o5.push(239, 191, 189), i5 = e5;
          continue;
        }
        e5 = 65536 + (i5 - 55296 << 10 | e5 - 56320);
      } else i5 && (r5 -= 3) > -1 && o5.push(239, 191, 189);
      if (i5 = null, e5 < 128) {
        if ((r5 -= 1) < 0) break;
        o5.push(e5);
      } else if (e5 < 2048) {
        if ((r5 -= 2) < 0) break;
        o5.push(e5 >> 6 | 192, 63 & e5 | 128);
      } else if (e5 < 65536) {
        if ((r5 -= 3) < 0) break;
        o5.push(e5 >> 12 | 224, e5 >> 6 & 63 | 128, 63 & e5 | 128);
      } else {
        if (!(e5 < 1114112)) throw new Error("Invalid code point");
        if ((r5 -= 4) < 0) break;
        o5.push(e5 >> 18 | 240, e5 >> 12 & 63 | 128, e5 >> 6 & 63 | 128, 63 & e5 | 128);
      }
    }
    return o5;
  }
  function z2(t5) {
    return n$1$1.toByteArray(function(t6) {
      if ((t6 = (t6 = t6.split("=")[0]).trim().replace(j2, "")).length < 2) return "";
      for (; t6.length % 4 != 0; ) t6 += "=";
      return t6;
    }(t5));
  }
  function D2(t5, r5, e5, n5) {
    for (var i5 = 0; i5 < n5 && !(i5 + e5 >= r5.length || i5 >= t5.length); ++i5) r5[i5 + e5] = t5[i5];
    return i5;
  }
  function F2(t5, r5) {
    return t5 instanceof r5 || null != t5 && null != t5.constructor && null != t5.constructor.name && t5.constructor.name === r5.name;
  }
  function N2(t5) {
    return t5 != t5;
  }
  function t4(r5, e5) {
    for (var n5 in r5) e5[n5] = r5[n5];
  }
  function f4(r5, e5, n5) {
    return o4(r5, e5, n5);
  }
  function a4(t5) {
    var e5;
    switch (this.encoding = function(t6) {
      var e6 = function(t7) {
        if (!t7) return "utf8";
        for (var e7; ; ) switch (t7) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t7;
          default:
            if (e7) return;
            t7 = ("" + t7).toLowerCase(), e7 = true;
        }
      }(t6);
      if ("string" != typeof e6 && (s4.isEncoding === i4 || !i4(t6))) throw new Error("Unknown encoding: " + t6);
      return e6 || t6;
    }(t5), this.encoding) {
      case "utf16le":
        this.text = h4, this.end = l4, e5 = 4;
        break;
      case "utf8":
        this.fillLast = n$13, e5 = 4;
        break;
      case "base64":
        this.text = u$13, this.end = o$13, e5 = 3;
        break;
      default:
        return this.write = f$13, this.end = c4, void 0;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s4.allocUnsafe(e5);
  }
  function r4(t5) {
    return t5 <= 127 ? 0 : t5 >> 5 == 6 ? 2 : t5 >> 4 == 14 ? 3 : t5 >> 3 == 30 ? 4 : t5 >> 6 == 2 ? -1 : -2;
  }
  function n$13(t5) {
    var e5 = this.lastTotal - this.lastNeed, s5 = function(t6, e6, s6) {
      if (128 != (192 & e6[0])) return t6.lastNeed = 0, "\uFFFD";
      if (t6.lastNeed > 1 && e6.length > 1) {
        if (128 != (192 & e6[1])) return t6.lastNeed = 1, "\uFFFD";
        if (t6.lastNeed > 2 && e6.length > 2 && 128 != (192 & e6[2])) return t6.lastNeed = 2, "\uFFFD";
      }
    }(this, t5);
    return void 0 !== s5 ? s5 : this.lastNeed <= t5.length ? (t5.copy(this.lastChar, e5, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t5.copy(this.lastChar, e5, 0, t5.length), this.lastNeed -= t5.length, void 0);
  }
  function h4(t5, e5) {
    if ((t5.length - e5) % 2 == 0) {
      var s5 = t5.toString("utf16le", e5);
      if (s5) {
        var i5 = s5.charCodeAt(s5.length - 1);
        if (i5 >= 55296 && i5 <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t5[t5.length - 2], this.lastChar[1] = t5[t5.length - 1], s5.slice(0, -1);
      }
      return s5;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t5[t5.length - 1], t5.toString("utf16le", e5, t5.length - 1);
  }
  function l4(t5) {
    var e5 = t5 && t5.length ? this.write(t5) : "";
    if (this.lastNeed) {
      var s5 = this.lastTotal - this.lastNeed;
      return e5 + this.lastChar.toString("utf16le", 0, s5);
    }
    return e5;
  }
  function u$13(t5, e5) {
    var s5 = (t5.length - e5) % 3;
    return 0 === s5 ? t5.toString("base64", e5) : (this.lastNeed = 3 - s5, this.lastTotal = 3, 1 === s5 ? this.lastChar[0] = t5[t5.length - 1] : (this.lastChar[0] = t5[t5.length - 2], this.lastChar[1] = t5[t5.length - 1]), t5.toString("base64", e5, t5.length - s5));
  }
  function o$13(t5) {
    var e5 = t5 && t5.length ? this.write(t5) : "";
    return this.lastNeed ? e5 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e5;
  }
  function f$13(t5) {
    return t5.toString(this.encoding);
  }
  function c4(t5) {
    return t5 && t5.length ? this.write(t5) : "";
  }
  function dew$2$1() {
    if (_dewExec$2$1) return exports$2$1;
    _dewExec$2$1 = true;
    exports$2$1.byteLength = byteLength;
    exports$2$1.toByteArray = toByteArray;
    exports$2$1.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i5 = 0, len = code.length; i5 < len; ++i5) {
      lookup[i5] = code[i5];
      revLookup[code.charCodeAt(i5)] = i5;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i6;
      for (i6 = 0; i6 < len2; i6 += 4) {
        tmp = revLookup[b64.charCodeAt(i6)] << 18 | revLookup[b64.charCodeAt(i6 + 1)] << 12 | revLookup[b64.charCodeAt(i6 + 2)] << 6 | revLookup[b64.charCodeAt(i6 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i6)] << 2 | revLookup[b64.charCodeAt(i6 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i6)] << 10 | revLookup[b64.charCodeAt(i6 + 1)] << 4 | revLookup[b64.charCodeAt(i6 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i6 = start; i6 < end; i6 += 3) {
        tmp = (uint8[i6] << 16 & 16711680) + (uint8[i6 + 1] << 8 & 65280) + (uint8[i6 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i6 = 0, len22 = len2 - extraBytes; i6 < len22; i6 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i6, i6 + maxChunkLength > len22 ? len22 : i6 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    return exports$2$1;
  }
  function dew$1$1() {
    if (_dewExec$1$1) return exports$1$1;
    _dewExec$1$1 = true;
    exports$1$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e5, m4;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i5 = isLE ? nBytes - 1 : 0;
      var d4 = isLE ? -1 : 1;
      var s5 = buffer2[offset + i5];
      i5 += d4;
      e5 = s5 & (1 << -nBits) - 1;
      s5 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e5 = e5 * 256 + buffer2[offset + i5], i5 += d4, nBits -= 8) {
      }
      m4 = e5 & (1 << -nBits) - 1;
      e5 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m4 = m4 * 256 + buffer2[offset + i5], i5 += d4, nBits -= 8) {
      }
      if (e5 === 0) {
        e5 = 1 - eBias;
      } else if (e5 === eMax) {
        return m4 ? NaN : (s5 ? -1 : 1) * Infinity;
      } else {
        m4 = m4 + Math.pow(2, mLen);
        e5 = e5 - eBias;
      }
      return (s5 ? -1 : 1) * m4 * Math.pow(2, e5 - mLen);
    };
    exports$1$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e5, m4, c5;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i5 = isLE ? 0 : nBytes - 1;
      var d4 = isLE ? 1 : -1;
      var s5 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m4 = isNaN(value) ? 1 : 0;
        e5 = eMax;
      } else {
        e5 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c5 = Math.pow(2, -e5)) < 1) {
          e5--;
          c5 *= 2;
        }
        if (e5 + eBias >= 1) {
          value += rt / c5;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c5 >= 2) {
          e5++;
          c5 /= 2;
        }
        if (e5 + eBias >= eMax) {
          m4 = 0;
          e5 = eMax;
        } else if (e5 + eBias >= 1) {
          m4 = (value * c5 - 1) * Math.pow(2, mLen);
          e5 = e5 + eBias;
        } else {
          m4 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e5 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i5] = m4 & 255, i5 += d4, m4 /= 256, mLen -= 8) {
      }
      e5 = e5 << mLen | m4;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i5] = e5 & 255, i5 += d4, e5 /= 256, eLen -= 8) {
      }
      buffer2[offset + i5 - d4] |= s5 * 128;
    };
    return exports$1$1;
  }
  function dew$g2() {
    if (_dewExec$g2) return exports$g2;
    _dewExec$g2 = true;
    const base64 = dew$2$1();
    const ieee754 = dew$1$1();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports$g2.Buffer = Buffer3;
    exports$g2.SlowBuffer = SlowBuffer;
    exports$g2.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports$g2.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e5) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b4 = fromObject(value);
      if (b4) return b4;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i5 = 0; i5 < length; i5 += 1) {
        buf[i5] = array[i5] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer2(b4) {
      return b4 != null && b4._isBuffer === true && b4 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a5, b4) {
      if (isInstance(a5, Uint8Array)) a5 = Buffer3.from(a5, a5.offset, a5.byteLength);
      if (isInstance(b4, Uint8Array)) b4 = Buffer3.from(b4, b4.offset, b4.byteLength);
      if (!Buffer3.isBuffer(a5) || !Buffer3.isBuffer(b4)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a5 === b4) return 0;
      let x3 = a5.length;
      let y5 = b4.length;
      for (let i5 = 0, len = Math.min(x3, y5); i5 < len; ++i5) {
        if (a5[i5] !== b4[i5]) {
          x3 = a5[i5];
          y5 = b4[i5];
          break;
        }
      }
      if (x3 < y5) return -1;
      if (y5 < x3) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i5;
      if (length === void 0) {
        length = 0;
        for (i5 = 0; i5 < list.length; ++i5) {
          length += list[i5].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        let buf = list[i5];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(buffer2, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b4, n5, m4) {
      const i5 = b4[n5];
      b4[n5] = b4[m4];
      b4[m4] = i5;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 2) {
        swap(this, i5, i5 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 4) {
        swap(this, i5, i5 + 3);
        swap(this, i5 + 1, i5 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 8) {
        swap(this, i5, i5 + 7);
        swap(this, i5 + 1, i5 + 6);
        swap(this, i5 + 2, i5 + 5);
        swap(this, i5 + 3, i5 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b4) {
      if (!Buffer3.isBuffer(b4)) throw new TypeError("Argument must be a Buffer");
      if (this === b4) return true;
      return Buffer3.compare(this, b4) === 0;
    };
    Buffer3.prototype.inspect = function inspect2() {
      let str = "";
      const max = exports$g2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x3 = thisEnd - thisStart;
      let y5 = end - start;
      const len = Math.min(x3, y5);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i5 = 0; i5 < len; ++i5) {
        if (thisCopy[i5] !== targetCopy[i5]) {
          x3 = thisCopy[i5];
          y5 = targetCopy[i5];
          break;
        }
      }
      if (x3 < y5) return -1;
      if (y5 < x3) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i6) {
        if (indexSize === 1) {
          return buf[i6];
        } else {
          return buf.readUInt16BE(i6 * indexSize);
        }
      }
      let i5;
      if (dir) {
        let foundIndex = -1;
        for (i5 = byteOffset; i5 < arrLength; i5++) {
          if (read(arr, i5) === read(val, foundIndex === -1 ? 0 : i5 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i5;
            if (i5 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i5 -= i5 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i5 = byteOffset; i5 >= 0; i5--) {
          let found = true;
          for (let j3 = 0; j3 < valLength; j3++) {
            if (read(arr, i5 + j3) !== read(val, j3)) {
              found = false;
              break;
            }
          }
          if (found) return i5;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i5;
      for (i5 = 0; i5 < length; ++i5) {
        const parsed = parseInt(string.substr(i5 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i5;
        buf[offset + i5] = parsed;
      }
      return i5;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i5 = start;
      while (i5 < end) {
        const firstByte = buf[i5];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i5 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i5 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              fourthByte = buf[i5 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i5 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i5 = 0;
      while (i5 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i5, i5 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i5 = start; i5 < end; ++i5) {
        out += hexSliceLookupTable[buf[i5]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i5 = 0; i5 < bytes.length - 1; i5 += 2) {
        res += String.fromCharCode(bytes[i5] + bytes[i5 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i5 = 0;
      while (++i5 < byteLength2 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i5 = 0;
      while (++i5 < byteLength2 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i5 = byteLength2;
      let mul = 1;
      let val = this[offset + --i5];
      while (i5 > 0 && (mul *= 256)) {
        val += this[offset + --i5] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i5 = 0;
      this[offset] = value & 255;
      while (++i5 < byteLength2 && (mul *= 256)) {
        this[offset + i5] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i5 = byteLength2 - 1;
      let mul = 1;
      this[offset + i5] = value & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        this[offset + i5] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i5 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i5 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i5 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i5] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i5 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i5] = value & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i5 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i5] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    const errors = {};
    function E3(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E3("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E3("ERR_INVALID_ARG_TYPE", function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E3("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i5 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i5 >= start + 4; i5 -= 3) {
        res = `_${val.slice(i5 - 3, i5)}${res}`;
      }
      return `${val.slice(0, i5)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n5 = typeof min === "bigint" ? "n" : "";
        let range;
        {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n5} and < 2${n5} ** ${(byteLength2 + 1) * 8}${n5}`;
          } else {
            range = `>= -(2${n5} ** ${(byteLength2 + 1) * 8 - 1}${n5}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n5}`;
          }
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type2) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type2);
        throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE("offset", `>= ${0} and <= ${length}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i5 = 0; i5 < length; ++i5) {
        codePoint = string.charCodeAt(i5);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i5 + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i5 = 0; i5 < str.length; ++i5) {
        byteArray.push(str.charCodeAt(i5) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c5, hi, lo;
      const byteArray = [];
      for (let i5 = 0; i5 < str.length; ++i5) {
        if ((units -= 2) < 0) break;
        c5 = str.charCodeAt(i5);
        hi = c5 >> 8;
        lo = c5 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i5;
      for (i5 = 0; i5 < length; ++i5) {
        if (i5 + offset >= dst.length || i5 >= src.length) break;
        dst[i5 + offset] = src[i5];
      }
      return i5;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i5 = 0; i5 < 16; ++i5) {
        const i16 = i5 * 16;
        for (let j3 = 0; j3 < 16; ++j3) {
          table[i16 + j3] = alphabet[i5] + alphabet[j3];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    return exports$g2;
  }
  function dew$f2() {
    if (_dewExec$f2) return exports$f2;
    _dewExec$f2 = true;
    if (typeof Object.create === "function") {
      exports$f2 = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      exports$f2 = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    return exports$f2;
  }
  function dew$e2() {
    if (_dewExec$e2) return exports$e2;
    _dewExec$e2 = true;
    exports$e2 = y.EventEmitter;
    return exports$e2;
  }
  function dew$d2() {
    if (_dewExec$d2) return exports$d2;
    _dewExec$d2 = true;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        var source = arguments[i5] != null ? arguments[i5] : {};
        if (i5 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      return Constructor;
    }
    var _require = buffer, Buffer3 = _require.Buffer;
    var _require2 = X, inspect2 = _require2.inspect;
    var custom = inspect2 && inspect2.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer3.prototype.copy.call(src, target, offset);
    }
    exports$d2 = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v5) {
          var entry = {
            data: v5,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v5) {
          var entry = {
            data: v5,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s5) {
          if (this.length === 0) return "";
          var p5 = this.head;
          var ret = "" + p5.data;
          while (p5 = p5.next) {
            ret += s5 + p5.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n5) {
          if (this.length === 0) return Buffer3.alloc(0);
          var ret = Buffer3.allocUnsafe(n5 >>> 0);
          var p5 = this.head;
          var i5 = 0;
          while (p5) {
            copyBuffer(p5.data, ret, i5);
            i5 += p5.data.length;
            p5 = p5.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n5, hasStrings) {
          var ret;
          if (n5 < this.head.data.length) {
            ret = this.head.data.slice(0, n5);
            this.head.data = this.head.data.slice(n5);
          } else if (n5 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n5) : this._getBuffer(n5);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n5) {
          var p5 = this.head;
          var c5 = 1;
          var ret = p5.data;
          n5 -= ret.length;
          while (p5 = p5.next) {
            var str = p5.data;
            var nb = n5 > str.length ? str.length : n5;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n5);
            n5 -= nb;
            if (n5 === 0) {
              if (nb === str.length) {
                ++c5;
                if (p5.next) this.head = p5.next;
                else this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = str.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n5) {
          var ret = Buffer3.allocUnsafe(n5);
          var p5 = this.head;
          var c5 = 1;
          p5.data.copy(ret);
          n5 -= p5.data.length;
          while (p5 = p5.next) {
            var buf = p5.data;
            var nb = n5 > buf.length ? buf.length : n5;
            buf.copy(ret, ret.length - n5, 0, nb);
            n5 -= nb;
            if (n5 === 0) {
              if (nb === buf.length) {
                ++c5;
                if (p5.next) this.head = p5.next;
                else this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = buf.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_3, options) {
          return inspect2(this, _objectSpread({}, options, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
    return exports$d2;
  }
  function dew$c2() {
    if (_dewExec$c2) return exports$c2;
    _dewExec$c2 = true;
    var process$1 = process3;
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process$1.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process$1.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process$1.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    exports$c2 = {
      destroy,
      undestroy,
      errorOrDestroy
    };
    return exports$c2;
  }
  function dew$b2() {
    if (_dewExec$b2) return exports$b2;
    _dewExec$b2 = true;
    const codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i5) => String(i5));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(0, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + value + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name2, " argument")) {
        msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type2 = includes(name2, ".") ? "property" : "argument";
        msg = `The "${name2}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    exports$b2.codes = codes;
    return exports$b2;
  }
  function dew$a2() {
    if (_dewExec$a2) return exports$a2;
    _dewExec$a2 = true;
    var ERR_INVALID_OPT_VALUE = dew$b2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name2 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name2, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    exports$a2 = {
      getHighWaterMark
    };
    return exports$a2;
  }
  function dew$92() {
    if (_dewExec$92) return exports$92;
    _dewExec$92 = true;
    exports$92 = deprecate2;
    function deprecate2(fn, msg) {
      if (config2("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config2("throwDeprecation")) {
            throw new Error(msg);
          } else if (config2("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this || _global$22, arguments);
      }
      return deprecated;
    }
    function config2(name2) {
      try {
        if (!_global$22.localStorage) return false;
      } catch (_3) {
        return false;
      }
      var val = _global$22.localStorage[name2];
      if (null == val) return false;
      return String(val).toLowerCase() === "true";
    }
    return exports$92;
  }
  function dew$82() {
    if (_dewExec$82) return exports$82;
    _dewExec$82 = true;
    var process$1 = process3;
    exports$82 = Writable2;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex2;
    Writable2.WritableState = WritableState;
    var internalUtil = {
      deprecate: dew$92()
    };
    var Stream2 = dew$e2();
    var Buffer3 = buffer.Buffer;
    var OurUint8Array = _global$12.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = dew$c2();
    var _require = dew$a2(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = dew$b2().codes, ERR_INVALID_ARG_TYPE2 = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    dew$f2()(Writable2, Stream2);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || dew$72();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_3) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable2) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable2(options) {
      Duplex2 = Duplex2 || dew$72();
      var isDuplex = this instanceof Duplex2;
      if (!isDuplex && !realHasInstance.call(Writable2, this)) return new Writable2(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process$1.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer3.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer3.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process$1.nextTick(cb, er);
        process$1.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished2 = needFinish(state) || stream.destroyed;
        if (!finished2 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process$1.nextTick(afterWrite, stream, state, finished2, cb);
        } else {
          afterWrite(stream, state, finished2, cb);
        }
      }
    }
    function afterWrite(stream, state, finished2, cb) {
      if (!finished2) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l5 = state.bufferedRequestCount;
        var buffer2 = new Array(l5);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process$1.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process$1.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    return exports$82;
  }
  function dew$72() {
    if (_dewExec$72) return exports$72;
    _dewExec$72 = true;
    var process$1 = process3;
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    exports$72 = Duplex2;
    var Readable2 = dew$32();
    var Writable2 = dew$82();
    dew$f2()(Duplex2, Readable2);
    {
      var keys = objectKeys(Writable2.prototype);
      for (var v5 = 0; v5 < keys.length; v5++) {
        var method = keys[v5];
        if (!Duplex2.prototype[method]) Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    function Duplex2(options) {
      if (!(this instanceof Duplex2)) return new Duplex2(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process$1.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    return exports$72;
  }
  function dew$62() {
    if (_dewExec$62) return exports$62;
    _dewExec$62 = true;
    var ERR_STREAM_PREMATURE_CLOSE = dew$b2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once3(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once3(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    exports$62 = eos;
    return exports$62;
  }
  function dew$52() {
    if (_dewExec$52) return exports$52;
    _dewExec$52 = true;
    var process$1 = process3;
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished2 = dew$62();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult2(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve2 = iter[kLastResolve];
      if (resolve2 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve2(createIterResult2(data, false));
        }
      }
    }
    function onReadable(iter) {
      process$1.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve2, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve2(createIterResult2(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve2, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult2(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve2, reject) {
            process$1.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve2(createIterResult2(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult2(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve2, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve2(createIterResult2(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve2, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult2(data, false));
          } else {
            iterator[kLastResolve] = resolve2;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished2(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve2 = iterator[kLastResolve];
        if (resolve2 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult2(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    exports$52 = createReadableStreamAsyncIterator;
    return exports$52;
  }
  function dew$42() {
    if (_dewExec$42) return exports$42;
    _dewExec$42 = true;
    exports$42 = function() {
      throw new Error("Readable.from is not available in the browser");
    };
    return exports$42;
  }
  function dew$32() {
    if (_dewExec$32) return exports$32;
    _dewExec$32 = true;
    var process$1 = process3;
    exports$32 = Readable2;
    var Duplex2;
    Readable2.ReadableState = ReadableState;
    y.EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type2) {
      return emitter.listeners(type2).length;
    };
    var Stream2 = dew$e2();
    var Buffer3 = buffer.Buffer;
    var OurUint8Array = _global4.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = X;
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = dew$d2();
    var destroyImpl = dew$c2();
    var _require = dew$a2(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = dew$b2().codes, ERR_INVALID_ARG_TYPE2 = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder2;
    var createReadableStreamAsyncIterator;
    var from;
    dew$f2()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener2(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || dew$72();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder2) StringDecoder2 = e$13.StringDecoder;
        this.decoder = new StringDecoder2(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex2 = Duplex2 || dew$72();
      if (!(this instanceof Readable2)) return new Readable2(options);
      var isDuplex = this instanceof Duplex2;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder2) StringDecoder2 = e$13.StringDecoder;
      var decoder = new StringDecoder2(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p5 = this._readableState.buffer.head;
      var content = "";
      while (p5 !== null) {
        content += decoder.write(p5.data);
        p5 = p5.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n5) {
      if (n5 >= MAX_HWM) {
        n5 = MAX_HWM;
      } else {
        n5--;
        n5 |= n5 >>> 1;
        n5 |= n5 >>> 2;
        n5 |= n5 >>> 4;
        n5 |= n5 >>> 8;
        n5 |= n5 >>> 16;
        n5++;
      }
      return n5;
    }
    function howMuchToRead(n5, state) {
      if (n5 <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n5 !== n5) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n5 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n5);
      if (n5 <= state.length) return n5;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n5) {
      debug("read", n5);
      n5 = parseInt(n5, 10);
      var state = this._readableState;
      var nOrig = n5;
      if (n5 !== 0) state.emittedReadable = false;
      if (n5 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n5 = howMuchToRead(n5, state);
      if (n5 === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n5 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n5 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n5 > 0) ret = fromList(n5, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n5 = 0;
      } else {
        state.length -= n5;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n5 && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process$1.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process$1.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n5) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process$1.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i5 = 0; i5 < len; i5++) {
          dests[i5].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process$1.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process$1.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i5 in stream) {
        if (this[i5] === void 0 && typeof stream[i5] === "function") {
          this[i5] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i5);
        }
      }
      for (var n5 = 0; n5 < kProxyEvents.length; n5++) {
        stream.on(kProxyEvents[n5], this.emit.bind(this, kProxyEvents[n5]));
      }
      this._read = function(n6) {
        debug("wrapped _read", n6);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = dew$52();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState.length;
      }
    });
    function fromList(n5, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n5 || n5 >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n5, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process$1.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from === void 0) {
          from = dew$42();
        }
        return from(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x3) {
      for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
        if (xs[i5] === x3) return i5;
      }
      return -1;
    }
    return exports$32;
  }
  function dew$23() {
    if (_dewExec$23) return exports$25;
    _dewExec$23 = true;
    exports$25 = Transform2;
    var _require$codes = dew$b2().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex2 = dew$72();
    dew$f2()(Transform2, Duplex2);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2)) return new Transform2(options);
      Duplex2.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex2.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n5) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex2.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
    return exports$25;
  }
  function dew$15() {
    if (_dewExec$15) return exports$16;
    _dewExec$15 = true;
    exports$16 = PassThrough2;
    var Transform2 = dew$23();
    dew$f2()(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2)) return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    return exports$16;
  }
  function dew9() {
    if (_dewExec9) return exports10;
    _dewExec9 = true;
    var eos;
    function once3(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = dew$b2().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once3(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = dew$62();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop2;
      if (typeof streams[streams.length - 1] !== "function") return noop2;
      return streams.pop();
    }
    function pipeline2() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i5) {
        var reading = i5 < streams.length - 1;
        var writing = i5 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    exports10 = pipeline2;
    return exports10;
  }
  var r$13, t$13, e$23, n$23, o$23, a$13, h$13, a$1$1, e$1$1, n$1$1, i$13, o$1$1, j2, Y2, e4, n4, o4, u4, e$13, s4, i4, exports$2$1, _dewExec$2$1, exports$1$1, _dewExec$1$1, exports$g2, _dewExec$g2, buffer, exports$f2, _dewExec$f2, exports$e2, _dewExec$e2, exports$d2, _dewExec$d2, exports$c2, _dewExec$c2, exports$b2, _dewExec$b2, exports$a2, _dewExec$a2, exports$92, _dewExec$92, _global$22, exports$82, _dewExec$82, _global$12, exports$72, _dewExec$72, exports$62, _dewExec$62, exports$52, _dewExec$52, exports$42, _dewExec$42, exports$32, _dewExec$32, _global4, exports$25, _dewExec$23, exports$16, _dewExec$15, exports10, _dewExec9;
  var init_chunk_B738Er4n = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-B738Er4n.js"() {
      init_buffer2();
      init_chunk_tHuMsdT0();
      init_chunk_D3uu3VYh();
      init_chunk_b0rmRow7();
      for (r$13 = { byteLength: function(r5) {
        var t5 = u$22(r5), e5 = t5[0], n5 = t5[1];
        return 3 * (e5 + n5) / 4 - n5;
      }, toByteArray: function(r5) {
        var t5, o5, a5 = u$22(r5), h5 = a5[0], c5 = a5[1], d4 = new n$23(function(r6, t6, e5) {
          return 3 * (t6 + e5) / 4 - e5;
        }(0, h5, c5)), f5 = 0, A3 = c5 > 0 ? h5 - 4 : h5;
        for (o5 = 0; o5 < A3; o5 += 4) t5 = e$23[r5.charCodeAt(o5)] << 18 | e$23[r5.charCodeAt(o5 + 1)] << 12 | e$23[r5.charCodeAt(o5 + 2)] << 6 | e$23[r5.charCodeAt(o5 + 3)], d4[f5++] = t5 >> 16 & 255, d4[f5++] = t5 >> 8 & 255, d4[f5++] = 255 & t5;
        2 === c5 && (t5 = e$23[r5.charCodeAt(o5)] << 2 | e$23[r5.charCodeAt(o5 + 1)] >> 4, d4[f5++] = 255 & t5);
        1 === c5 && (t5 = e$23[r5.charCodeAt(o5)] << 10 | e$23[r5.charCodeAt(o5 + 1)] << 4 | e$23[r5.charCodeAt(o5 + 2)] >> 2, d4[f5++] = t5 >> 8 & 255, d4[f5++] = 255 & t5);
        return d4;
      }, fromByteArray: function(r5) {
        for (var e5, n5 = r5.length, o5 = n5 % 3, a5 = [], h5 = 0, u5 = n5 - o5; h5 < u5; h5 += 16383) a5.push(c$13(r5, h5, h5 + 16383 > u5 ? u5 : h5 + 16383));
        1 === o5 ? (e5 = r5[n5 - 1], a5.push(t$13[e5 >> 2] + t$13[e5 << 4 & 63] + "==")) : 2 === o5 && (e5 = (r5[n5 - 2] << 8) + r5[n5 - 1], a5.push(t$13[e5 >> 10] + t$13[e5 >> 4 & 63] + t$13[e5 << 2 & 63] + "="));
        return a5.join("");
      } }, t$13 = [], e$23 = [], n$23 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$23 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$13 = 0, h$13 = o$23.length; a$13 < h$13; ++a$13) t$13[a$13] = o$23[a$13], e$23[o$23.charCodeAt(a$13)] = a$13;
      e$23["-".charCodeAt(0)] = 62, e$23["_".charCodeAt(0)] = 63;
      a$1$1 = { read: function(a5, t5, o5, r5, h5) {
        var M3, f5, p5 = 8 * h5 - r5 - 1, w3 = (1 << p5) - 1, e5 = w3 >> 1, i5 = -7, N3 = o5 ? h5 - 1 : 0, n5 = o5 ? -1 : 1, u5 = a5[t5 + N3];
        for (N3 += n5, M3 = u5 & (1 << -i5) - 1, u5 >>= -i5, i5 += p5; i5 > 0; M3 = 256 * M3 + a5[t5 + N3], N3 += n5, i5 -= 8) ;
        for (f5 = M3 & (1 << -i5) - 1, M3 >>= -i5, i5 += r5; i5 > 0; f5 = 256 * f5 + a5[t5 + N3], N3 += n5, i5 -= 8) ;
        if (0 === M3) M3 = 1 - e5;
        else {
          if (M3 === w3) return f5 ? NaN : 1 / 0 * (u5 ? -1 : 1);
          f5 += Math.pow(2, r5), M3 -= e5;
        }
        return (u5 ? -1 : 1) * f5 * Math.pow(2, M3 - r5);
      }, write: function(a5, t5, o5, r5, h5, M3) {
        var f5, p5, w3, e5 = 8 * M3 - h5 - 1, i5 = (1 << e5) - 1, N3 = i5 >> 1, n5 = 23 === h5 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u5 = r5 ? 0 : M3 - 1, l5 = r5 ? 1 : -1, s5 = t5 < 0 || 0 === t5 && 1 / t5 < 0 ? 1 : 0;
        for (t5 = Math.abs(t5), isNaN(t5) || t5 === 1 / 0 ? (p5 = isNaN(t5) ? 1 : 0, f5 = i5) : (f5 = Math.floor(Math.log(t5) / Math.LN2), t5 * (w3 = Math.pow(2, -f5)) < 1 && (f5--, w3 *= 2), (t5 += f5 + N3 >= 1 ? n5 / w3 : n5 * Math.pow(2, 1 - N3)) * w3 >= 2 && (f5++, w3 /= 2), f5 + N3 >= i5 ? (p5 = 0, f5 = i5) : f5 + N3 >= 1 ? (p5 = (t5 * w3 - 1) * Math.pow(2, h5), f5 += N3) : (p5 = t5 * Math.pow(2, N3 - 1) * Math.pow(2, h5), f5 = 0)); h5 >= 8; a5[o5 + u5] = 255 & p5, u5 += l5, p5 /= 256, h5 -= 8) ;
        for (f5 = f5 << h5 | p5, e5 += h5; e5 > 0; a5[o5 + u5] = 255 & f5, u5 += l5, f5 /= 256, e5 -= 8) ;
        a5[o5 + u5 - l5] |= 128 * s5;
      } };
      e$1$1 = {};
      n$1$1 = r$13;
      i$13 = a$1$1;
      o$1$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
      e$1$1.Buffer = u$1$1, e$1$1.SlowBuffer = function(t5) {
        +t5 != t5 && (t5 = 0);
        return u$1$1.alloc(+t5);
      }, e$1$1.INSPECT_MAX_BYTES = 50;
      e$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
        try {
          var t5 = new Uint8Array(1), r5 = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(r5, Uint8Array.prototype), Object.setPrototypeOf(t5, r5), 42 === t5.foo();
        } catch (t6) {
          return false;
        }
      }(), u$1$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$1.prototype, "parent", { enumerable: true, get: function() {
        if (u$1$1.isBuffer(this)) return this.buffer;
      } }), Object.defineProperty(u$1$1.prototype, "offset", { enumerable: true, get: function() {
        if (u$1$1.isBuffer(this)) return this.byteOffset;
      } }), u$1$1.poolSize = 8192, u$1$1.from = function(t5, r5, e5) {
        return s$12(t5, r5, e5);
      }, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function(t5, r5, e5) {
        return function(t6, r6, e6) {
          return h$1$1(t6), t6 <= 0 ? f$2(t6) : void 0 !== r6 ? "string" == typeof e6 ? f$2(t6).fill(r6, e6) : f$2(t6).fill(r6) : f$2(t6);
        }(t5, r5, e5);
      }, u$1$1.allocUnsafe = function(t5) {
        return a$2(t5);
      }, u$1$1.allocUnsafeSlow = function(t5) {
        return a$2(t5);
      }, u$1$1.isBuffer = function(t5) {
        return null != t5 && true === t5._isBuffer && t5 !== u$1$1.prototype;
      }, u$1$1.compare = function(t5, r5) {
        if (F2(t5, Uint8Array) && (t5 = u$1$1.from(t5, t5.offset, t5.byteLength)), F2(r5, Uint8Array) && (r5 = u$1$1.from(r5, r5.offset, r5.byteLength)), !u$1$1.isBuffer(t5) || !u$1$1.isBuffer(r5)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (t5 === r5) return 0;
        for (var e5 = t5.length, n5 = r5.length, i5 = 0, o5 = Math.min(e5, n5); i5 < o5; ++i5) if (t5[i5] !== r5[i5]) {
          e5 = t5[i5], n5 = r5[i5];
          break;
        }
        return e5 < n5 ? -1 : n5 < e5 ? 1 : 0;
      }, u$1$1.isEncoding = function(t5) {
        switch (String(t5).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, u$1$1.concat = function(t5, r5) {
        if (!Array.isArray(t5)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t5.length) return u$1$1.alloc(0);
        var e5;
        if (void 0 === r5) for (r5 = 0, e5 = 0; e5 < t5.length; ++e5) r5 += t5[e5].length;
        var n5 = u$1$1.allocUnsafe(r5), i5 = 0;
        for (e5 = 0; e5 < t5.length; ++e5) {
          var o5 = t5[e5];
          if (F2(o5, Uint8Array) && (o5 = u$1$1.from(o5)), !u$1$1.isBuffer(o5)) throw new TypeError('"list" argument must be an Array of Buffers');
          o5.copy(n5, i5), i5 += o5.length;
        }
        return n5;
      }, u$1$1.byteLength = y4, u$1$1.prototype._isBuffer = true, u$1$1.prototype.swap16 = function() {
        var t5 = this.length;
        if (t5 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var r5 = 0; r5 < t5; r5 += 2) w2(this, r5, r5 + 1);
        return this;
      }, u$1$1.prototype.swap32 = function() {
        var t5 = this.length;
        if (t5 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var r5 = 0; r5 < t5; r5 += 4) w2(this, r5, r5 + 3), w2(this, r5 + 1, r5 + 2);
        return this;
      }, u$1$1.prototype.swap64 = function() {
        var t5 = this.length;
        if (t5 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var r5 = 0; r5 < t5; r5 += 8) w2(this, r5, r5 + 7), w2(this, r5 + 1, r5 + 6), w2(this, r5 + 2, r5 + 5), w2(this, r5 + 3, r5 + 4);
        return this;
      }, u$1$1.prototype.toString = function() {
        var t5 = this.length;
        return 0 === t5 ? "" : 0 === arguments.length ? I2(this, 0, t5) : g3.apply(this, arguments);
      }, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function(t5) {
        if (!u$1$1.isBuffer(t5)) throw new TypeError("Argument must be a Buffer");
        return this === t5 || 0 === u$1$1.compare(this, t5);
      }, u$1$1.prototype.inspect = function() {
        var t5 = "", r5 = e$1$1.INSPECT_MAX_BYTES;
        return t5 = this.toString("hex", 0, r5).replace(/(.{2})/g, "$1 ").trim(), this.length > r5 && (t5 += " ... "), "<Buffer " + t5 + ">";
      }, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function(t5, r5, e5, n5, i5) {
        if (F2(t5, Uint8Array) && (t5 = u$1$1.from(t5, t5.offset, t5.byteLength)), !u$1$1.isBuffer(t5)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t5);
        if (void 0 === r5 && (r5 = 0), void 0 === e5 && (e5 = t5 ? t5.length : 0), void 0 === n5 && (n5 = 0), void 0 === i5 && (i5 = this.length), r5 < 0 || e5 > t5.length || n5 < 0 || i5 > this.length) throw new RangeError("out of range index");
        if (n5 >= i5 && r5 >= e5) return 0;
        if (n5 >= i5) return -1;
        if (r5 >= e5) return 1;
        if (this === t5) return 0;
        for (var o5 = (i5 >>>= 0) - (n5 >>>= 0), f5 = (e5 >>>= 0) - (r5 >>>= 0), s5 = Math.min(o5, f5), h5 = this.slice(n5, i5), a5 = t5.slice(r5, e5), p5 = 0; p5 < s5; ++p5) if (h5[p5] !== a5[p5]) {
          o5 = h5[p5], f5 = a5[p5];
          break;
        }
        return o5 < f5 ? -1 : f5 < o5 ? 1 : 0;
      }, u$1$1.prototype.includes = function(t5, r5, e5) {
        return -1 !== this.indexOf(t5, r5, e5);
      }, u$1$1.prototype.indexOf = function(t5, r5, e5) {
        return d3(this, t5, r5, e5, true);
      }, u$1$1.prototype.lastIndexOf = function(t5, r5, e5) {
        return d3(this, t5, r5, e5, false);
      }, u$1$1.prototype.write = function(t5, r5, e5, n5) {
        if (void 0 === r5) n5 = "utf8", e5 = this.length, r5 = 0;
        else if (void 0 === e5 && "string" == typeof r5) n5 = r5, e5 = this.length, r5 = 0;
        else {
          if (!isFinite(r5)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          r5 >>>= 0, isFinite(e5) ? (e5 >>>= 0, void 0 === n5 && (n5 = "utf8")) : (n5 = e5, e5 = void 0);
        }
        var i5 = this.length - r5;
        if ((void 0 === e5 || e5 > i5) && (e5 = i5), t5.length > 0 && (e5 < 0 || r5 < 0) || r5 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        n5 || (n5 = "utf8");
        for (var o5 = false; ; ) switch (n5) {
          case "hex":
            return b3(this, t5, r5, e5);
          case "utf8":
          case "utf-8":
            return m3(this, t5, r5, e5);
          case "ascii":
            return E2(this, t5, r5, e5);
          case "latin1":
          case "binary":
            return B2(this, t5, r5, e5);
          case "base64":
            return A2(this, t5, r5, e5);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return U2(this, t5, r5, e5);
          default:
            if (o5) throw new TypeError("Unknown encoding: " + n5);
            n5 = ("" + n5).toLowerCase(), o5 = true;
        }
      }, u$1$1.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      u$1$1.prototype.slice = function(t5, r5) {
        var e5 = this.length;
        (t5 = ~~t5) < 0 ? (t5 += e5) < 0 && (t5 = 0) : t5 > e5 && (t5 = e5), (r5 = void 0 === r5 ? e5 : ~~r5) < 0 ? (r5 += e5) < 0 && (r5 = 0) : r5 > e5 && (r5 = e5), r5 < t5 && (r5 = t5);
        var n5 = this.subarray(t5, r5);
        return Object.setPrototypeOf(n5, u$1$1.prototype), n5;
      }, u$1$1.prototype.readUIntLE = function(t5, r5, e5) {
        t5 >>>= 0, r5 >>>= 0, e5 || x2(t5, r5, this.length);
        for (var n5 = this[t5], i5 = 1, o5 = 0; ++o5 < r5 && (i5 *= 256); ) n5 += this[t5 + o5] * i5;
        return n5;
      }, u$1$1.prototype.readUIntBE = function(t5, r5, e5) {
        t5 >>>= 0, r5 >>>= 0, e5 || x2(t5, r5, this.length);
        for (var n5 = this[t5 + --r5], i5 = 1; r5 > 0 && (i5 *= 256); ) n5 += this[t5 + --r5] * i5;
        return n5;
      }, u$1$1.prototype.readUInt8 = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 1, this.length), this[t5];
      }, u$1$1.prototype.readUInt16LE = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 2, this.length), this[t5] | this[t5 + 1] << 8;
      }, u$1$1.prototype.readUInt16BE = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 2, this.length), this[t5] << 8 | this[t5 + 1];
      }, u$1$1.prototype.readUInt32LE = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 4, this.length), (this[t5] | this[t5 + 1] << 8 | this[t5 + 2] << 16) + 16777216 * this[t5 + 3];
      }, u$1$1.prototype.readUInt32BE = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 4, this.length), 16777216 * this[t5] + (this[t5 + 1] << 16 | this[t5 + 2] << 8 | this[t5 + 3]);
      }, u$1$1.prototype.readIntLE = function(t5, r5, e5) {
        t5 >>>= 0, r5 >>>= 0, e5 || x2(t5, r5, this.length);
        for (var n5 = this[t5], i5 = 1, o5 = 0; ++o5 < r5 && (i5 *= 256); ) n5 += this[t5 + o5] * i5;
        return n5 >= (i5 *= 128) && (n5 -= Math.pow(2, 8 * r5)), n5;
      }, u$1$1.prototype.readIntBE = function(t5, r5, e5) {
        t5 >>>= 0, r5 >>>= 0, e5 || x2(t5, r5, this.length);
        for (var n5 = r5, i5 = 1, o5 = this[t5 + --n5]; n5 > 0 && (i5 *= 256); ) o5 += this[t5 + --n5] * i5;
        return o5 >= (i5 *= 128) && (o5 -= Math.pow(2, 8 * r5)), o5;
      }, u$1$1.prototype.readInt8 = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 1, this.length), 128 & this[t5] ? -1 * (255 - this[t5] + 1) : this[t5];
      }, u$1$1.prototype.readInt16LE = function(t5, r5) {
        t5 >>>= 0, r5 || x2(t5, 2, this.length);
        var e5 = this[t5] | this[t5 + 1] << 8;
        return 32768 & e5 ? 4294901760 | e5 : e5;
      }, u$1$1.prototype.readInt16BE = function(t5, r5) {
        t5 >>>= 0, r5 || x2(t5, 2, this.length);
        var e5 = this[t5 + 1] | this[t5] << 8;
        return 32768 & e5 ? 4294901760 | e5 : e5;
      }, u$1$1.prototype.readInt32LE = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 4, this.length), this[t5] | this[t5 + 1] << 8 | this[t5 + 2] << 16 | this[t5 + 3] << 24;
      }, u$1$1.prototype.readInt32BE = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 4, this.length), this[t5] << 24 | this[t5 + 1] << 16 | this[t5 + 2] << 8 | this[t5 + 3];
      }, u$1$1.prototype.readFloatLE = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 4, this.length), i$13.read(this, t5, true, 23, 4);
      }, u$1$1.prototype.readFloatBE = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 4, this.length), i$13.read(this, t5, false, 23, 4);
      }, u$1$1.prototype.readDoubleLE = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 8, this.length), i$13.read(this, t5, true, 52, 8);
      }, u$1$1.prototype.readDoubleBE = function(t5, r5) {
        return t5 >>>= 0, r5 || x2(t5, 8, this.length), i$13.read(this, t5, false, 52, 8);
      }, u$1$1.prototype.writeUIntLE = function(t5, r5, e5, n5) {
        (t5 = +t5, r5 >>>= 0, e5 >>>= 0, n5) || C2(this, t5, r5, e5, Math.pow(2, 8 * e5) - 1, 0);
        var i5 = 1, o5 = 0;
        for (this[r5] = 255 & t5; ++o5 < e5 && (i5 *= 256); ) this[r5 + o5] = t5 / i5 & 255;
        return r5 + e5;
      }, u$1$1.prototype.writeUIntBE = function(t5, r5, e5, n5) {
        (t5 = +t5, r5 >>>= 0, e5 >>>= 0, n5) || C2(this, t5, r5, e5, Math.pow(2, 8 * e5) - 1, 0);
        var i5 = e5 - 1, o5 = 1;
        for (this[r5 + i5] = 255 & t5; --i5 >= 0 && (o5 *= 256); ) this[r5 + i5] = t5 / o5 & 255;
        return r5 + e5;
      }, u$1$1.prototype.writeUInt8 = function(t5, r5, e5) {
        return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 1, 255, 0), this[r5] = 255 & t5, r5 + 1;
      }, u$1$1.prototype.writeUInt16LE = function(t5, r5, e5) {
        return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 2, 65535, 0), this[r5] = 255 & t5, this[r5 + 1] = t5 >>> 8, r5 + 2;
      }, u$1$1.prototype.writeUInt16BE = function(t5, r5, e5) {
        return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 2, 65535, 0), this[r5] = t5 >>> 8, this[r5 + 1] = 255 & t5, r5 + 2;
      }, u$1$1.prototype.writeUInt32LE = function(t5, r5, e5) {
        return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 4, 4294967295, 0), this[r5 + 3] = t5 >>> 24, this[r5 + 2] = t5 >>> 16, this[r5 + 1] = t5 >>> 8, this[r5] = 255 & t5, r5 + 4;
      }, u$1$1.prototype.writeUInt32BE = function(t5, r5, e5) {
        return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 4, 4294967295, 0), this[r5] = t5 >>> 24, this[r5 + 1] = t5 >>> 16, this[r5 + 2] = t5 >>> 8, this[r5 + 3] = 255 & t5, r5 + 4;
      }, u$1$1.prototype.writeIntLE = function(t5, r5, e5, n5) {
        if (t5 = +t5, r5 >>>= 0, !n5) {
          var i5 = Math.pow(2, 8 * e5 - 1);
          C2(this, t5, r5, e5, i5 - 1, -i5);
        }
        var o5 = 0, f5 = 1, u5 = 0;
        for (this[r5] = 255 & t5; ++o5 < e5 && (f5 *= 256); ) t5 < 0 && 0 === u5 && 0 !== this[r5 + o5 - 1] && (u5 = 1), this[r5 + o5] = (t5 / f5 >> 0) - u5 & 255;
        return r5 + e5;
      }, u$1$1.prototype.writeIntBE = function(t5, r5, e5, n5) {
        if (t5 = +t5, r5 >>>= 0, !n5) {
          var i5 = Math.pow(2, 8 * e5 - 1);
          C2(this, t5, r5, e5, i5 - 1, -i5);
        }
        var o5 = e5 - 1, f5 = 1, u5 = 0;
        for (this[r5 + o5] = 255 & t5; --o5 >= 0 && (f5 *= 256); ) t5 < 0 && 0 === u5 && 0 !== this[r5 + o5 + 1] && (u5 = 1), this[r5 + o5] = (t5 / f5 >> 0) - u5 & 255;
        return r5 + e5;
      }, u$1$1.prototype.writeInt8 = function(t5, r5, e5) {
        return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 1, 127, -128), t5 < 0 && (t5 = 255 + t5 + 1), this[r5] = 255 & t5, r5 + 1;
      }, u$1$1.prototype.writeInt16LE = function(t5, r5, e5) {
        return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 2, 32767, -32768), this[r5] = 255 & t5, this[r5 + 1] = t5 >>> 8, r5 + 2;
      }, u$1$1.prototype.writeInt16BE = function(t5, r5, e5) {
        return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 2, 32767, -32768), this[r5] = t5 >>> 8, this[r5 + 1] = 255 & t5, r5 + 2;
      }, u$1$1.prototype.writeInt32LE = function(t5, r5, e5) {
        return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 4, 2147483647, -2147483648), this[r5] = 255 & t5, this[r5 + 1] = t5 >>> 8, this[r5 + 2] = t5 >>> 16, this[r5 + 3] = t5 >>> 24, r5 + 4;
      }, u$1$1.prototype.writeInt32BE = function(t5, r5, e5) {
        return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 4, 2147483647, -2147483648), t5 < 0 && (t5 = 4294967295 + t5 + 1), this[r5] = t5 >>> 24, this[r5 + 1] = t5 >>> 16, this[r5 + 2] = t5 >>> 8, this[r5 + 3] = 255 & t5, r5 + 4;
      }, u$1$1.prototype.writeFloatLE = function(t5, r5, e5) {
        return k2(this, t5, r5, true, e5);
      }, u$1$1.prototype.writeFloatBE = function(t5, r5, e5) {
        return k2(this, t5, r5, false, e5);
      }, u$1$1.prototype.writeDoubleLE = function(t5, r5, e5) {
        return M2(this, t5, r5, true, e5);
      }, u$1$1.prototype.writeDoubleBE = function(t5, r5, e5) {
        return M2(this, t5, r5, false, e5);
      }, u$1$1.prototype.copy = function(t5, r5, e5, n5) {
        if (!u$1$1.isBuffer(t5)) throw new TypeError("argument should be a Buffer");
        if (e5 || (e5 = 0), n5 || 0 === n5 || (n5 = this.length), r5 >= t5.length && (r5 = t5.length), r5 || (r5 = 0), n5 > 0 && n5 < e5 && (n5 = e5), n5 === e5) return 0;
        if (0 === t5.length || 0 === this.length) return 0;
        if (r5 < 0) throw new RangeError("targetStart out of bounds");
        if (e5 < 0 || e5 >= this.length) throw new RangeError("Index out of range");
        if (n5 < 0) throw new RangeError("sourceEnd out of bounds");
        n5 > this.length && (n5 = this.length), t5.length - r5 < n5 - e5 && (n5 = t5.length - r5 + e5);
        var i5 = n5 - e5;
        if (this === t5 && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(r5, e5, n5);
        else if (this === t5 && e5 < r5 && r5 < n5) for (var o5 = i5 - 1; o5 >= 0; --o5) t5[o5 + r5] = this[o5 + e5];
        else Uint8Array.prototype.set.call(t5, this.subarray(e5, n5), r5);
        return i5;
      }, u$1$1.prototype.fill = function(t5, r5, e5, n5) {
        if ("string" == typeof t5) {
          if ("string" == typeof r5 ? (n5 = r5, r5 = 0, e5 = this.length) : "string" == typeof e5 && (n5 = e5, e5 = this.length), void 0 !== n5 && "string" != typeof n5) throw new TypeError("encoding must be a string");
          if ("string" == typeof n5 && !u$1$1.isEncoding(n5)) throw new TypeError("Unknown encoding: " + n5);
          if (1 === t5.length) {
            var i5 = t5.charCodeAt(0);
            ("utf8" === n5 && i5 < 128 || "latin1" === n5) && (t5 = i5);
          }
        } else "number" == typeof t5 ? t5 &= 255 : "boolean" == typeof t5 && (t5 = Number(t5));
        if (r5 < 0 || this.length < r5 || this.length < e5) throw new RangeError("Out of range index");
        if (e5 <= r5) return this;
        var o5;
        if (r5 >>>= 0, e5 = void 0 === e5 ? this.length : e5 >>> 0, t5 || (t5 = 0), "number" == typeof t5) for (o5 = r5; o5 < e5; ++o5) this[o5] = t5;
        else {
          var f5 = u$1$1.isBuffer(t5) ? t5 : u$1$1.from(t5, n5), s5 = f5.length;
          if (0 === s5) throw new TypeError('The value "' + t5 + '" is invalid for argument "value"');
          for (o5 = 0; o5 < e5 - r5; ++o5) this[o5 + r5] = f5[o5 % s5];
        }
        return this;
      };
      j2 = /[^+/0-9A-Za-z-_]/g;
      Y2 = function() {
        for (var t5 = new Array(256), r5 = 0; r5 < 16; ++r5) for (var e5 = 16 * r5, n5 = 0; n5 < 16; ++n5) t5[e5 + n5] = "0123456789abcdef"[r5] + "0123456789abcdef"[n5];
        return t5;
      }();
      e$1$1.Buffer;
      e$1$1.INSPECT_MAX_BYTES;
      e$1$1.kMaxLength;
      e4 = {};
      n4 = e$1$1;
      o4 = n4.Buffer;
      o4.from && o4.alloc && o4.allocUnsafe && o4.allocUnsafeSlow ? e4 = n4 : (t4(n4, e4), e4.Buffer = f4), f4.prototype = Object.create(o4.prototype), t4(o4, f4), f4.from = function(r5, e5, n5) {
        if ("number" == typeof r5) throw new TypeError("Argument must not be a number");
        return o4(r5, e5, n5);
      }, f4.alloc = function(r5, e5, n5) {
        if ("number" != typeof r5) throw new TypeError("Argument must be a number");
        var t5 = o4(r5);
        return void 0 !== e5 ? "string" == typeof n5 ? t5.fill(e5, n5) : t5.fill(e5) : t5.fill(0), t5;
      }, f4.allocUnsafe = function(r5) {
        if ("number" != typeof r5) throw new TypeError("Argument must be a number");
        return o4(r5);
      }, f4.allocUnsafeSlow = function(r5) {
        if ("number" != typeof r5) throw new TypeError("Argument must be a number");
        return n4.SlowBuffer(r5);
      };
      u4 = e4;
      e$13 = {};
      s4 = u4.Buffer;
      i4 = s4.isEncoding || function(t5) {
        switch ((t5 = "" + t5) && t5.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      e$13.StringDecoder = a4, a4.prototype.write = function(t5) {
        if (0 === t5.length) return "";
        var e5, s5;
        if (this.lastNeed) {
          if (void 0 === (e5 = this.fillLast(t5))) return "";
          s5 = this.lastNeed, this.lastNeed = 0;
        } else s5 = 0;
        return s5 < t5.length ? e5 ? e5 + this.text(t5, s5) : this.text(t5, s5) : e5 || "";
      }, a4.prototype.end = function(t5) {
        var e5 = t5 && t5.length ? this.write(t5) : "";
        return this.lastNeed ? e5 + "\uFFFD" : e5;
      }, a4.prototype.text = function(t5, e5) {
        var s5 = function(t6, e6, s6) {
          var i6 = e6.length - 1;
          if (i6 < s6) return 0;
          var a5 = r4(e6[i6]);
          if (a5 >= 0) return a5 > 0 && (t6.lastNeed = a5 - 1), a5;
          if (--i6 < s6 || -2 === a5) return 0;
          if ((a5 = r4(e6[i6])) >= 0) return a5 > 0 && (t6.lastNeed = a5 - 2), a5;
          if (--i6 < s6 || -2 === a5) return 0;
          if ((a5 = r4(e6[i6])) >= 0) return a5 > 0 && (2 === a5 ? a5 = 0 : t6.lastNeed = a5 - 3), a5;
          return 0;
        }(this, t5, e5);
        if (!this.lastNeed) return t5.toString("utf8", e5);
        this.lastTotal = s5;
        var i5 = t5.length - (s5 - this.lastNeed);
        return t5.copy(this.lastChar, 0, i5), t5.toString("utf8", e5, i5);
      }, a4.prototype.fillLast = function(t5) {
        if (this.lastNeed <= t5.length) return t5.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t5.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t5.length), this.lastNeed -= t5.length;
      };
      exports$2$1 = {};
      _dewExec$2$1 = false;
      exports$1$1 = {};
      _dewExec$1$1 = false;
      exports$g2 = {};
      _dewExec$g2 = false;
      buffer = dew$g2();
      buffer.Buffer;
      buffer.INSPECT_MAX_BYTES;
      buffer.kMaxLength;
      exports$f2 = {};
      _dewExec$f2 = false;
      exports$e2 = {};
      _dewExec$e2 = false;
      exports$d2 = {};
      _dewExec$d2 = false;
      exports$c2 = {};
      _dewExec$c2 = false;
      exports$b2 = {};
      _dewExec$b2 = false;
      exports$a2 = {};
      _dewExec$a2 = false;
      exports$92 = {};
      _dewExec$92 = false;
      _global$22 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$82 = {};
      _dewExec$82 = false;
      _global$12 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$72 = {};
      _dewExec$72 = false;
      exports$62 = {};
      _dewExec$62 = false;
      exports$52 = {};
      _dewExec$52 = false;
      exports$42 = {};
      _dewExec$42 = false;
      exports$32 = {};
      _dewExec$32 = false;
      _global4 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$25 = {};
      _dewExec$23 = false;
      exports$16 = {};
      _dewExec$15 = false;
      exports10 = {};
      _dewExec9 = false;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-C4rKjYLo.js
  function dew10() {
    if (_dewExec10) return exports11;
    _dewExec10 = true;
    exports11 = exports11 = dew$32();
    exports11.Stream = exports11;
    exports11.Readable = exports11;
    exports11.Writable = dew$82();
    exports11.Duplex = dew$72();
    exports11.Transform = dew$23();
    exports11.PassThrough = dew$15();
    exports11.finished = dew$62();
    exports11.pipeline = dew9();
    return exports11;
  }
  var exports11, _dewExec10;
  var init_chunk_C4rKjYLo = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-C4rKjYLo.js"() {
      init_buffer2();
      init_chunk_B738Er4n();
      exports11 = {};
      _dewExec10 = false;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/https.js
  var https_exports = {};
  __export(https_exports, {
    Agent: () => Agent2,
    ClientRequest: () => ClientRequest2,
    IncomingMessage: () => IncomingMessage2,
    METHODS: () => METHODS2,
    STATUS_CODES: () => STATUS_CODES2,
    default: () => exports12,
    get: () => get2,
    globalAgent: () => globalAgent2,
    request: () => request2
  });
  function dew$53() {
    if (_dewExec$53) return exports$63;
    _dewExec$53 = true;
    exports$63.fetch = isFunction2(_global$32.fetch) && isFunction2(_global$32.ReadableStream);
    exports$63.writableStream = isFunction2(_global$32.WritableStream);
    exports$63.abortController = isFunction2(_global$32.AbortController);
    var xhr;
    function getXHR() {
      if (xhr !== void 0) return xhr;
      if (_global$32.XMLHttpRequest) {
        xhr = new _global$32.XMLHttpRequest();
        try {
          xhr.open("GET", _global$32.XDomainRequest ? "/" : "https://example.com");
        } catch (e5) {
          xhr = null;
        }
      } else {
        xhr = null;
      }
      return xhr;
    }
    function checkTypeSupport(type2) {
      var xhr2 = getXHR();
      if (!xhr2) return false;
      try {
        xhr2.responseType = type2;
        return xhr2.responseType === type2;
      } catch (e5) {
      }
      return false;
    }
    exports$63.arraybuffer = exports$63.fetch || checkTypeSupport("arraybuffer");
    exports$63.msstream = !exports$63.fetch && checkTypeSupport("ms-stream");
    exports$63.mozchunkedarraybuffer = !exports$63.fetch && checkTypeSupport("moz-chunked-arraybuffer");
    exports$63.overrideMimeType = exports$63.fetch || (getXHR() ? isFunction2(getXHR().overrideMimeType) : false);
    function isFunction2(value) {
      return typeof value === "function";
    }
    xhr = null;
    return exports$63;
  }
  function dew$43() {
    if (_dewExec$43) return exports$53;
    _dewExec$43 = true;
    var Buffer3 = buffer.Buffer;
    var process$1 = process3;
    var capability = dew$53();
    var inherits2 = dew$f2();
    var stream = dew10();
    var rStates = exports$53.readyStates = {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    };
    var IncomingMessage3 = exports$53.IncomingMessage = function(xhr, response, mode, resetTimers) {
      var self2 = this || _global$23;
      stream.Readable.call(self2);
      self2._mode = mode;
      self2.headers = {};
      self2.rawHeaders = [];
      self2.trailers = {};
      self2.rawTrailers = [];
      self2.on("end", function() {
        process$1.nextTick(function() {
          self2.emit("close");
        });
      });
      if (mode === "fetch") {
        let read = function() {
          reader.read().then(function(result) {
            if (self2._destroyed) return;
            resetTimers(result.done);
            if (result.done) {
              self2.push(null);
              return;
            }
            self2.push(Buffer3.from(result.value));
            read();
          }).catch(function(err) {
            resetTimers(true);
            if (!self2._destroyed) self2.emit("error", err);
          });
        };
        self2._fetchResponse = response;
        self2.url = response.url;
        self2.statusCode = response.status;
        self2.statusMessage = response.statusText;
        response.headers.forEach(function(header, key) {
          self2.headers[key.toLowerCase()] = header;
          self2.rawHeaders.push(key, header);
        });
        if (capability.writableStream) {
          var writable = new WritableStream({
            write: function(chunk) {
              resetTimers(false);
              return new Promise(function(resolve2, reject) {
                if (self2._destroyed) {
                  reject();
                } else if (self2.push(Buffer3.from(chunk))) {
                  resolve2();
                } else {
                  self2._resumeFetch = resolve2;
                }
              });
            },
            close: function() {
              resetTimers(true);
              if (!self2._destroyed) self2.push(null);
            },
            abort: function(err) {
              resetTimers(true);
              if (!self2._destroyed) self2.emit("error", err);
            }
          });
          try {
            response.body.pipeTo(writable).catch(function(err) {
              resetTimers(true);
              if (!self2._destroyed) self2.emit("error", err);
            });
            return;
          } catch (e5) {
          }
        }
        var reader = response.body.getReader();
        read();
      } else {
        self2._xhr = xhr;
        self2._pos = 0;
        self2.url = xhr.responseURL;
        self2.statusCode = xhr.status;
        self2.statusMessage = xhr.statusText;
        var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
        headers.forEach(function(header) {
          var matches = header.match(/^([^:]+):\s*(.*)/);
          if (matches) {
            var key = matches[1].toLowerCase();
            if (key === "set-cookie") {
              if (self2.headers[key] === void 0) {
                self2.headers[key] = [];
              }
              self2.headers[key].push(matches[2]);
            } else if (self2.headers[key] !== void 0) {
              self2.headers[key] += ", " + matches[2];
            } else {
              self2.headers[key] = matches[2];
            }
            self2.rawHeaders.push(matches[1], matches[2]);
          }
        });
        self2._charset = "x-user-defined";
        if (!capability.overrideMimeType) {
          var mimeType = self2.rawHeaders["mime-type"];
          if (mimeType) {
            var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
            if (charsetMatch) {
              self2._charset = charsetMatch[1].toLowerCase();
            }
          }
          if (!self2._charset) self2._charset = "utf-8";
        }
      }
    };
    inherits2(IncomingMessage3, stream.Readable);
    IncomingMessage3.prototype._read = function() {
      var self2 = this || _global$23;
      var resolve2 = self2._resumeFetch;
      if (resolve2) {
        self2._resumeFetch = null;
        resolve2();
      }
    };
    IncomingMessage3.prototype._onXHRProgress = function(resetTimers) {
      var self2 = this || _global$23;
      var xhr = self2._xhr;
      var response = null;
      switch (self2._mode) {
        case "text":
          response = xhr.responseText;
          if (response.length > self2._pos) {
            var newData = response.substr(self2._pos);
            if (self2._charset === "x-user-defined") {
              var buffer2 = Buffer3.alloc(newData.length);
              for (var i5 = 0; i5 < newData.length; i5++) buffer2[i5] = newData.charCodeAt(i5) & 255;
              self2.push(buffer2);
            } else {
              self2.push(newData, self2._charset);
            }
            self2._pos = response.length;
          }
          break;
        case "arraybuffer":
          if (xhr.readyState !== rStates.DONE || !xhr.response) break;
          response = xhr.response;
          self2.push(Buffer3.from(new Uint8Array(response)));
          break;
        case "moz-chunked-arraybuffer":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING || !response) break;
          self2.push(Buffer3.from(new Uint8Array(response)));
          break;
        case "ms-stream":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING) break;
          var reader = new _global$23.MSStreamReader();
          reader.onprogress = function() {
            if (reader.result.byteLength > self2._pos) {
              self2.push(Buffer3.from(new Uint8Array(reader.result.slice(self2._pos))));
              self2._pos = reader.result.byteLength;
            }
          };
          reader.onload = function() {
            resetTimers(true);
            self2.push(null);
          };
          reader.readAsArrayBuffer(response);
          break;
      }
      if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
        resetTimers(true);
        self2.push(null);
      }
    };
    return exports$53;
  }
  function dew$33() {
    if (_dewExec$33) return exports$43;
    _dewExec$33 = true;
    var Buffer3 = buffer.Buffer;
    var process$1 = process3;
    var capability = dew$53();
    var inherits2 = dew$f2();
    var response = dew$43();
    var stream = dew10();
    var IncomingMessage3 = response.IncomingMessage;
    var rStates = response.readyStates;
    function decideMode(preferBinary, useFetch) {
      if (capability.fetch && useFetch) {
        return "fetch";
      } else if (capability.mozchunkedarraybuffer) {
        return "moz-chunked-arraybuffer";
      } else if (capability.msstream) {
        return "ms-stream";
      } else if (capability.arraybuffer && preferBinary) {
        return "arraybuffer";
      } else {
        return "text";
      }
    }
    var ClientRequest3 = exports$43 = function(opts) {
      var self2 = this || _global$13;
      stream.Writable.call(self2);
      self2._opts = opts;
      self2._body = [];
      self2._headers = {};
      if (opts.auth) self2.setHeader("Authorization", "Basic " + Buffer3.from(opts.auth).toString("base64"));
      Object.keys(opts.headers).forEach(function(name2) {
        self2.setHeader(name2, opts.headers[name2]);
      });
      var preferBinary;
      var useFetch = true;
      if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
        useFetch = false;
        preferBinary = true;
      } else if (opts.mode === "prefer-streaming") {
        preferBinary = false;
      } else if (opts.mode === "allow-wrong-content-type") {
        preferBinary = !capability.overrideMimeType;
      } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
        preferBinary = true;
      } else {
        throw new Error("Invalid value for opts.mode");
      }
      self2._mode = decideMode(preferBinary, useFetch);
      self2._fetchTimer = null;
      self2._socketTimeout = null;
      self2._socketTimer = null;
      self2.on("finish", function() {
        self2._onFinish();
      });
    };
    inherits2(ClientRequest3, stream.Writable);
    ClientRequest3.prototype.setHeader = function(name2, value) {
      var self2 = this || _global$13;
      var lowerName = name2.toLowerCase();
      if (unsafeHeaders.indexOf(lowerName) !== -1) return;
      self2._headers[lowerName] = {
        name: name2,
        value
      };
    };
    ClientRequest3.prototype.getHeader = function(name2) {
      var header = (this || _global$13)._headers[name2.toLowerCase()];
      if (header) return header.value;
      return null;
    };
    ClientRequest3.prototype.removeHeader = function(name2) {
      var self2 = this || _global$13;
      delete self2._headers[name2.toLowerCase()];
    };
    ClientRequest3.prototype._onFinish = function() {
      var self2 = this || _global$13;
      if (self2._destroyed) return;
      var opts = self2._opts;
      if ("timeout" in opts && opts.timeout !== 0) {
        self2.setTimeout(opts.timeout);
      }
      var headersObj = self2._headers;
      var body = null;
      if (opts.method !== "GET" && opts.method !== "HEAD") {
        body = new Blob(self2._body, {
          type: (headersObj["content-type"] || {}).value || ""
        });
      }
      var headersList = [];
      Object.keys(headersObj).forEach(function(keyName) {
        var name2 = headersObj[keyName].name;
        var value = headersObj[keyName].value;
        if (Array.isArray(value)) {
          value.forEach(function(v5) {
            headersList.push([name2, v5]);
          });
        } else {
          headersList.push([name2, value]);
        }
      });
      if (self2._mode === "fetch") {
        var signal = null;
        if (capability.abortController) {
          var controller = new AbortController();
          signal = controller.signal;
          self2._fetchAbortController = controller;
          if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
            self2._fetchTimer = _global$13.setTimeout(function() {
              self2.emit("requestTimeout");
              if (self2._fetchAbortController) self2._fetchAbortController.abort();
            }, opts.requestTimeout);
          }
        }
        _global$13.fetch(self2._opts.url, {
          method: self2._opts.method,
          headers: headersList,
          body: body || void 0,
          mode: "cors",
          credentials: opts.withCredentials ? "include" : "same-origin",
          signal
        }).then(function(response2) {
          self2._fetchResponse = response2;
          self2._resetTimers(false);
          self2._connect();
        }, function(reason) {
          self2._resetTimers(true);
          if (!self2._destroyed) self2.emit("error", reason);
        });
      } else {
        var xhr = self2._xhr = new _global$13.XMLHttpRequest();
        try {
          xhr.open(self2._opts.method, self2._opts.url, true);
        } catch (err) {
          process$1.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
        if ("responseType" in xhr) xhr.responseType = self2._mode;
        if ("withCredentials" in xhr) xhr.withCredentials = !!opts.withCredentials;
        if (self2._mode === "text" && "overrideMimeType" in xhr) xhr.overrideMimeType("text/plain; charset=x-user-defined");
        if ("requestTimeout" in opts) {
          xhr.timeout = opts.requestTimeout;
          xhr.ontimeout = function() {
            self2.emit("requestTimeout");
          };
        }
        headersList.forEach(function(header) {
          xhr.setRequestHeader(header[0], header[1]);
        });
        self2._response = null;
        xhr.onreadystatechange = function() {
          switch (xhr.readyState) {
            case rStates.LOADING:
            case rStates.DONE:
              self2._onXHRProgress();
              break;
          }
        };
        if (self2._mode === "moz-chunked-arraybuffer") {
          xhr.onprogress = function() {
            self2._onXHRProgress();
          };
        }
        xhr.onerror = function() {
          if (self2._destroyed) return;
          self2._resetTimers(true);
          self2.emit("error", new Error("XHR error"));
        };
        try {
          xhr.send(body);
        } catch (err) {
          process$1.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
      }
    };
    function statusValid(xhr) {
      try {
        var status = xhr.status;
        return status !== null && status !== 0;
      } catch (e5) {
        return false;
      }
    }
    ClientRequest3.prototype._onXHRProgress = function() {
      var self2 = this || _global$13;
      self2._resetTimers(false);
      if (!statusValid(self2._xhr) || self2._destroyed) return;
      if (!self2._response) self2._connect();
      self2._response._onXHRProgress(self2._resetTimers.bind(self2));
    };
    ClientRequest3.prototype._connect = function() {
      var self2 = this || _global$13;
      if (self2._destroyed) return;
      self2._response = new IncomingMessage3(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2));
      self2._response.on("error", function(err) {
        self2.emit("error", err);
      });
      self2.emit("response", self2._response);
    };
    ClientRequest3.prototype._write = function(chunk, encoding, cb) {
      var self2 = this || _global$13;
      self2._body.push(chunk);
      cb();
    };
    ClientRequest3.prototype._resetTimers = function(done) {
      var self2 = this || _global$13;
      _global$13.clearTimeout(self2._socketTimer);
      self2._socketTimer = null;
      if (done) {
        _global$13.clearTimeout(self2._fetchTimer);
        self2._fetchTimer = null;
      } else if (self2._socketTimeout) {
        self2._socketTimer = _global$13.setTimeout(function() {
          self2.emit("timeout");
        }, self2._socketTimeout);
      }
    };
    ClientRequest3.prototype.abort = ClientRequest3.prototype.destroy = function(err) {
      var self2 = this || _global$13;
      self2._destroyed = true;
      self2._resetTimers(true);
      if (self2._response) self2._response._destroyed = true;
      if (self2._xhr) self2._xhr.abort();
      else if (self2._fetchAbortController) self2._fetchAbortController.abort();
      if (err) self2.emit("error", err);
    };
    ClientRequest3.prototype.end = function(data, encoding, cb) {
      var self2 = this || _global$13;
      if (typeof data === "function") {
        cb = data;
        data = void 0;
      }
      stream.Writable.prototype.end.call(self2, data, encoding, cb);
    };
    ClientRequest3.prototype.setTimeout = function(timeout, cb) {
      var self2 = this || _global$13;
      if (cb) self2.once("timeout", cb);
      self2._socketTimeout = timeout;
      self2._resetTimers(false);
    };
    ClientRequest3.prototype.flushHeaders = function() {
    };
    ClientRequest3.prototype.setNoDelay = function() {
    };
    ClientRequest3.prototype.setSocketKeepAlive = function() {
    };
    var unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
    return exports$43;
  }
  function dew$24() {
    if (_dewExec$24) return exports$33;
    _dewExec$24 = true;
    exports$33 = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i5 = 0; i5 < arguments.length; i5++) {
        var source = arguments[i5];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
    return exports$33;
  }
  function dew$16() {
    if (_dewExec$16) return exports$26;
    _dewExec$16 = true;
    exports$26 = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    return exports$26;
  }
  function dew$63() {
    if (_dewExec$63) return exports$1$12;
    _dewExec$63 = true;
    var ClientRequest3 = dew$33();
    var response = dew$43();
    var extend = dew$24();
    var statusCodes = dew$16();
    var url = h3;
    var http = exports$1$12;
    http.request = function(opts, cb) {
      if (typeof opts === "string") opts = url.parse(opts);
      else opts = extend(opts);
      var defaultProtocol = _global$42.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
      var protocol = opts.protocol || defaultProtocol;
      var host = opts.hostname || opts.host;
      var port = opts.port;
      var path2 = opts.path || "/";
      if (host && host.indexOf(":") !== -1) host = "[" + host + "]";
      opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path2;
      opts.method = (opts.method || "GET").toUpperCase();
      opts.headers = opts.headers || {};
      var req = new ClientRequest3(opts);
      if (cb) req.on("response", cb);
      return req;
    };
    http.get = function get3(opts, cb) {
      var req = http.request(opts, cb);
      req.end();
      return req;
    };
    http.ClientRequest = ClientRequest3;
    http.IncomingMessage = response.IncomingMessage;
    http.Agent = function() {
    };
    http.Agent.defaultMaxSockets = 4;
    http.globalAgent = new http.Agent();
    http.STATUS_CODES = statusCodes;
    http.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
    return exports$1$12;
  }
  function dew11() {
    if (_dewExec11) return exports$17;
    _dewExec11 = true;
    var http = exports$73;
    var url = h3;
    var https = exports$17;
    for (var key in http) {
      if (http.hasOwnProperty(key)) https[key] = http[key];
    }
    https.request = function(params, cb) {
      params = validateParams(params);
      return http.request.call(this || _global5, params, cb);
    };
    https.get = function(params, cb) {
      params = validateParams(params);
      return http.get.call(this || _global5, params, cb);
    };
    function validateParams(params) {
      if (typeof params === "string") {
        params = url.parse(params);
      }
      if (!params.protocol) {
        params.protocol = "https:";
      }
      if (params.protocol !== "https:") {
        throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
      }
      return params;
    }
    return exports$17;
  }
  var exports$63, _dewExec$53, _global$32, exports$53, _dewExec$43, _global$23, exports$43, _dewExec$33, _global$13, exports$33, _dewExec$24, exports$26, _dewExec$16, exports$1$12, _dewExec$63, _global$42, exports$73, exports$17, _dewExec11, _global5, exports12, Agent2, ClientRequest2, IncomingMessage2, METHODS2, STATUS_CODES2, get2, globalAgent2, request2;
  var init_https = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/https.js"() {
      init_buffer2();
      init_chunk_B738Er4n();
      init_chunk_C4rKjYLo();
      init_chunk_b0rmRow7();
      init_chunk_DHWh_hmB();
      init_chunk_tHuMsdT0();
      init_chunk_D3uu3VYh();
      exports$63 = {};
      _dewExec$53 = false;
      _global$32 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$53 = {};
      _dewExec$43 = false;
      _global$23 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$43 = {};
      _dewExec$33 = false;
      _global$13 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$33 = {};
      _dewExec$24 = false;
      exports$26 = {};
      _dewExec$16 = false;
      exports$1$12 = {};
      _dewExec$63 = false;
      _global$42 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$73 = dew$63();
      exports$73.Agent;
      exports$73.ClientRequest;
      exports$73.IncomingMessage;
      exports$73.METHODS;
      exports$73.STATUS_CODES;
      exports$73.get;
      exports$73.globalAgent;
      exports$73.request;
      exports$17 = {};
      _dewExec11 = false;
      _global5 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports12 = dew11();
      Agent2 = exports12.Agent;
      ClientRequest2 = exports12.ClientRequest;
      IncomingMessage2 = exports12.IncomingMessage;
      METHODS2 = exports12.METHODS;
      STATUS_CODES2 = exports12.STATUS_CODES;
      get2 = exports12.get;
      globalAgent2 = exports12.globalAgent;
      request2 = exports12.request;
    }
  });

  // ../../node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js
  var empty_exports = {};
  __export(empty_exports, {
    default: () => empty_default
  });
  var empty_default;
  var init_empty = __esm({
    "../../node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js"() {
      init_buffer2();
      empty_default = {};
    }
  });

  // ../../node_modules/json-placeholder-replacer/dist/library.js
  var require_library = __commonJS({
    "../../node_modules/json-placeholder-replacer/dist/library.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.JsonPlaceholderReplacer = void 0;
      var defaultDelimiterTags = [
        {
          begin: "{{",
          end: "}}"
        },
        {
          begin: "<<",
          end: ">>"
        }
      ];
      var defaultSeparator = ":";
      var defaultNullishValues = [];
      var JsonPlaceholderReplacer = class {
        constructor(options) {
          this.variablesMap = [];
          this.configuration = this.initializeOptions(options);
          const escapeRegExp = (text) => text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
          this.configuration.delimiterTags = this.configuration.delimiterTags.map((tag) => Object.assign(Object.assign({}, tag), { escapedBeginning: escapeRegExp(tag.begin), escapedEnding: escapeRegExp(tag.end) }));
          const delimiterTagsRegexes = this.configuration.delimiterTags.map((delimiterTag) => `^${delimiterTag.begin}[^${delimiterTag.end}]+${delimiterTag.end}$`).join("|");
          this.delimiterTagsRegex = new RegExp(delimiterTagsRegexes);
        }
        addVariableMap(variableMap) {
          if (typeof variableMap === "string") {
            this.variablesMap.push(JSON.parse(variableMap));
          } else {
            this.variablesMap.push(variableMap);
          }
          return this;
        }
        setVariableMap(...variablesMap) {
          this.variablesMap.length = 0;
          variablesMap.forEach((variableMap) => this.addVariableMap(variableMap));
          return this;
        }
        replace(json) {
          return this.replaceChildren(json, this.variablesMap);
        }
        replaceWith(json, ...variablesMap) {
          return this.replaceChildren(json, variablesMap);
        }
        initializeOptions(options) {
          var _a;
          let delimiterTags = defaultDelimiterTags;
          let defaultValueSeparator = defaultSeparator;
          let nullishValues = defaultNullishValues;
          if (options !== void 0) {
            if (options.delimiterTags !== void 0 && options.delimiterTags.length > 0) {
              delimiterTags = options.delimiterTags;
            }
            if (options.defaultValueSeparator !== void 0) {
              defaultValueSeparator = options.defaultValueSeparator;
            }
            if ((_a = options.nullishValues) === null || _a === void 0 ? void 0 : _a.length) {
              nullishValues = options.nullishValues.map((v5) => JSON.stringify(v5));
            }
          }
          return { defaultValueSeparator, delimiterTags, nullishValues };
        }
        replaceChildren(node, variablesMap) {
          for (const key in node) {
            const attribute = node[key];
            if (typeof attribute === "object") {
              node[key] = this.replaceChildren(attribute, variablesMap);
            } else if (attribute !== void 0) {
              node[key] = this.replaceValue(attribute, variablesMap);
            }
          }
          return node;
        }
        replaceValue(node, variablesMap) {
          const attributeAsString = node.toString();
          const placeHolderIsInsideStringContext = !this.delimiterTagsRegex.test(node);
          const output = this.configuration.delimiterTags.reduce((acc, delimiterTag) => {
            const regex = new RegExp(`(${delimiterTag.escapedBeginning}[^${delimiterTag.escapedEnding}]+${delimiterTag.escapedEnding})`, "g");
            return acc.replace(regex, this.replacer(placeHolderIsInsideStringContext, variablesMap)(delimiterTag));
          }, attributeAsString);
          try {
            if (output === attributeAsString) {
              return node;
            }
            return JSON.parse(output);
          } catch (exc) {
            return output;
          }
        }
        replacer(placeHolderIsInsideStringContext, variablesMap) {
          return (delimiterTag) => (placeHolder) => {
            const { tag, defaultValue } = this.parseTag(placeHolder, delimiterTag);
            const mapCheckResult = this.checkInEveryMap(tag, variablesMap);
            if (mapCheckResult === void 0) {
              if (defaultValue !== void 0) {
                return defaultValue;
              }
              return placeHolder;
            }
            if (!placeHolderIsInsideStringContext) {
              return mapCheckResult;
            }
            const parsed = JSON.parse(mapCheckResult);
            if (typeof parsed === "object") {
              return JSON.stringify(parsed);
            }
            return parsed;
          };
        }
        parseTag(placeHolder, delimiterTag) {
          const path2 = placeHolder.substring(delimiterTag.begin.length, placeHolder.length - delimiterTag.begin.length);
          let tag = path2;
          let defaultValue;
          const defaultValueSeparatorIndex = path2.indexOf(this.configuration.defaultValueSeparator);
          if (defaultValueSeparatorIndex > 0) {
            tag = path2.substring(0, defaultValueSeparatorIndex);
            defaultValue = path2.substring(defaultValueSeparatorIndex + this.configuration.defaultValueSeparator.length);
          }
          return { tag, defaultValue };
        }
        checkInEveryMap(path2, variablesMap) {
          const { nullishValues } = this.configuration;
          let result;
          variablesMap.forEach((map) => {
            let value = this.navigateThroughMap(map, path2);
            if (value !== void 0 && nullishValues.includes(value)) {
              value = void 0;
            }
            result = value || result;
          });
          return result;
        }
        navigateThroughMap(map, path2) {
          if (map === void 0) {
            return;
          }
          const shortCircuit = map[path2];
          if (shortCircuit !== void 0) {
            return JSON.stringify(shortCircuit);
          }
          const keys = path2.split(".");
          const key = keys[0];
          keys.shift();
          return this.navigateThroughMap(map[key], keys.join("."));
        }
      };
      exports21.JsonPlaceholderReplacer = JsonPlaceholderReplacer;
    }
  });

  // ../../node_modules/wot-thing-model-types/schema/tm-json-schema-validation.json
  var require_tm_json_schema_validation = __commonJS({
    "../../node_modules/wot-thing-model-types/schema/tm-json-schema-validation.json"(exports21, module) {
      module.exports = {
        title: "Thing Model",
        version: "1.1-09-November-2023",
        description: "JSON Schema for validating Thing Models. This is automatically generated from the WoT TD Schema.",
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "https://raw.githubusercontent.com/w3c/wot-thing-description/main/validation/tm-json-schema-validation.json",
        definitions: {
          anyUri: {
            type: "string"
          },
          description: {
            type: "string"
          },
          descriptions: {
            type: "object",
            additionalProperties: {
              type: "string"
            },
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          title: {
            type: "string"
          },
          titles: {
            type: "object",
            additionalProperties: {
              type: "string"
            },
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          security: {
            oneOf: [
              {
                type: "array",
                items: {
                  type: "string"
                }
              },
              {
                type: "string"
              }
            ]
          },
          scopes: {
            oneOf: [
              {
                type: "array",
                items: {
                  type: "string"
                }
              },
              {
                type: "string"
              }
            ]
          },
          subprotocol: {
            type: "string",
            examples: [
              "longpoll",
              "websub",
              "sse"
            ]
          },
          "thing-context-td-uri-v1": {
            type: "string",
            const: "https://www.w3.org/2019/wot/td/v1"
          },
          "thing-context-td-uri-v1.1": {
            type: "string",
            const: "https://www.w3.org/2022/wot/td/v1.1"
          },
          "thing-context-td-uri-temp": {
            type: "string",
            const: "http://www.w3.org/ns/td"
          },
          "thing-context": {
            anyOf: [
              {
                $comment: "New context URI with other vocabularies after it but not the old one",
                type: "array",
                items: [
                  {
                    $ref: "#/definitions/thing-context-td-uri-v1.1"
                  }
                ],
                additionalItems: {
                  anyOf: [
                    {
                      $ref: "#/definitions/anyUri"
                    },
                    {
                      type: "object"
                    }
                  ],
                  not: {
                    $ref: "#/definitions/thing-context-td-uri-v1"
                  }
                }
              },
              {
                $comment: "Only the new context URI",
                $ref: "#/definitions/thing-context-td-uri-v1.1"
              },
              {
                $comment: "Old context URI, followed by the new one and possibly other vocabularies. minItems and contains are required since prefixItems does not say all items should be provided",
                type: "array",
                prefixItems: [
                  {
                    $ref: "#/definitions/thing-context-td-uri-v1"
                  },
                  {
                    $ref: "#/definitions/thing-context-td-uri-v1.1"
                  }
                ],
                minItems: 2,
                contains: {
                  $ref: "#/definitions/thing-context-td-uri-v1.1"
                },
                additionalItems: {
                  anyOf: [
                    {
                      $ref: "#/definitions/anyUri"
                    },
                    {
                      type: "object"
                    }
                  ]
                }
              },
              {
                $comment: "Old context URI, followed by possibly other vocabularies. minItems and contains are required since prefixItems does not say all items should be provided",
                type: "array",
                prefixItems: [
                  {
                    $ref: "#/definitions/thing-context-td-uri-v1"
                  }
                ],
                minItems: 1,
                contains: {
                  $ref: "#/definitions/thing-context-td-uri-v1"
                },
                additionalItems: {
                  anyOf: [
                    {
                      $ref: "#/definitions/anyUri"
                    },
                    {
                      type: "object"
                    }
                  ]
                }
              },
              {
                $comment: "Only the old context URI",
                $ref: "#/definitions/thing-context-td-uri-v1"
              }
            ]
          },
          bcp47_string: {
            type: "string",
            pattern: "^(((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(x(-[A-Za-z0-9]{1,8})+))?)|(x(-[A-Za-z0-9]{1,8})+)|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$"
          },
          type_declaration: {
            oneOf: [
              {
                type: "string"
              },
              {
                type: "array",
                items: {
                  type: "string"
                }
              }
            ]
          },
          "dataSchema-type": {
            type: "string",
            anyOf: [
              {
                enum: [
                  "boolean",
                  "integer",
                  "number",
                  "string",
                  "object",
                  "array",
                  "null"
                ]
              },
              {
                $ref: "#/definitions/placeholder-pattern"
              }
            ]
          },
          dataSchema: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              title: {
                $ref: "#/definitions/title"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              titles: {
                $ref: "#/definitions/titles"
              },
              writeOnly: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              readOnly: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              oneOf: {
                type: "array",
                items: {
                  $ref: "#/definitions/dataSchema"
                }
              },
              unit: {
                type: "string"
              },
              enum: {
                anyOf: [
                  {
                    type: "array",
                    minItems: 1,
                    uniqueItems: true
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              format: {
                type: "string"
              },
              const: {},
              default: {},
              contentEncoding: {
                type: "string"
              },
              contentMediaType: {
                type: "string"
              },
              type: {
                $ref: "#/definitions/dataSchema-type"
              },
              items: {
                oneOf: [
                  {
                    $ref: "#/definitions/dataSchema"
                  },
                  {
                    type: "array",
                    items: {
                      $ref: "#/definitions/dataSchema"
                    }
                  }
                ]
              },
              maxItems: {
                anyOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              minItems: {
                anyOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              minimum: {
                anyOf: [
                  {
                    type: "number"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              maximum: {
                anyOf: [
                  {
                    type: "number"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              exclusiveMinimum: {
                type: "number"
              },
              exclusiveMaximum: {
                type: "number"
              },
              minLength: {
                anyOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              maxLength: {
                anyOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              multipleOf: {
                $ref: "#/definitions/multipleOfDefinition"
              },
              properties: {
                additionalProperties: {
                  $ref: "#/definitions/dataSchema"
                }
              },
              required: {
                anyOf: [
                  {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          additionalResponsesDefinition: {
            type: "array",
            items: {
              type: "object",
              properties: {
                contentType: {
                  type: "string"
                },
                schema: {
                  type: "string"
                },
                success: {
                  type: "boolean"
                }
              }
            }
          },
          multipleOfDefinition: {
            anyOf: [
              {
                type: [
                  "integer",
                  "number"
                ],
                exclusiveMinimum: 0
              },
              {
                $ref: "#/definitions/placeholder-pattern"
              }
            ]
          },
          expectedResponse: {
            type: "object",
            properties: {
              contentType: {
                type: "string"
              }
            },
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          form_element_base: {
            type: "object",
            properties: {
              op: {
                oneOf: [
                  {
                    type: "string"
                  },
                  {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  }
                ]
              },
              href: {
                $ref: "#/definitions/anyUri"
              },
              contentType: {
                type: "string"
              },
              contentCoding: {
                type: "string"
              },
              subprotocol: {
                $ref: "#/definitions/subprotocol"
              },
              security: {
                $ref: "#/definitions/security"
              },
              scopes: {
                $ref: "#/definitions/scopes"
              },
              response: {
                $ref: "#/definitions/expectedResponse"
              },
              additionalResponses: {
                $ref: "#/definitions/additionalResponsesDefinition"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          form_element_property: {
            allOf: [
              {
                $ref: "#/definitions/form_element_base"
              }
            ],
            type: "object",
            properties: {
              op: {
                oneOf: [
                  {
                    type: "string",
                    anyOf: [
                      {
                        enum: [
                          "readproperty",
                          "writeproperty",
                          "observeproperty",
                          "unobserveproperty"
                        ]
                      },
                      {
                        $ref: "#/definitions/placeholder-pattern"
                      }
                    ]
                  },
                  {
                    type: "array",
                    items: {
                      type: "string",
                      anyOf: [
                        {
                          enum: [
                            "readproperty",
                            "writeproperty",
                            "observeproperty",
                            "unobserveproperty"
                          ]
                        },
                        {
                          $ref: "#/definitions/placeholder-pattern"
                        }
                      ]
                    },
                    minItems: 1
                  }
                ]
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          form_element_action: {
            allOf: [
              {
                $ref: "#/definitions/form_element_base"
              }
            ],
            type: "object",
            properties: {
              op: {
                oneOf: [
                  {
                    type: "string",
                    anyOf: [
                      {
                        enum: [
                          "invokeaction",
                          "queryaction",
                          "cancelaction"
                        ]
                      },
                      {
                        $ref: "#/definitions/placeholder-pattern"
                      }
                    ]
                  },
                  {
                    type: "array",
                    items: {
                      type: "string",
                      anyOf: [
                        {
                          enum: [
                            "invokeaction",
                            "queryaction",
                            "cancelaction"
                          ]
                        },
                        {
                          $ref: "#/definitions/placeholder-pattern"
                        }
                      ]
                    },
                    minItems: 1
                  }
                ]
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          form_element_event: {
            allOf: [
              {
                $ref: "#/definitions/form_element_base"
              }
            ],
            type: "object",
            properties: {
              op: {
                oneOf: [
                  {
                    type: "string",
                    anyOf: [
                      {
                        enum: [
                          "subscribeevent",
                          "unsubscribeevent"
                        ]
                      },
                      {
                        $ref: "#/definitions/placeholder-pattern"
                      }
                    ]
                  },
                  {
                    type: "array",
                    items: {
                      type: "string",
                      anyOf: [
                        {
                          enum: [
                            "subscribeevent",
                            "unsubscribeevent"
                          ]
                        },
                        {
                          $ref: "#/definitions/placeholder-pattern"
                        }
                      ]
                    },
                    minItems: 1
                  }
                ]
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          form_element_root: {
            allOf: [
              {
                $ref: "#/definitions/form_element_base"
              }
            ],
            type: "object",
            properties: {
              op: {
                oneOf: [
                  {
                    type: "string",
                    anyOf: [
                      {
                        enum: [
                          "readallproperties",
                          "writeallproperties",
                          "readmultipleproperties",
                          "writemultipleproperties",
                          "observeallproperties",
                          "unobserveallproperties",
                          "queryallactions",
                          "subscribeallevents",
                          "unsubscribeallevents"
                        ]
                      },
                      {
                        $ref: "#/definitions/placeholder-pattern"
                      }
                    ]
                  },
                  {
                    type: "array",
                    items: {
                      type: "string",
                      anyOf: [
                        {
                          enum: [
                            "readallproperties",
                            "writeallproperties",
                            "readmultipleproperties",
                            "writemultipleproperties",
                            "observeallproperties",
                            "unobserveallproperties",
                            "queryallactions",
                            "subscribeallevents",
                            "unsubscribeallevents"
                          ]
                        },
                        {
                          $ref: "#/definitions/placeholder-pattern"
                        }
                      ]
                    },
                    minItems: 1
                  }
                ]
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          form: {
            $comment: "This is NOT for validation purposes but for automatic generation of TS types. For more info, please see: https://github.com/w3c/wot-thing-description/pull/1319#issuecomment-994950057",
            oneOf: [
              {
                $ref: "#/definitions/form_element_property"
              },
              {
                $ref: "#/definitions/form_element_action"
              },
              {
                $ref: "#/definitions/form_element_event"
              },
              {
                $ref: "#/definitions/form_element_root"
              }
            ]
          },
          property_element: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              title: {
                $ref: "#/definitions/title"
              },
              titles: {
                $ref: "#/definitions/titles"
              },
              forms: {
                type: "array",
                minItems: 1,
                items: {
                  $ref: "#/definitions/form_element_property"
                }
              },
              uriVariables: {
                type: "object",
                additionalProperties: {
                  $ref: "#/definitions/dataSchema"
                },
                propertyNames: {
                  not: {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                }
              },
              observable: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              writeOnly: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              readOnly: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              oneOf: {
                type: "array",
                items: {
                  $ref: "#/definitions/dataSchema"
                }
              },
              unit: {
                type: "string"
              },
              enum: {
                anyOf: [
                  {
                    type: "array",
                    minItems: 1,
                    uniqueItems: true
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              format: {
                type: "string"
              },
              const: {},
              default: {},
              type: {
                $ref: "#/definitions/dataSchema-type"
              },
              items: {
                oneOf: [
                  {
                    $ref: "#/definitions/dataSchema"
                  },
                  {
                    type: "array",
                    items: {
                      $ref: "#/definitions/dataSchema"
                    }
                  }
                ]
              },
              maxItems: {
                anyOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              minItems: {
                anyOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              minimum: {
                anyOf: [
                  {
                    type: "number"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              maximum: {
                anyOf: [
                  {
                    type: "number"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              exclusiveMinimum: {
                type: "number"
              },
              exclusiveMaximum: {
                type: "number"
              },
              minLength: {
                anyOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              maxLength: {
                anyOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              multipleOf: {
                $ref: "#/definitions/multipleOfDefinition"
              },
              properties: {
                additionalProperties: {
                  $ref: "#/definitions/dataSchema"
                }
              },
              required: {
                anyOf: [
                  {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          action_element: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              title: {
                $ref: "#/definitions/title"
              },
              titles: {
                $ref: "#/definitions/titles"
              },
              forms: {
                type: "array",
                minItems: 1,
                items: {
                  $ref: "#/definitions/form_element_action"
                }
              },
              uriVariables: {
                type: "object",
                additionalProperties: {
                  $ref: "#/definitions/dataSchema"
                },
                propertyNames: {
                  not: {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                }
              },
              input: {
                $ref: "#/definitions/dataSchema"
              },
              output: {
                $ref: "#/definitions/dataSchema"
              },
              safe: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              idempotent: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              synchronous: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          event_element: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              title: {
                $ref: "#/definitions/title"
              },
              titles: {
                $ref: "#/definitions/titles"
              },
              forms: {
                type: "array",
                minItems: 1,
                items: {
                  $ref: "#/definitions/form_element_event"
                }
              },
              uriVariables: {
                type: "object",
                additionalProperties: {
                  $ref: "#/definitions/dataSchema"
                },
                propertyNames: {
                  not: {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                }
              },
              subscription: {
                $ref: "#/definitions/dataSchema"
              },
              data: {
                $ref: "#/definitions/dataSchema"
              },
              dataResponse: {
                $ref: "#/definitions/dataSchema"
              },
              cancellation: {
                $ref: "#/definitions/dataSchema"
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          base_link_element: {
            type: "object",
            properties: {
              href: {
                $ref: "#/definitions/anyUri"
              },
              type: {
                type: "string"
              },
              rel: {
                type: "string"
              },
              anchor: {
                $ref: "#/definitions/anyUri"
              },
              hreflang: {
                anyOf: [
                  {
                    $ref: "#/definitions/bcp47_string"
                  },
                  {
                    type: "array",
                    items: {
                      $ref: "#/definitions/bcp47_string"
                    }
                  }
                ]
              },
              instanceName: {
                type: "string"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          link_element: {
            allOf: [
              {
                $ref: "#/definitions/base_link_element"
              },
              {
                not: {
                  description: "A basic link element should not contain sizes",
                  type: "object",
                  properties: {
                    sizes: {}
                  },
                  required: [
                    "sizes"
                  ]
                }
              },
              {
                not: {
                  description: "A basic link element should not contain icon",
                  properties: {
                    rel: {
                      anyOf: [
                        {
                          enum: [
                            "icon"
                          ]
                        },
                        {
                          $ref: "#/definitions/placeholder-pattern"
                        }
                      ]
                    }
                  },
                  required: [
                    "rel"
                  ]
                }
              }
            ]
          },
          icon_link_element: {
            allOf: [
              {
                $ref: "#/definitions/base_link_element"
              },
              {
                properties: {
                  rel: {
                    const: "icon"
                  },
                  sizes: {
                    type: "string",
                    pattern: "[0-9]*x[0-9]+"
                  }
                },
                required: [
                  "rel"
                ]
              }
            ]
          },
          additionalSecurityScheme: {
            description: "Applies to additional SecuritySchemes not defined in the WoT TD specification.",
            $comment: "Additional SecuritySchemes should always be defined via a context extension, using a prefixed value for the scheme. This prefix (e.g. 'ace', see the example below) must contain at least one character in order to reference a valid JSON-LD context extension.",
            examples: [
              {
                scheme: "ace:ACESecurityScheme",
                "ace:as": "coaps://as.example.com/token",
                "ace:audience": "coaps://rs.example.com",
                "ace:scopes": [
                  "limited",
                  "special"
                ],
                "ace:cnonce": true
              }
            ],
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                pattern: ".+:.*"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          noSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "nosec"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          autoSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "auto"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              }
            },
            not: {
              required: [
                "name"
              ]
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          comboSecurityScheme: {
            oneOf: [
              {
                type: "object",
                properties: {
                  "@type": {
                    $ref: "#/definitions/type_declaration"
                  },
                  description: {
                    $ref: "#/definitions/description"
                  },
                  descriptions: {
                    $ref: "#/definitions/descriptions"
                  },
                  proxy: {
                    $ref: "#/definitions/anyUri"
                  },
                  scheme: {
                    type: "string",
                    anyOf: [
                      {
                        enum: [
                          "combo"
                        ]
                      },
                      {
                        $ref: "#/definitions/placeholder-pattern"
                      }
                    ]
                  },
                  oneOf: {
                    type: "array",
                    minItems: 2,
                    items: {
                      type: "string"
                    }
                  },
                  "tm:ref": {
                    $ref: "#/definitions/tm_ref"
                  }
                },
                additionalProperties: true
              },
              {
                type: "object",
                properties: {
                  "@type": {
                    $ref: "#/definitions/type_declaration"
                  },
                  description: {
                    $ref: "#/definitions/description"
                  },
                  descriptions: {
                    $ref: "#/definitions/descriptions"
                  },
                  proxy: {
                    $ref: "#/definitions/anyUri"
                  },
                  scheme: {
                    type: "string",
                    anyOf: [
                      {
                        enum: [
                          "combo"
                        ]
                      },
                      {
                        $ref: "#/definitions/placeholder-pattern"
                      }
                    ]
                  },
                  allOf: {
                    type: "array",
                    minItems: 2,
                    items: {
                      type: "string"
                    }
                  },
                  "tm:ref": {
                    $ref: "#/definitions/tm_ref"
                  }
                },
                additionalProperties: true
              }
            ]
          },
          basicSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "basic"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              in: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "header",
                      "query",
                      "body",
                      "cookie",
                      "auto"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              name: {
                type: "string"
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          digestSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "digest"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              qop: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "auth",
                      "auth-int"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              in: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "header",
                      "query",
                      "body",
                      "cookie",
                      "auto"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              name: {
                type: "string"
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          apiKeySecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "apikey"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              in: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "header",
                      "query",
                      "body",
                      "cookie",
                      "uri",
                      "auto"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              name: {
                type: "string"
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          bearerSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "bearer"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              authorization: {
                $ref: "#/definitions/anyUri"
              },
              alg: {
                type: "string"
              },
              format: {
                type: "string"
              },
              in: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "header",
                      "query",
                      "body",
                      "cookie",
                      "auto"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              name: {
                type: "string"
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          pskSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "psk"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              identity: {
                type: "string"
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          oAuth2SecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                anyOf: [
                  {
                    enum: [
                      "oauth2"
                    ]
                  },
                  {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                ]
              },
              authorization: {
                $ref: "#/definitions/anyUri"
              },
              token: {
                $ref: "#/definitions/anyUri"
              },
              refresh: {
                $ref: "#/definitions/anyUri"
              },
              scopes: {
                oneOf: [
                  {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  {
                    type: "string"
                  }
                ]
              },
              flow: {
                anyOf: [
                  {
                    type: "string"
                  },
                  {
                    type: "string",
                    anyOf: [
                      {
                        enum: [
                          "code",
                          "client"
                        ]
                      },
                      {
                        $ref: "#/definitions/placeholder-pattern"
                      }
                    ]
                  }
                ]
              },
              "tm:ref": {
                $ref: "#/definitions/tm_ref"
              }
            },
            additionalProperties: true,
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          securityScheme: {
            anyOf: [
              {
                $ref: "#/definitions/noSecurityScheme"
              },
              {
                $ref: "#/definitions/autoSecurityScheme"
              },
              {
                $ref: "#/definitions/comboSecurityScheme"
              },
              {
                $ref: "#/definitions/basicSecurityScheme"
              },
              {
                $ref: "#/definitions/digestSecurityScheme"
              },
              {
                $ref: "#/definitions/apiKeySecurityScheme"
              },
              {
                $ref: "#/definitions/bearerSecurityScheme"
              },
              {
                $ref: "#/definitions/pskSecurityScheme"
              },
              {
                $ref: "#/definitions/oAuth2SecurityScheme"
              },
              {
                $ref: "#/definitions/additionalSecurityScheme"
              }
            ]
          },
          tm_type_declaration: {
            oneOf: [
              {
                type: "string",
                const: "tm:ThingModel"
              },
              {
                type: "array",
                items: {
                  type: "string"
                },
                contains: {
                  const: "tm:ThingModel"
                }
              }
            ]
          },
          "placeholder-pattern": {
            type: "string",
            pattern: "^.*[{]{2}[ -~]+[}]{2}.*$"
          },
          tm_optional: {
            type: "array",
            items: {
              $comment: "this first checks for the general structure of /properties/myProp and then prohibits using / 3 times",
              allOf: [
                {
                  type: "string",
                  pattern: "^((/properties/)|(/actions/)|(/events/))(([^/]))",
                  $comment: "regex tests available at https://regex101.com/r/UgOzrJ/1"
                },
                {
                  not: {
                    type: "string",
                    pattern: "(/)(.*/){2}",
                    $comment: "regex tests available at https://regex101.com/r/r7vB0r/2"
                  }
                }
              ]
            }
          },
          tm_ref: {
            type: "string",
            format: "uri-reference"
          }
        },
        type: "object",
        properties: {
          id: {
            type: "string"
          },
          title: {
            $ref: "#/definitions/title"
          },
          titles: {
            $ref: "#/definitions/titles"
          },
          properties: {
            type: "object",
            additionalProperties: {
              $ref: "#/definitions/property_element"
            },
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          actions: {
            type: "object",
            additionalProperties: {
              $ref: "#/definitions/action_element"
            },
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          events: {
            type: "object",
            additionalProperties: {
              $ref: "#/definitions/event_element"
            },
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          description: {
            $ref: "#/definitions/description"
          },
          descriptions: {
            $ref: "#/definitions/descriptions"
          },
          version: {
            anyOf: [
              {
                type: "object",
                properties: {
                  model: {
                    type: "string"
                  }
                },
                propertyNames: {
                  not: {
                    $ref: "#/definitions/placeholder-pattern"
                  }
                },
                not: {
                  type: "object",
                  properties: {
                    instance: {
                      type: "string"
                    }
                  },
                  required: [
                    "instance"
                  ]
                }
              },
              {
                $ref: "#/definitions/placeholder-pattern"
              }
            ]
          },
          links: {
            type: "array",
            items: {
              oneOf: [
                {
                  $ref: "#/definitions/link_element"
                },
                {
                  $ref: "#/definitions/icon_link_element"
                }
              ]
            }
          },
          forms: {
            type: "array",
            minItems: 1,
            items: {
              $ref: "#/definitions/form_element_root"
            }
          },
          base: {
            $ref: "#/definitions/anyUri"
          },
          securityDefinitions: {
            type: "object",
            minProperties: 1,
            additionalProperties: {
              $ref: "#/definitions/securityScheme"
            },
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          schemaDefinitions: {
            type: "object",
            minProperties: 1,
            additionalProperties: {
              $ref: "#/definitions/dataSchema"
            },
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          support: {
            $ref: "#/definitions/anyUri"
          },
          created: {
            type: "string"
          },
          modified: {
            type: "string"
          },
          profile: {
            oneOf: [
              {
                $ref: "#/definitions/anyUri"
              },
              {
                type: "array",
                minItems: 1,
                items: {
                  $ref: "#/definitions/anyUri"
                }
              }
            ]
          },
          security: {
            oneOf: [
              {
                type: "string"
              },
              {
                type: "array",
                minItems: 1,
                items: {
                  type: "string"
                }
              }
            ]
          },
          uriVariables: {
            type: "object",
            additionalProperties: {
              $ref: "#/definitions/dataSchema"
            },
            propertyNames: {
              not: {
                $ref: "#/definitions/placeholder-pattern"
              }
            }
          },
          "@type": {
            $ref: "#/definitions/tm_type_declaration"
          },
          "@context": {
            $ref: "#/definitions/thing-context"
          },
          "tm:optional": {
            $ref: "#/definitions/tm_optional"
          }
        },
        additionalProperties: true,
        propertyNames: {
          not: {
            $ref: "#/definitions/placeholder-pattern"
          }
        },
        required: [
          "@context",
          "@type"
        ]
      };
    }
  });

  // ../../node_modules/@thingweb/thing-model/dist/src/tm-helpers.js
  var require_tm_helpers = __commonJS({
    "../../node_modules/@thingweb/thing-model/dist/src/tm-helpers.js"(exports21) {
      "use strict";
      init_buffer2();
      var __createBinding = exports21 && exports21.__createBinding || (Object.create ? function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m4, k3);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k3];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o5[k22] = m4[k3];
      });
      var __setModuleDefault = exports21 && exports21.__setModuleDefault || (Object.create ? function(o5, v5) {
        Object.defineProperty(o5, "default", { enumerable: true, value: v5 });
      } : function(o5, v5) {
        o5["default"] = v5;
      });
      var __importStar = exports21 && exports21.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod) if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3)) __createBinding(result, mod, k3);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __awaiter = exports21 && exports21.__awaiter || function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P3 || (P3 = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e5) {
              reject(e5);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e5) {
              reject(e5);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.ThingModelHelpers = void 0;
      var ajv_1 = __importDefault(require_ajv());
      var ajv_formats_1 = __importDefault(require_dist());
      var http = __importStar((init_http(), __toCommonJS(http_exports)));
      var https = __importStar((init_https(), __toCommonJS(https_exports)));
      var fs = __importStar((init_empty(), __toCommonJS(empty_exports)));
      var json_placeholder_replacer_1 = require_library();
      var tm_json_schema_validation_json_1 = __importDefault(require_tm_json_schema_validation());
      var debug_1 = __importDefault(require_browser());
      var namespace = "node-wot:td-tools:thing-model-helpers";
      var logDebug = (0, debug_1.default)(`${namespace}:debug`);
      var logError = (0, debug_1.default)(`${namespace}:error`);
      var tmSchema = tm_json_schema_validation_json_1.default;
      var ajv = new ajv_1.default({ strict: false });
      (0, ajv_formats_1.default)(ajv);
      var ThingModelHelpers = class _ThingModelHelpers {
        constructor(_resolver) {
          this.deps = [];
          this.resolver = void 0;
          if (_resolver) {
            this.resolver = _resolver;
          }
        }
        static isThingModel(_data) {
          if (_data === null || _data === void 0) {
            return false;
          }
          if (!(typeof _data === "object") || Array.isArray(_data)) {
            return false;
          }
          const data = _data;
          if (Array.isArray(data["@type"])) {
            const valid = data["@type"].filter((x3) => x3 === "tm:ThingModel").length > 0;
            if (valid) {
              return true;
            }
          } else if (data["@type"] === "tm:ThingModel") {
            return true;
          }
          if (Object.keys(this.getThingModelRef(data)).length > 0) {
            return true;
          }
          if ("links" in data && Array.isArray(data.links)) {
            const foundTmExtendsRel = data.links.find((link) => link.rel === "tm:extends");
            if (foundTmExtendsRel != null)
              return true;
          }
          if (data.properties !== void 0) {
            if (this.isThingModel(data.properties))
              return true;
          }
          if (data.actions !== void 0) {
            if (this.isThingModel(data.actions))
              return true;
          }
          if (data.events !== void 0) {
            if (this.isThingModel(data.events))
              return true;
          }
          return false;
        }
        static getModelVersion(data) {
          var _a;
          return typeof (data === null || data === void 0 ? void 0 : data.version) === "object" && typeof ((_a = data === null || data === void 0 ? void 0 : data.version) === null || _a === void 0 ? void 0 : _a.model) === "string" ? data.version.model : void 0;
        }
        static validateThingModel(data) {
          var _a;
          const isValid = _ThingModelHelpers.tsSchemaValidator(data);
          let errors;
          if (!isValid) {
            errors = (_a = _ThingModelHelpers.tsSchemaValidator.errors) === null || _a === void 0 ? void 0 : _a.map((o5) => o5.message).join("\n");
          }
          return {
            valid: isValid,
            errors
          };
        }
        getPartialTDs(model, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const extendedModels = yield this._getPartialTDs(model, options);
            const extendedPartialTDs = extendedModels.map((_data) => {
              const data = _data;
              if (data["@type"] instanceof Array) {
                data["@type"] = data["@type"].map((el) => {
                  if (el === "tm:ThingModel") {
                    return "Thing";
                  }
                  return el;
                });
              } else {
                data["@type"] = "Thing";
              }
              return data;
            });
            return extendedPartialTDs;
          });
        }
        fetchModel(uri) {
          return __awaiter(this, void 0, void 0, function* () {
            this.addDependency(uri);
            let tm;
            if (this.resolver) {
              tm = yield this.resolver.fetch(uri);
            } else {
              tm = yield this.localFetch(uri);
            }
            if (!_ThingModelHelpers.isThingModel(tm)) {
              throw new Error(`Data at ${uri} is not a Thing Model`);
            }
            return tm;
          });
        }
        localFetch(uri) {
          const proto = uri.split("://")[0];
          switch (proto) {
            case "file": {
              const file = uri.split("://")[1];
              return new Promise((resolve2, reject) => {
                fs.readFile(file, { encoding: "utf-8" }, function(err, data) {
                  if (!err) {
                    resolve2(JSON.parse(data));
                  } else {
                    reject(err);
                  }
                });
              });
            }
            case "http": {
              return new Promise((resolve2, reject) => {
                http.get(uri, (res) => {
                  if (res.statusCode == null || res.statusCode !== 200) {
                    reject(new Error(`http status code not 200 but ${res.statusCode} for ${uri}`));
                  }
                  res.setEncoding("utf8");
                  let rawData = "";
                  res.on("data", (chunk) => {
                    rawData += chunk;
                  });
                  res.on("end", () => {
                    try {
                      const parsedData = JSON.parse(rawData);
                      logDebug(`https fetched: ${parsedData}`);
                      resolve2(parsedData);
                    } catch (error) {
                      logError(error);
                    }
                  });
                }).on("error", (e5) => {
                  reject(e5);
                });
              });
            }
            case "https": {
              return new Promise((resolve2, reject) => {
                https.get(uri, (res) => {
                  if (res.statusCode == null || res.statusCode !== 200) {
                    reject(new Error(`https status code not 200 but ${res.statusCode} for ${uri}`));
                  }
                  res.setEncoding("utf8");
                  let rawData = "";
                  res.on("data", (chunk) => {
                    rawData += chunk;
                  });
                  res.on("end", () => {
                    try {
                      const parsedData = JSON.parse(rawData);
                      logDebug(`https fetched: ${parsedData}`);
                      resolve2(parsedData);
                    } catch (error) {
                      logError(error);
                    }
                  });
                }).on("error", (e5) => {
                  reject(e5);
                });
              });
            }
            default:
              break;
          }
          return null;
        }
        _getPartialTDs(model, options) {
          return __awaiter(this, void 0, void 0, function* () {
            if (!_ThingModelHelpers.isThingModel(model)) {
              throw new Error(`${model} is not a Thing Model`);
            }
            let isValid = _ThingModelHelpers.validateThingModel(model);
            if (isValid.valid === false || isValid.errors !== void 0) {
              throw new Error(isValid.errors);
            }
            isValid = this.checkPlaceholderMap(model, options === null || options === void 0 ? void 0 : options.map);
            if (isValid.valid === false || isValid.errors !== void 0) {
              throw new Error(isValid.errors);
            }
            const modelInput = yield this.fetchAffordances(model);
            const extendedModels = yield this.composeModel(model, modelInput, options);
            return extendedModels;
          });
        }
        fetchAffordances(data) {
          var _a;
          return __awaiter(this, void 0, void 0, function* () {
            const modelInput = {};
            const extLinks = _ThingModelHelpers.getThingModelLinks(data, "tm:extends");
            if (extLinks.length > 0) {
              modelInput.extends = [];
              for (const s5 of extLinks) {
                let source = yield this.fetchModel(s5.href);
                [source] = yield this._getPartialTDs(source);
                modelInput.extends.push(source);
              }
            }
            const affordanceTypes = ["properties", "actions", "events"];
            modelInput.imports = [];
            for (const affType of affordanceTypes) {
              const affRefs = _ThingModelHelpers.getThingModelRef(data[affType]);
              if (Object.keys(affRefs).length > 0) {
                for (const aff in affRefs) {
                  const affUri = affRefs[aff];
                  const refObj = this.parseTmRef(affUri);
                  if (refObj.uri == null) {
                    throw new Error(`Missing remote path in ${affUri}`);
                  }
                  let source = yield this.fetchModel(refObj.uri);
                  [source] = yield this._getPartialTDs(source);
                  delete data[affType][aff]["tm:ref"];
                  const importedAffordance = (_a = this.getRefAffordance(refObj, source)) !== null && _a !== void 0 ? _a : {};
                  refObj.name = aff;
                  modelInput.imports.push(Object.assign({ affordance: importedAffordance }, refObj));
                }
              }
            }
            const tmLinks = _ThingModelHelpers.getThingModelLinks(data, "tm:submodel");
            if (tmLinks.length > 0) {
              modelInput.submodel = {};
              for (const l5 of tmLinks) {
                const submodel = yield this.fetchModel(l5.href);
                modelInput.submodel[l5.href] = submodel;
              }
            }
            return modelInput;
          });
        }
        composeModel(data, modelObject, options) {
          var _a, _b, _c, _d, _e;
          return __awaiter(this, void 0, void 0, function* () {
            let tmpThingModels = [];
            const title2 = ((_a = data.title) !== null && _a !== void 0 ? _a : "").replace(/ /g, "");
            if (!options) {
              options = {};
            }
            if (options.baseUrl == null) {
              options.baseUrl = ".";
            }
            const newTMHref = this.returnNewTMHref(options.baseUrl, title2);
            const newTDHref = this.returnNewTDHref(options.baseUrl, title2);
            if ("extends" in modelObject) {
              const extendObjs = (_b = modelObject.extends) !== null && _b !== void 0 ? _b : [];
              for (const extendObj of extendObjs) {
                data = _ThingModelHelpers.extendThingModel(extendObj, data);
              }
              data.links = (_c = data.links) === null || _c === void 0 ? void 0 : _c.filter((link) => link.rel !== "tm:extends");
            }
            if ("imports" in modelObject) {
              const importObjs = (_d = modelObject.imports) !== null && _d !== void 0 ? _d : [];
              for (const importedObj of importObjs) {
                data = _ThingModelHelpers.importAffordance(importedObj.type, importedObj.name, importedObj.affordance, data);
              }
            }
            if ("submodel" in modelObject) {
              const submodelObj = modelObject.submodel;
              for (const key in submodelObj) {
                const sub = submodelObj[key];
                if (options.selfComposition === true) {
                  if (!data.links) {
                    throw new Error("You used self composition but links are missing; they are needed to extract the instance name");
                  }
                  const index = data.links.findIndex((el2) => el2.href === key);
                  const el = data.links[index];
                  const instanceName = el.instanceName;
                  if (instanceName == null) {
                    throw new Error("Self composition is not possible without instance names");
                  }
                  const [subPartialTD] = yield this._getPartialTDs(sub, options);
                  const affordanceTypes = ["properties", "actions", "events"];
                  for (const affType of affordanceTypes) {
                    for (const affKey in subPartialTD[affType]) {
                      const newAffKey = `${instanceName}_${affKey}`;
                      if (!(affType in data)) {
                        data[affType] = {};
                      }
                      data[affType][newAffKey] = subPartialTD[affType][affKey];
                    }
                  }
                } else {
                  const subTitle = ((_e = sub.title) !== null && _e !== void 0 ? _e : "").replace(/ /g, "");
                  const subNewHref = this.returnNewTDHref(options.baseUrl, subTitle);
                  if (!sub.links) {
                    sub.links = [];
                  }
                  sub.links.push({
                    rel: "collection",
                    href: newTDHref,
                    type: "application/td+json"
                  });
                  const tmpPartialSubTDs = yield this._getPartialTDs(sub, options);
                  tmpThingModels.push(...tmpPartialSubTDs);
                  data = _ThingModelHelpers.formatSubmodelLink(data, key, subNewHref);
                }
              }
            }
            if (!data.links || options.selfComposition === true) {
              data.links = [];
            }
            data.links.push({
              rel: "type",
              href: newTMHref,
              type: "application/tm+json"
            });
            if ("version" in data) {
              delete data.version;
            }
            if (options.map) {
              data = this.fillPlaceholder(data, options.map);
            }
            tmpThingModels.unshift(data);
            tmpThingModels = tmpThingModels.map((el) => this.fillPlaceholder(el, options === null || options === void 0 ? void 0 : options.map));
            if (this.deps.length > 0) {
              this.removeDependency();
            }
            return tmpThingModels;
          });
        }
        static getThingModelRef(data) {
          const refs = {};
          if (data == null) {
            return refs;
          }
          for (const key in data) {
            for (const key1 in data[key]) {
              if (key1 === "tm:ref") {
                refs[key] = data[key]["tm:ref"];
              }
            }
          }
          return refs;
        }
        static getThingModelLinks(data, type2) {
          let links = [];
          if ("links" in data && Array.isArray(data.links)) {
            links = data.links;
          }
          return links.filter((el) => el.rel === type2);
        }
        static extendThingModel(source, dest) {
          let extendedModel = {};
          const properties = source.properties;
          const actions = source.actions;
          const events = source.events;
          extendedModel = Object.assign(Object.assign({}, source), dest);
          if (properties) {
            if (!extendedModel.properties) {
              extendedModel.properties = {};
            }
            for (const key in properties) {
              if (dest.properties && dest.properties[key] != null) {
                extendedModel.properties[key] = Object.assign(Object.assign({}, properties[key]), dest.properties[key]);
              } else {
                extendedModel.properties[key] = properties[key];
              }
            }
          }
          if (actions) {
            if (!extendedModel.actions) {
              extendedModel.actions = {};
            }
            for (const key in actions) {
              if (dest.actions && key in dest.actions) {
                extendedModel.actions[key] = Object.assign(Object.assign({}, actions[key]), dest.actions[key]);
              } else {
                extendedModel.actions[key] = actions[key];
              }
            }
          }
          if (events) {
            if (!extendedModel.events) {
              extendedModel.events = {};
            }
            for (const key in events) {
              if (dest.events && key in dest.events) {
                extendedModel.events[key] = Object.assign(Object.assign({}, events[key]), dest.events[key]);
              } else {
                extendedModel.events[key] = events[key];
              }
            }
          }
          return extendedModel;
        }
        static importAffordance(affordanceType, affordanceName, source, dest) {
          if (!dest[affordanceType]) {
            dest[affordanceType] = {};
          }
          const d4 = dest[affordanceType][affordanceName];
          dest[affordanceType][affordanceName] = Object.assign(Object.assign({}, source), d4);
          for (const key in dest[affordanceType][affordanceName]) {
            if (dest[affordanceType][affordanceName][key] === void 0) {
              delete dest[affordanceType][affordanceName][key];
            }
          }
          return dest;
        }
        static formatSubmodelLink(source, oldHref, newHref) {
          if (!source.links) {
            throw new Error("Links are missing");
          }
          const index = source.links.findIndex((el2) => el2.href === oldHref);
          if (index === -1) {
            throw new Error("Link not found");
          }
          const el = source.links[index];
          if ("instanceName" in el) {
            delete el.instanceName;
          }
          source.links[index] = Object.assign(Object.assign({}, el), { href: newHref, type: "application/td+json", rel: "item" });
          return source;
        }
        parseTmRef(value) {
          const thingModelUri = value.split("#")[0];
          const affordaceUri = value.split("#")[1];
          const affordaceType = affordaceUri.split("/")[1];
          const affordaceName = affordaceUri.split("/")[2];
          return { uri: thingModelUri, type: affordaceType, name: affordaceName };
        }
        getRefAffordance(obj, thing) {
          const affordanceType = obj.type;
          const affordanceKey = obj.name;
          if (!(affordanceType in thing)) {
            return void 0;
          }
          const affordances = thing[affordanceType];
          if (!(affordanceKey in affordances)) {
            return void 0;
          }
          return affordances[affordanceKey];
        }
        fillPlaceholder(data, map = {}) {
          const placeHolderReplacer = new json_placeholder_replacer_1.JsonPlaceholderReplacer();
          placeHolderReplacer.addVariableMap(map);
          return placeHolderReplacer.replace(data);
        }
        checkPlaceholderMap(model, map = {}) {
          var _a;
          const regex = "{{.*?}}";
          const modelString = JSON.stringify(model);
          let keys = (_a = modelString.match(new RegExp(regex, "g"))) !== null && _a !== void 0 ? _a : [];
          keys = keys.map((el) => el.replace("{{", "").replace("}}", ""));
          let isValid = true;
          let errors;
          if ((keys === null || keys === void 0 ? void 0 : keys.length) > 0 && (map === void 0 || map === null)) {
            isValid = false;
            errors = `No map provided for model ${model.title}`;
          } else if (keys.length > 0) {
            keys.every((key) => {
              if (!(key in map)) {
                errors = `Missing required fields in map for model ${model.title}`;
                isValid = false;
                return false;
              }
              return true;
            });
          }
          return {
            valid: isValid,
            errors
          };
        }
        returnNewTMHref(baseUrl, tdname) {
          return `${baseUrl}/${tdname}.tm.jsonld`;
        }
        returnNewTDHref(baseUrl, tdname) {
          return `${baseUrl}/${tdname}.td.jsonld`;
        }
        addDependency(dep) {
          if (this.deps.indexOf(dep) > -1) {
            throw new Error(`Circular dependency found for ${dep}`);
          }
          this.deps.push(dep);
        }
        removeDependency(dep) {
          if (dep != null) {
            this.deps = this.deps.filter((el) => el !== dep);
          } else {
            this.deps.pop();
          }
        }
      };
      exports21.ThingModelHelpers = ThingModelHelpers;
      ThingModelHelpers.tsSchemaValidator = ajv.compile(tmSchema);
    }
  });

  // ../../node_modules/@thingweb/thing-model/dist/src/resolver-interface.js
  var require_resolver_interface = __commonJS({
    "../../node_modules/@thingweb/thing-model/dist/src/resolver-interface.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
    }
  });

  // ../../node_modules/@thingweb/thing-model/dist/src/thing-model.js
  var require_thing_model = __commonJS({
    "../../node_modules/@thingweb/thing-model/dist/src/thing-model.js"(exports21) {
      "use strict";
      init_buffer2();
      var __createBinding = exports21 && exports21.__createBinding || (Object.create ? function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m4, k3);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k3];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o5[k22] = m4[k3];
      });
      var __exportStar = exports21 && exports21.__exportStar || function(m4, exports22) {
        for (var p5 in m4) if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports22, p5)) __createBinding(exports22, m4, p5);
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      __exportStar(require_tm_helpers(), exports21);
      __exportStar(require_resolver_interface(), exports21);
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/events.js
  var events_exports = {};
  __export(events_exports, {
    EventEmitter: () => EventEmitter,
    default: () => exports13,
    defaultMaxListeners: () => defaultMaxListeners,
    init: () => init,
    listenerCount: () => listenerCount,
    on: () => on2,
    once: () => once2
  });
  function dew12() {
    if (_dewExec12) return exports$18;
    _dewExec12 = true;
    var R3 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R3 && typeof R3.apply === "function" ? R3.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R3 && typeof R3.ownKeys === "function") {
      ReflectOwnKeys = R3.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    exports$18 = EventEmitter2;
    exports$18.once = once3;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners2 = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners2;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners2 = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n5) {
      if (typeof n5 !== "number" || n5 < 0 || NumberIsNaN(n5)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n5 + ".");
      }
      this._maxListeners = n5;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0) return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit2(type2) {
      var args = [];
      for (var i5 = 1; i5 < arguments.length; i5++) args.push(arguments[i5]);
      var doError = type2 === "error";
      var events = this._events;
      if (events !== void 0) doError = doError && events.error === void 0;
      else if (!doError) return false;
      if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type2];
      if (handler === void 0) return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners2 = arrayClone(handler, len);
        for (var i5 = 0; i5 < len; ++i5) ReflectApply(listeners2[i5], this, args);
      }
      return true;
    };
    function _addListener(target, type2, listener, prepend) {
      var m4;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit("newListener", type2, listener.listener ? listener.listener : listener);
          events = target._events;
        }
        existing = events[type2];
      }
      if (existing === void 0) {
        existing = events[type2] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m4 = _getMaxListeners(target);
        if (m4 > 0 && existing.length > m4 && !existing.warned) {
          existing.warned = true;
          var w3 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w3.name = "MaxListenersExceededWarning";
          w3.emitter = target;
          w3.type = type2;
          w3.count = existing.length;
          ProcessEmitWarning(w3);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener2(type2, listener) {
      return _addListener(this, type2, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener2(type2, listener) {
      return _addListener(this, type2, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type2, listener) {
      var state = {
        fired: false,
        wrapFn: void 0,
        target,
        type: type2,
        listener
      };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once4(type2, listener) {
      checkListener(listener);
      this.on(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener2(type2, listener) {
      checkListener(listener);
      this.prependListener(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener2(type2, listener) {
      var list, events, position, i5, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0) return this;
      list = events[type2];
      if (list === void 0) return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type2];
          if (events.removeListener) this.emit("removeListener", type2, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i5 = list.length - 1; i5 >= 0; i5--) {
          if (list[i5] === listener || list[i5].listener === listener) {
            originalListener = list[i5].listener;
            position = i5;
            break;
          }
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1) events[type2] = list[0];
        if (events.removeListener !== void 0) this.emit("removeListener", type2, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(type2) {
      var listeners2, events, i5;
      events = this._events;
      if (events === void 0) return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type2] !== void 0) {
          if (--this._eventsCount === 0) this._events = /* @__PURE__ */ Object.create(null);
          else delete events[type2];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i5 = 0; i5 < keys.length; ++i5) {
          key = keys[i5];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type2];
      if (typeof listeners2 === "function") {
        this.removeListener(type2, listeners2);
      } else if (listeners2 !== void 0) {
        for (i5 = listeners2.length - 1; i5 >= 0; i5--) {
          this.removeListener(type2, listeners2[i5]);
        }
      }
      return this;
    };
    function _listeners(target, type2, unwrap) {
      var events = target._events;
      if (events === void 0) return [];
      var evlistener = events[type2];
      if (evlistener === void 0) return [];
      if (typeof evlistener === "function") return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners2(type2) {
      return _listeners(this, type2, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type2) {
      return _listeners(this, type2, false);
    };
    EventEmitter2.listenerCount = function(emitter, type2) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type2);
      } else {
        return listenerCount2.call(emitter, type2);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount2;
    function listenerCount2(type2) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type2];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n5) {
      var copy = new Array(n5);
      for (var i5 = 0; i5 < n5; ++i5) copy[i5] = arr[i5];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++) list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i5 = 0; i5 < ret.length; ++i5) {
        ret[i5] = arr[i5].listener || arr[i5];
      }
      return ret;
    }
    function once3(emitter, name2) {
      return new Promise(function(resolve2, reject) {
        function errorListener(err) {
          emitter.removeListener(name2, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve2([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name2, resolver, {
          once: true
        });
        if (name2 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
          });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name2, listener);
        } else {
          emitter.on(name2, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name2, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name2, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
    return exports$18;
  }
  var exports$18, _dewExec12, exports13, EventEmitter, defaultMaxListeners, init, listenerCount, on2, once2;
  var init_events = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/events.js"() {
      init_buffer2();
      exports$18 = {};
      _dewExec12 = false;
      exports13 = dew12();
      exports13["once"];
      exports13.once = function(emitter, event) {
        return new Promise((resolve2, reject) => {
          function eventListener(...args) {
            if (errorListener !== void 0) {
              emitter.removeListener("error", errorListener);
            }
            resolve2(args);
          }
          let errorListener;
          if (event !== "error") {
            errorListener = (err) => {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          emitter.once(event, eventListener);
        });
      };
      exports13.on = function(emitter, event) {
        const unconsumedEventValues = [];
        const unconsumedPromises = [];
        let error = null;
        let finished2 = false;
        const iterator = {
          async next() {
            const value = unconsumedEventValues.shift();
            if (value) {
              return createIterResult(value, false);
            }
            if (error) {
              const p5 = Promise.reject(error);
              error = null;
              return p5;
            }
            if (finished2) {
              return createIterResult(void 0, true);
            }
            return new Promise((resolve2, reject) => unconsumedPromises.push({ resolve: resolve2, reject }));
          },
          async return() {
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
            finished2 = true;
            for (const promise of unconsumedPromises) {
              promise.resolve(createIterResult(void 0, true));
            }
            return createIterResult(void 0, true);
          },
          throw(err) {
            error = err;
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
        emitter.on(event, eventHandler);
        emitter.on("error", errorHandler);
        return iterator;
        function eventHandler(...args) {
          const promise = unconsumedPromises.shift();
          if (promise) {
            promise.resolve(createIterResult(args, false));
          } else {
            unconsumedEventValues.push(args);
          }
        }
        function errorHandler(err) {
          finished2 = true;
          const toError = unconsumedPromises.shift();
          if (toError) {
            toError.reject(err);
          } else {
            error = err;
          }
          iterator.return();
        }
      };
      ({
        EventEmitter,
        defaultMaxListeners,
        init,
        listenerCount,
        on: on2,
        once: once2
      } = exports13);
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-DtcTpLWz.js
  function dew$k2() {
    if (_dewExec$k2) return exports$k2;
    _dewExec$k2 = true;
    exports$k2 = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
    return exports$k2;
  }
  function dew$j2() {
    if (_dewExec$j2) return exports$j2;
    _dewExec$j2 = true;
    exports$j2 = Error;
    return exports$j2;
  }
  function dew$i2() {
    if (_dewExec$i2) return exports$i2;
    _dewExec$i2 = true;
    exports$i2 = EvalError;
    return exports$i2;
  }
  function dew$h2() {
    if (_dewExec$h2) return exports$h2;
    _dewExec$h2 = true;
    exports$h2 = RangeError;
    return exports$h2;
  }
  function dew$g3() {
    if (_dewExec$g3) return exports$g3;
    _dewExec$g3 = true;
    exports$g3 = ReferenceError;
    return exports$g3;
  }
  function dew$f3() {
    if (_dewExec$f3) return exports$f3;
    _dewExec$f3 = true;
    exports$f3 = SyntaxError;
    return exports$f3;
  }
  function dew$e3() {
    if (_dewExec$e3) return exports$e3;
    _dewExec$e3 = true;
    exports$e3 = TypeError;
    return exports$e3;
  }
  function dew$d3() {
    if (_dewExec$d3) return exports$d3;
    _dewExec$d3 = true;
    exports$d3 = URIError;
    return exports$d3;
  }
  function dew$c3() {
    if (_dewExec$c3) return exports$c3;
    _dewExec$c3 = true;
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = dew$k2();
    exports$c3 = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
    return exports$c3;
  }
  function dew$b3() {
    if (_dewExec$b3) return exports$b3;
    _dewExec$b3 = true;
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    exports$b3 = function hasProto() {
      return {
        __proto__: test
      }.foo === test.foo && !(test instanceof $Object);
    };
    return exports$b3;
  }
  function dew$a3() {
    if (_dewExec$a3) return exports$a3;
    _dewExec$a3 = true;
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a5, b4) {
      var arr = [];
      for (var i5 = 0; i5 < a5.length; i5 += 1) {
        arr[i5] = a5[i5];
      }
      for (var j3 = 0; j3 < b4.length; j3 += 1) {
        arr[j3 + a5.length] = b4[j3];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i5 = offset, j3 = 0; i5 < arrLike.length; i5 += 1, j3 += 1) {
        arr[j3] = arrLike[i5];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i5 = 0; i5 < arr.length; i5 += 1) {
        str += arr[i5];
        if (i5 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    exports$a3 = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, concatty(args, arguments));
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(that, concatty(args, arguments));
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i5 = 0; i5 < boundLength; i5++) {
        boundArgs[i5] = "$" + i5;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
    return exports$a3;
  }
  function dew$93() {
    if (_dewExec$93) return exports$93;
    _dewExec$93 = true;
    var implementation = dew$a3();
    exports$93 = Function.prototype.bind || implementation;
    return exports$93;
  }
  function dew$83() {
    if (_dewExec$83) return exports$83;
    _dewExec$83 = true;
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = dew$93();
    exports$83 = bind.call(call, $hasOwn);
    return exports$83;
  }
  function dew$73() {
    if (_dewExec$73) return exports$74;
    _dewExec$73 = true;
    var undefined$1;
    var $Error = dew$j2();
    var $EvalError = dew$i2();
    var $RangeError = dew$h2();
    var $ReferenceError = dew$g3();
    var $SyntaxError = dew$f3();
    var $TypeError = dew$e3();
    var $URIError = dew$d3();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e5) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e5) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = dew$c3()();
    var hasProto = dew$b3()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x3) {
      return x3.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
      "%AsyncFromSyncIteratorPrototype%": undefined$1,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
      "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
      "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
      "%Symbol%": hasSymbols ? Symbol : undefined$1,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e5) {
        var errorProto = getProto(getProto(e5));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var doEval = function doEval2(name2) {
      var value;
      if (name2 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = dew$93();
    var hasOwn = dew$83();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    exports$74 = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name2) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i5 = 1, isOwn = true; i5 < parts.length; i5 += 1) {
        var part = parts[i5];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void undefined$1;
          }
          if ($gOPD && i5 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
    return exports$74;
  }
  function dew$64() {
    if (_dewExec$64) return exports$64;
    _dewExec$64 = true;
    var GetIntrinsic = dew$73();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", {
          value: 1
        });
      } catch (e5) {
        $defineProperty = false;
      }
    }
    exports$64 = $defineProperty;
    return exports$64;
  }
  function dew$54() {
    if (_dewExec$54) return exports$54;
    _dewExec$54 = true;
    var GetIntrinsic = dew$73();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e5) {
        $gOPD = null;
      }
    }
    exports$54 = $gOPD;
    return exports$54;
  }
  function dew$44() {
    if (_dewExec$44) return exports$44;
    _dewExec$44 = true;
    var $defineProperty = dew$64();
    var $SyntaxError = dew$f3();
    var $TypeError = dew$e3();
    var gopd = dew$54();
    exports$44 = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
    return exports$44;
  }
  function dew$34() {
    if (_dewExec$34) return exports$34;
    _dewExec$34 = true;
    var $defineProperty = dew$64();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", {
          value: 1
        }).length !== 1;
      } catch (e5) {
        return true;
      }
    };
    exports$34 = hasPropertyDescriptors;
    return exports$34;
  }
  function dew$25() {
    if (_dewExec$25) return exports$27;
    _dewExec$25 = true;
    var GetIntrinsic = dew$73();
    var define2 = dew$44();
    var hasDescriptors = dew$34()();
    var gOPD = dew$54();
    var $TypeError = dew$e3();
    var $floor = GetIntrinsic("%Math.floor%");
    exports$27 = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
    return exports$27;
  }
  function dew$17() {
    if (_dewExec$17) return exports$19;
    _dewExec$17 = true;
    var bind = dew$93();
    var GetIntrinsic = dew$73();
    var setFunctionLength = dew$25();
    var $TypeError = dew$e3();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = dew$64();
    var $max = GetIntrinsic("%Math.max%");
    exports$19 = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(exports$19, "apply", {
        value: applyBind
      });
    } else {
      exports$19.apply = applyBind;
    }
    return exports$19;
  }
  function dew13() {
    if (_dewExec13) return exports14;
    _dewExec13 = true;
    var GetIntrinsic = dew$73();
    var callBind = dew$17();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    exports14 = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
    return exports14;
  }
  var exports$k2, _dewExec$k2, exports$j2, _dewExec$j2, exports$i2, _dewExec$i2, exports$h2, _dewExec$h2, exports$g3, _dewExec$g3, exports$f3, _dewExec$f3, exports$e3, _dewExec$e3, exports$d3, _dewExec$d3, exports$c3, _dewExec$c3, exports$b3, _dewExec$b3, exports$a3, _dewExec$a3, exports$93, _dewExec$93, exports$83, _dewExec$83, exports$74, _dewExec$73, exports$64, _dewExec$64, exports$54, _dewExec$54, exports$44, _dewExec$44, exports$34, _dewExec$34, exports$27, _dewExec$25, exports$19, _dewExec$17, exports14, _dewExec13;
  var init_chunk_DtcTpLWz = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-DtcTpLWz.js"() {
      init_buffer2();
      exports$k2 = {};
      _dewExec$k2 = false;
      exports$j2 = {};
      _dewExec$j2 = false;
      exports$i2 = {};
      _dewExec$i2 = false;
      exports$h2 = {};
      _dewExec$h2 = false;
      exports$g3 = {};
      _dewExec$g3 = false;
      exports$f3 = {};
      _dewExec$f3 = false;
      exports$e3 = {};
      _dewExec$e3 = false;
      exports$d3 = {};
      _dewExec$d3 = false;
      exports$c3 = {};
      _dewExec$c3 = false;
      exports$b3 = {};
      _dewExec$b3 = false;
      exports$a3 = {};
      _dewExec$a3 = false;
      exports$93 = {};
      _dewExec$93 = false;
      exports$83 = {};
      _dewExec$83 = false;
      exports$74 = {};
      _dewExec$73 = false;
      exports$64 = {};
      _dewExec$64 = false;
      exports$54 = {};
      _dewExec$54 = false;
      exports$44 = {};
      _dewExec$44 = false;
      exports$34 = {};
      _dewExec$34 = false;
      exports$27 = {};
      _dewExec$25 = false;
      exports$19 = {};
      _dewExec$17 = false;
      exports14 = {};
      _dewExec13 = false;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/util.js
  var util_exports = {};
  __export(util_exports, {
    TextDecoder: () => TextDecoder2,
    TextEncoder: () => TextEncoder,
    _extend: () => _extend,
    callbackify: () => callbackify,
    debuglog: () => debuglog,
    default: () => exports15,
    deprecate: () => deprecate,
    format: () => format,
    inherits: () => inherits,
    inspect: () => inspect,
    isArray: () => isArray,
    isBoolean: () => isBoolean,
    isBuffer: () => isBuffer,
    isDate: () => isDate,
    isError: () => isError,
    isFunction: () => isFunction,
    isNull: () => isNull,
    isNullOrUndefined: () => isNullOrUndefined,
    isNumber: () => isNumber,
    isObject: () => isObject,
    isPrimitive: () => isPrimitive,
    isRegExp: () => isRegExp,
    isString: () => isString,
    isSymbol: () => isSymbol,
    isUndefined: () => isUndefined,
    log: () => log,
    promisify: () => promisify3,
    types: () => types
  });
  function dew$b4() {
    if (_dewExec$b4) return exports$c4;
    _dewExec$b4 = true;
    var hasSymbols = dew$k2();
    exports$c4 = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
    return exports$c4;
  }
  function dew$a4() {
    if (_dewExec$a4) return exports$b4;
    _dewExec$a4 = true;
    var hasToStringTag = dew$b4()();
    var callBound = dew13();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    exports$b4 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    return exports$b4;
  }
  function dew$94() {
    if (_dewExec$94) return exports$a4;
    _dewExec$94 = true;
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = dew$b4()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e5) {
      }
    };
    var GeneratorFunction;
    exports$a4 = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
    return exports$a4;
  }
  function dew$84() {
    if (_dewExec$84) return exports$94;
    _dewExec$84 = true;
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_3) {
        if (_3 !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e5) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e5) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      var all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e5) {
            }
          }
          return false;
        };
      }
    }
    exports$94 = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e5) {
        if (e5 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
    return exports$94;
  }
  function dew$74() {
    if (_dewExec$74) return exports$84;
    _dewExec$74 = true;
    var isCallable = dew$84();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i5 = 0, len = array.length; i5 < len; i5++) {
        if (hasOwnProperty.call(array, i5)) {
          if (receiver == null) {
            iterator(array[i5], i5, array);
          } else {
            iterator.call(receiver, array[i5], i5, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i5 = 0, len = string.length; i5 < len; i5++) {
        if (receiver == null) {
          iterator(string.charAt(i5), i5, string);
        } else {
          iterator.call(receiver, string.charAt(i5), i5, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k3 in object) {
        if (hasOwnProperty.call(object, k3)) {
          if (receiver == null) {
            iterator(object[k3], k3, object);
          } else {
            iterator.call(receiver, object[k3], k3, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    exports$84 = forEach;
    return exports$84;
  }
  function dew$65() {
    if (_dewExec$65) return exports$75;
    _dewExec$65 = true;
    exports$75 = ["Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"];
    return exports$75;
  }
  function dew$55() {
    if (_dewExec$55) return exports$65;
    _dewExec$55 = true;
    var possibleNames = dew$65();
    var g4 = typeof globalThis === "undefined" ? _global$24 : globalThis;
    exports$65 = function availableTypedArrays() {
      var out = [];
      for (var i5 = 0; i5 < possibleNames.length; i5++) {
        if (typeof g4[possibleNames[i5]] === "function") {
          out[out.length] = possibleNames[i5];
        }
      }
      return out;
    };
    return exports$65;
  }
  function dew$45() {
    if (_dewExec$45) return exports$55;
    _dewExec$45 = true;
    var forEach = dew$74();
    var availableTypedArrays = dew$55();
    var callBind = dew$17();
    var callBound = dew13();
    var gOPD = dew$54();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = dew$b4()();
    var g4 = typeof globalThis === "undefined" ? _global$14 : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var getPrototypeOf = Object.getPrototypeOf;
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i5 = 0; i5 < array.length; i5 += 1) {
        if (array[i5] === value) {
          return i5;
        }
      }
      return -1;
    };
    var cache = {
      __proto__: null
    };
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g4[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g4[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache["$" + typedArray] = callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = $slice(typedArray, 1);
              }
            } catch (e5) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name2) {
          if (!found) {
            try {
              getter(value);
              found = $slice(name2, 1);
            } catch (e5) {
            }
          }
        }
      );
      return found;
    };
    exports$55 = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
    return exports$55;
  }
  function dew$35() {
    if (_dewExec$35) return exports$45;
    _dewExec$35 = true;
    var whichTypedArray = dew$45();
    exports$45 = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
    return exports$45;
  }
  function dew$26() {
    if (_dewExec$26) return exports$35;
    _dewExec$26 = true;
    var isArgumentsObject = dew$a4();
    var isGeneratorFunction = dew$94();
    var whichTypedArray = dew$45();
    var isTypedArray = dew$35();
    function uncurryThis(f5) {
      return f5.call.bind(f5);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e5) {
        return false;
      }
    }
    exports$35.isArgumentsObject = isArgumentsObject;
    exports$35.isGeneratorFunction = isGeneratorFunction;
    exports$35.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports$35.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports$35.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports$35.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports$35.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports$35.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports$35.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports$35.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports$35.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports$35.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports$35.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports$35.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports$35.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports$35.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports$35.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports$35.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports$35.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports$35.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports$35.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports$35.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports$35.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports$35.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports$35.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports$35.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports$35.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports$35.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports$35.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports$35.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports$35.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports$35.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports$35.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports$35.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports$35.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports$35, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
    return exports$35;
  }
  function dew$18() {
    if (_dewExec$18) return exports$28;
    _dewExec$18 = true;
    exports$28 = function isBuffer2(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
    return exports$28;
  }
  function dew14() {
    if (_dewExec14) return exports$110;
    _dewExec14 = true;
    var process$1 = process2;
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i5 = 0; i5 < keys.length; i5++) {
        descriptors[keys[i5]] = Object.getOwnPropertyDescriptor(obj, keys[i5]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports$110.format = function(f5) {
      if (!isString2(f5)) {
        var objects = [];
        for (var i5 = 0; i5 < arguments.length; i5++) {
          objects.push(inspect2(arguments[i5]));
        }
        return objects.join(" ");
      }
      var i5 = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f5).replace(formatRegExp, function(x4) {
        if (x4 === "%%") return "%";
        if (i5 >= len) return x4;
        switch (x4) {
          case "%s":
            return String(args[i5++]);
          case "%d":
            return Number(args[i5++]);
          case "%j":
            try {
              return JSON.stringify(args[i5++]);
            } catch (_3) {
              return "[Circular]";
            }
          default:
            return x4;
        }
      });
      for (var x3 = args[i5]; i5 < len; x3 = args[++i5]) {
        if (isNull2(x3) || !isObject2(x3)) {
          str += " " + x3;
        } else {
          str += " " + inspect2(x3);
        }
      }
      return str;
    };
    exports$110.deprecate = function(fn, msg) {
      if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
        return fn;
      }
      if (typeof process$1 === "undefined") {
        return function() {
          return exports$110.deprecate(fn, msg).apply(this || _global6, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process$1.throwDeprecation) {
            throw new Error(msg);
          } else if (process$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this || _global6, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var debugEnv = process$1.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports$110.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid2 = process$1.pid;
          debugs[set] = function() {
            var msg = exports$110.format.apply(exports$110, arguments);
            console.error("%s %d: %s", set, pid2, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect2(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean2(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports$110._extend(ctx, opts);
      }
      if (isUndefined2(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined2(ctx.depth)) ctx.depth = 2;
      if (isUndefined2(ctx.colors)) ctx.colors = false;
      if (isUndefined2(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports$110.inspect = inspect2;
    inspect2.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect2.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect2.styles[styleType];
      if (style) {
        return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports$110.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString2(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError2(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction2(value)) {
          var name2 = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name2 + "]", "special");
        }
        if (isRegExp2(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate2(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError2(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray2(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction2(value)) {
        var n5 = value.name ? ": " + value.name : "";
        base = " [Function" + n5 + "]";
      }
      if (isRegExp2(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate2(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError2(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp2(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined2(value)) return ctx.stylize("undefined", "undefined");
      if (isString2(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber2(value)) return ctx.stylize("" + value, "number");
      if (isBoolean2(value)) return ctx.stylize("" + value, "boolean");
      if (isNull2(value)) return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i5 = 0, l5 = value.length; i5 < l5; ++i5) {
        if (hasOwnProperty(value, String(i5))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i5), true));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name2, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name2 = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull2(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined2(name2)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name2 = JSON.stringify("" + key);
        if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name2 = name2.slice(1, -1);
          name2 = ctx.stylize(name2, "name");
        } else {
          name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name2 = ctx.stylize(name2, "string");
        }
      }
      return name2 + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports$110.types = dew$26();
    function isArray2(ar) {
      return Array.isArray(ar);
    }
    exports$110.isArray = isArray2;
    function isBoolean2(arg) {
      return typeof arg === "boolean";
    }
    exports$110.isBoolean = isBoolean2;
    function isNull2(arg) {
      return arg === null;
    }
    exports$110.isNull = isNull2;
    function isNullOrUndefined2(arg) {
      return arg == null;
    }
    exports$110.isNullOrUndefined = isNullOrUndefined2;
    function isNumber2(arg) {
      return typeof arg === "number";
    }
    exports$110.isNumber = isNumber2;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports$110.isString = isString2;
    function isSymbol2(arg) {
      return typeof arg === "symbol";
    }
    exports$110.isSymbol = isSymbol2;
    function isUndefined2(arg) {
      return arg === void 0;
    }
    exports$110.isUndefined = isUndefined2;
    function isRegExp2(re2) {
      return isObject2(re2) && objectToString(re2) === "[object RegExp]";
    }
    exports$110.isRegExp = isRegExp2;
    exports$110.types.isRegExp = isRegExp2;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports$110.isObject = isObject2;
    function isDate2(d4) {
      return isObject2(d4) && objectToString(d4) === "[object Date]";
    }
    exports$110.isDate = isDate2;
    exports$110.types.isDate = isDate2;
    function isError2(e5) {
      return isObject2(e5) && (objectToString(e5) === "[object Error]" || e5 instanceof Error);
    }
    exports$110.isError = isError2;
    exports$110.types.isNativeError = isError2;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports$110.isFunction = isFunction2;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports$110.isPrimitive = isPrimitive2;
    exports$110.isBuffer = dew$18();
    function objectToString(o5) {
      return Object.prototype.toString.call(o5);
    }
    function pad(n5) {
      return n5 < 10 ? "0" + n5.toString(10) : n5.toString(10);
    }
    var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function timestamp() {
      var d4 = /* @__PURE__ */ new Date();
      var time = [pad(d4.getHours()), pad(d4.getMinutes()), pad(d4.getSeconds())].join(":");
      return [d4.getDate(), months[d4.getMonth()], time].join(" ");
    }
    exports$110.log = function() {
      console.log("%s - %s", timestamp(), exports$110.format.apply(exports$110, arguments));
    };
    exports$110.inherits = dew3();
    exports$110._extend = function(origin, add) {
      if (!add || !isObject2(add)) return origin;
      var keys = Object.keys(add);
      var i5 = keys.length;
      while (i5--) {
        origin[keys[i5]] = add[keys[i5]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports$110.promisify = function promisify4(original) {
      if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve2, reject) {
          promiseResolve = resolve2;
          promiseReject = reject;
        });
        var args = [];
        for (var i5 = 0; i5 < arguments.length; i5++) {
          args.push(arguments[i5]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this || _global6, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
    };
    exports$110.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify2(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i5 = 0; i5 < arguments.length; i5++) {
          args.push(arguments[i5]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this || _global6;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this || _global6, args).then(function(ret) {
          process$1.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
          process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }
    exports$110.callbackify = callbackify2;
    return exports$110;
  }
  var exports$c4, _dewExec$b4, exports$b4, _dewExec$a4, exports$a4, _dewExec$94, exports$94, _dewExec$84, exports$84, _dewExec$74, exports$75, _dewExec$65, exports$65, _dewExec$55, _global$24, exports$55, _dewExec$45, _global$14, exports$45, _dewExec$35, exports$35, _dewExec$26, exports$28, _dewExec$18, exports$110, _dewExec14, _global6, exports15, _extend, callbackify, debuglog, deprecate, format, inherits, inspect, isArray, isBoolean, isBuffer, isDate, isError, isFunction, isNull, isNullOrUndefined, isNumber, isObject, isPrimitive, isRegExp, isString, isSymbol, isUndefined, log, promisify3, types, TextEncoder, TextDecoder2;
  var init_util = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/util.js"() {
      init_buffer2();
      init_chunk_DtcTpLWz();
      init_chunk_CkFCi_G1();
      init_chunk_DEMDiNwt();
      exports$c4 = {};
      _dewExec$b4 = false;
      exports$b4 = {};
      _dewExec$a4 = false;
      exports$a4 = {};
      _dewExec$94 = false;
      exports$94 = {};
      _dewExec$84 = false;
      exports$84 = {};
      _dewExec$74 = false;
      exports$75 = {};
      _dewExec$65 = false;
      exports$65 = {};
      _dewExec$55 = false;
      _global$24 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$55 = {};
      _dewExec$45 = false;
      _global$14 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$45 = {};
      _dewExec$35 = false;
      exports$35 = {};
      _dewExec$26 = false;
      exports$28 = {};
      _dewExec$18 = false;
      exports$110 = {};
      _dewExec14 = false;
      _global6 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports15 = dew14();
      exports15["format"];
      exports15["deprecate"];
      exports15["debuglog"];
      exports15["inspect"];
      exports15["types"];
      exports15["isArray"];
      exports15["isBoolean"];
      exports15["isNull"];
      exports15["isNullOrUndefined"];
      exports15["isNumber"];
      exports15["isString"];
      exports15["isSymbol"];
      exports15["isUndefined"];
      exports15["isRegExp"];
      exports15["isObject"];
      exports15["isDate"];
      exports15["isError"];
      exports15["isFunction"];
      exports15["isPrimitive"];
      exports15["isBuffer"];
      exports15["log"];
      exports15["inherits"];
      exports15["_extend"];
      exports15["promisify"];
      exports15["callbackify"];
      _extend = exports15._extend;
      callbackify = exports15.callbackify;
      debuglog = exports15.debuglog;
      deprecate = exports15.deprecate;
      format = exports15.format;
      inherits = exports15.inherits;
      inspect = exports15.inspect;
      isArray = exports15.isArray;
      isBoolean = exports15.isBoolean;
      isBuffer = exports15.isBuffer;
      isDate = exports15.isDate;
      isError = exports15.isError;
      isFunction = exports15.isFunction;
      isNull = exports15.isNull;
      isNullOrUndefined = exports15.isNullOrUndefined;
      isNumber = exports15.isNumber;
      isObject = exports15.isObject;
      isPrimitive = exports15.isPrimitive;
      isRegExp = exports15.isRegExp;
      isString = exports15.isString;
      isSymbol = exports15.isSymbol;
      isUndefined = exports15.isUndefined;
      log = exports15.log;
      promisify3 = exports15.promisify;
      types = exports15.types;
      TextEncoder = exports15.TextEncoder = globalThis.TextEncoder;
      TextDecoder2 = exports15.TextDecoder = globalThis.TextDecoder;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/stream.js
  var stream_exports = {};
  __export(stream_exports, {
    Duplex: () => Duplex,
    PassThrough: () => PassThrough,
    Readable: () => Readable,
    Stream: () => Stream,
    Transform: () => Transform,
    Writable: () => Writable,
    default: () => exports16,
    finished: () => finished,
    pipeline: () => pipeline,
    promises: () => promises
  });
  function dew$o() {
    if (_dewExec$o) return exports$p;
    _dewExec$o = true;
    exports$p = {
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name2, prop) {
        return Object.defineProperty(self2, name2, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name2) {
        return Object.getOwnPropertyDescriptor(self2, name2);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
    return exports$p;
  }
  function dew$n() {
    if (_dewExec$n) return exports$o;
    _dewExec$n = true;
    const {
      AbortController: AbortController2,
      AbortSignal
    } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    exports$o = AbortController2;
    exports$o.AbortSignal = AbortSignal;
    exports$o.default = AbortController2;
    return exports$o;
  }
  function dew$m() {
    if (_dewExec$m) return exports$n;
    _dewExec$m = true;
    const bufferModule = dew();
    const {
      kResistStopPropagation,
      SymbolDispose
    } = dew$o();
    const AbortSignal = globalThis.AbortSignal || dew$n().AbortSignal;
    const AbortController2 = globalThis.AbortController || dew$n().AbortController;
    const AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    const Blob2 = globalThis.Blob || bufferModule.Blob;
    const isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b4) {
      return b4 instanceof Blob2;
    } : function isBlob2(b4) {
      return false;
    };
    const validateAbortSignal = (signal, name2) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name2, "AbortSignal", signal);
      }
    };
    const validateFunction = (value, name2) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE(name2, "Function", value);
    };
    class AggregateError2 extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i5 = 0; i5 < errors.length; i5++) {
          message += `    ${errors[i5].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    }
    exports$n = {
      AggregateError: AggregateError2,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve2;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve2 = res;
          reject = rej;
        });
        return {
          promise,
          resolve: resolve2,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve2, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve2(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format3, ...args) {
        return format3.replace(/%([sdifj])/g, function(...[_unused, type2]) {
          const replacement = args.shift();
          if (type2 === "f") {
            return replacement.toFixed(6);
          } else if (type2 === "j") {
            return JSON.stringify(replacement);
          } else if (type2 === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: exports13.addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController2();
        const abort2 = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort2, {
            once: true
          });
        });
        ac.signal.addEventListener("abort", () => {
          signals.forEach((signal) => signal.removeEventListener("abort", abort2));
        }, {
          once: true
        });
        return ac.signal;
      }
    };
    exports$n.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
    return exports$n;
  }
  function dew$l() {
    if (_dewExec$l) return exports$m;
    _dewExec$l = true;
    const {
      format: format3,
      inspect: inspect2,
      AggregateError: CustomAggregateError
    } = dew$m();
    const AggregateError2 = globalThis.AggregateError || CustomAggregateError;
    const kIsNodeError = Symbol("kIsNodeError");
    const kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    const classRegExp = /^([A-Z][a-z0-9]*)+$/;
    const nodeInternalPrefix = "__node_internal_";
    const codes = {};
    function assert2(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i5 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i5 >= start + 4; i5 -= 3) {
        res = `_${val.slice(i5 - 3, i5)}${res}`;
      }
      return `${val.slice(0, i5)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert2(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert2(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);
      if (args.length === 0) {
        return msg;
      }
      return format3(msg, ...args);
    }
    function E3(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError2([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    class AbortError extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    }
    E3("ERR_ASSERTION", "%s", Error);
    E3("ERR_INVALID_ARG_TYPE", (name2, expected, actual) => {
      assert2(typeof name2 === "string", "'name' must be a string");
      if (!Array.isArray(expected)) {
        expected = [expected];
      }
      let msg = "The ";
      if (name2.endsWith(" argument")) {
        msg += `${name2} `;
      } else {
        msg += `"${name2}" ${name2.includes(".") ? "property" : "argument"} `;
      }
      msg += "must be ";
      const types2 = [];
      const instances = [];
      const other = [];
      for (const value of expected) {
        assert2(typeof value === "string", "All expected entries have to be of type string");
        if (kTypes.includes(value)) {
          types2.push(value.toLowerCase());
        } else if (classRegExp.test(value)) {
          instances.push(value);
        } else {
          assert2(value !== "object", 'The value "object" should be written as "Object"');
          other.push(value);
        }
      }
      if (instances.length > 0) {
        const pos = types2.indexOf("object");
        if (pos !== -1) {
          types2.splice(types2, pos, 1);
          instances.push("Object");
        }
      }
      if (types2.length > 0) {
        switch (types2.length) {
          case 1:
            msg += `of type ${types2[0]}`;
            break;
          case 2:
            msg += `one of type ${types2[0]} or ${types2[1]}`;
            break;
          default: {
            const last = types2.pop();
            msg += `one of type ${types2.join(", ")}, or ${last}`;
          }
        }
        if (instances.length > 0 || other.length > 0) {
          msg += " or ";
        }
      }
      if (instances.length > 0) {
        switch (instances.length) {
          case 1:
            msg += `an instance of ${instances[0]}`;
            break;
          case 2:
            msg += `an instance of ${instances[0]} or ${instances[1]}`;
            break;
          default: {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
          }
        }
        if (other.length > 0) {
          msg += " or ";
        }
      }
      switch (other.length) {
        case 0:
          break;
        case 1:
          if (other[0].toLowerCase() !== other[0]) {
            msg += "an ";
          }
          msg += `${other[0]}`;
          break;
        case 2:
          msg += `one of ${other[0]} or ${other[1]}`;
          break;
        default: {
          const last = other.pop();
          msg += `one of ${other.join(", ")}, or ${last}`;
        }
      }
      if (actual == null) {
        msg += `. Received ${actual}`;
      } else if (typeof actual === "function" && actual.name) {
        msg += `. Received function ${actual.name}`;
      } else if (typeof actual === "object") {
        var _actual$constructor;
        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
          msg += `. Received an instance of ${actual.constructor.name}`;
        } else {
          const inspected = inspect2(actual, {
            depth: -1
          });
          msg += `. Received ${inspected}`;
        }
      } else {
        let inspected = inspect2(actual, {
          colors: false
        });
        if (inspected.length > 25) {
          inspected = `${inspected.slice(0, 25)}...`;
        }
        msg += `. Received type ${typeof actual} (${inspected})`;
      }
      return msg;
    }, TypeError);
    E3("ERR_INVALID_ARG_VALUE", (name2, value, reason = "is invalid") => {
      let inspected = inspect2(value);
      if (inspected.length > 128) {
        inspected = inspected.slice(0, 128) + "...";
      }
      const type2 = name2.includes(".") ? "property" : "argument";
      return `The ${type2} '${name2}' ${reason}. Received ${inspected}`;
    }, TypeError);
    E3("ERR_INVALID_RETURN_VALUE", (input, name2, value) => {
      var _value$constructor;
      const type2 = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
      return `Expected ${input} to be returned from the "${name2}" function but got ${type2}.`;
    }, TypeError);
    E3("ERR_MISSING_ARGS", (...args) => {
      assert2(args.length > 0, "At least one arg needs to be specified");
      let msg;
      const len = args.length;
      args = (Array.isArray(args) ? args : [args]).map((a5) => `"${a5}"`).join(" or ");
      switch (len) {
        case 1:
          msg += `The ${args[0]} argument`;
          break;
        case 2:
          msg += `The ${args[0]} and ${args[1]} arguments`;
          break;
        default:
          {
            const last = args.pop();
            msg += `The ${args.join(", ")}, and ${last} arguments`;
          }
          break;
      }
      return `${msg} must be specified`;
    }, TypeError);
    E3("ERR_OUT_OF_RANGE", (str, range, input) => {
      assert2(range, 'Missing "range" argument');
      let received;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > 2n ** 32n || input < -(2n ** 32n)) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      } else {
        received = inspect2(input);
      }
      return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
    }, RangeError);
    E3("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E3("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E3("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E3("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E3("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E3("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E3("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E3("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E3("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E3("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E3("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    exports$m = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
    return exports$m;
  }
  function dew$k3() {
    if (_dewExec$k3) return exports$l2;
    _dewExec$k3 = true;
    const {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = dew$o();
    const {
      hideStackFrames,
      codes: {
        ERR_SOCKET_BAD_PORT,
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_INVALID_ARG_VALUE,
        ERR_OUT_OF_RANGE,
        ERR_UNKNOWN_SIGNAL
      }
    } = dew$l();
    const {
      normalizeEncoding
    } = dew$m();
    const {
      isAsyncFunction,
      isArrayBufferView
    } = dew$m().types;
    const signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    const octalReg = /^[0-7]+$/;
    const modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name2, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name2, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name2);
      return value;
    }
    const validateInteger = hideStackFrames((value, name2, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
    });
    const validateInt32 = hideStackFrames((value, name2, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
      }
    });
    const validateUint32 = hideStackFrames((value, name2, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name2) {
      if (typeof value !== "string") throw new ERR_INVALID_ARG_TYPE2(name2, "string", value);
    }
    function validateNumber(value, name2, min = void 0, max) {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(name2, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
      }
    }
    const validateOneOf = hideStackFrames((value, name2, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v5) => typeof v5 === "string" ? `'${v5}'` : String2(v5)), ", ");
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
      }
    });
    function validateBoolean(value, name2) {
      if (typeof value !== "boolean") throw new ERR_INVALID_ARG_TYPE2(name2, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    const validateObject = hideStackFrames((value, name2, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "Object", value);
      }
    });
    const validateDictionary = hideStackFrames((value, name2) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE2(name2, "a dictionary", value);
      }
    });
    const validateArray = hideStackFrames((value, name2, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
      }
    });
    function validateStringArray(value, name2) {
      validateArray(value, name2);
      for (let i5 = 0; i5 < value.length; i5++) {
        validateString(value[i5], `${name2}[${i5}]`);
      }
    }
    function validateBooleanArray(value, name2) {
      validateArray(value, name2);
      for (let i5 = 0; i5 < value.length; i5++) {
        validateBoolean(value[i5], `${name2}[${i5}]`);
      }
    }
    function validateAbortSignalArray(value, name2) {
      validateArray(value, name2);
      for (let i5 = 0; i5 < value.length; i5++) {
        const signal = value[i5];
        const indexedName = `${name2}[${i5}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name2 = "signal") {
      validateString(signal, name2);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    const validateBuffer = hideStackFrames((buffer2, name2 = "buffer") => {
      if (!isArrayBufferView(buffer2)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, ["Buffer", "TypedArray", "DataView"], buffer2);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name2 = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name2, port, allowZero);
      }
      return port | 0;
    }
    const validateAbortSignal = hideStackFrames((signal, name2) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "AbortSignal", signal);
      }
    });
    const validateFunction = hideStackFrames((value, name2) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE2(name2, "Function", value);
    });
    const validatePlainFunction = hideStackFrames((value, name2) => {
      if (typeof value !== "function" || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE2(name2, "Function", value);
    });
    const validateUndefined = hideStackFrames((value, name2) => {
      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE2(name2, "undefined", value);
    });
    function validateUnion(value, name2, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    const linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name2) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(name2, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i5 = 0; i5 < hintsLength; i5++) {
          const link = hints[i5];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i5 !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    exports$l2 = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
    return exports$l2;
  }
  function dew$j3() {
    if (_dewExec$j3) return exports$k3;
    _dewExec$j3 = true;
    const {
      SymbolAsyncIterator,
      SymbolIterator,
      SymbolFor
    } = dew$o();
    const kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    const kIsErrored = SymbolFor("nodejs.stream.errored");
    const kIsReadable = SymbolFor("nodejs.stream.readable");
    const kIsWritable = SymbolFor("nodejs.stream.writable");
    const kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    const kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    const kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null) return false;
      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false) return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableEnded === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableFinished === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream)) return null;
      if (stream.readableEnded === true) return true;
      const rState = stream._readableState;
      if (!rState || rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream)) return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null) return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    exports$k3 = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
    return exports$k3;
  }
  function dew$i3() {
    if (_dewExec$i3) return exports$j3;
    _dewExec$i3 = true;
    const process$1 = process2;
    const {
      AbortError,
      codes
    } = dew$l();
    const {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_STREAM_PREMATURE_CLOSE
    } = codes;
    const {
      kEmptyObject,
      once: once3
    } = dew$m();
    const {
      validateAbortSignal,
      validateFunction,
      validateObject,
      validateBoolean
    } = dew$k3();
    const {
      Promise: Promise2,
      PromisePrototypeThen,
      SymbolDispose
    } = dew$o();
    const {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = dew$j3();
    let addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    const nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once3(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process$1.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process$1.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process$1.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process$1.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process$1.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort2 = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(stream, new AbortError(void 0, {
            cause: options.signal.reason
          }));
        };
        if (options.signal.aborted) {
          process$1.nextTick(abort2);
        } else {
          addAbortListener = addAbortListener || dew$m().addAbortListener;
          const disposable = addAbortListener(options.signal, abort2);
          const originalCallback = callback;
          callback = once3((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort2 = nop;
      if (options.signal) {
        abort2 = () => {
          isAborted = true;
          callback.call(stream, new AbortError(void 0, {
            cause: options.signal.reason
          }));
        };
        if (options.signal.aborted) {
          process$1.nextTick(abort2);
        } else {
          addAbortListener = addAbortListener || dew$m().addAbortListener;
          const disposable = addAbortListener(options.signal, abort2);
          const originalCallback = callback;
          callback = once3((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process$1.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished2(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve2, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve2();
          }
        });
      });
    }
    exports$j3 = eos;
    exports$j3.finished = finished2;
    return exports$j3;
  }
  function dew$h3() {
    if (_dewExec$h3) return exports$i3;
    _dewExec$h3 = true;
    const process$1 = process2;
    const {
      aggregateTwoErrors,
      codes: {
        ERR_MULTIPLE_CALLBACK
      },
      AbortError
    } = dew$l();
    const {
      Symbol: Symbol2
    } = dew$o();
    const {
      kIsDestroyed,
      isDestroyed,
      isFinished,
      isServerRequest
    } = dew$j3();
    const kDestroy = Symbol2("kDestroy");
    const kConstruct = Symbol2("kConstruct");
    function checkError(err, w3, r5) {
      if (err) {
        err.stack;
        if (w3 && !w3.errored) {
          w3.errored = err;
        }
        if (r5 && !r5.errored) {
          r5.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r5 = this._readableState;
      const w3 = this._writableState;
      const s5 = w3 || r5;
      if (w3 !== null && w3 !== void 0 && w3.destroyed || r5 !== null && r5 !== void 0 && r5.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w3, r5);
      if (w3) {
        w3.destroyed = true;
      }
      if (r5) {
        r5.destroyed = true;
      }
      if (!s5.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r5 = self2._readableState;
        const w3 = self2._writableState;
        checkError(err2, w3, r5);
        if (w3) {
          w3.closed = true;
        }
        if (r5) {
          r5.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process$1.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process$1.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r5 = self2._readableState;
      const w3 = self2._writableState;
      if (w3) {
        w3.closeEmitted = true;
      }
      if (r5) {
        r5.closeEmitted = true;
      }
      if (w3 !== null && w3 !== void 0 && w3.emitClose || r5 !== null && r5 !== void 0 && r5.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r5 = self2._readableState;
      const w3 = self2._writableState;
      if (w3 !== null && w3 !== void 0 && w3.errorEmitted || r5 !== null && r5 !== void 0 && r5.errorEmitted) {
        return;
      }
      if (w3) {
        w3.errorEmitted = true;
      }
      if (r5) {
        r5.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r5 = this._readableState;
      const w3 = this._writableState;
      if (r5) {
        r5.constructed = true;
        r5.closed = false;
        r5.closeEmitted = false;
        r5.destroyed = false;
        r5.errored = null;
        r5.errorEmitted = false;
        r5.reading = false;
        r5.ended = r5.readable === false;
        r5.endEmitted = r5.readable === false;
      }
      if (w3) {
        w3.constructed = true;
        w3.destroyed = false;
        w3.closed = false;
        w3.closeEmitted = false;
        w3.errored = null;
        w3.errorEmitted = false;
        w3.finalCalled = false;
        w3.prefinished = false;
        w3.ended = w3.writable === false;
        w3.ending = w3.writable === false;
        w3.finished = w3.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r5 = stream._readableState;
      const w3 = stream._writableState;
      if (w3 !== null && w3 !== void 0 && w3.destroyed || r5 !== null && r5 !== void 0 && r5.destroyed) {
        return this;
      }
      if (r5 !== null && r5 !== void 0 && r5.autoDestroy || w3 !== null && w3 !== void 0 && w3.autoDestroy) stream.destroy(err);
      else if (err) {
        err.stack;
        if (w3 && !w3.errored) {
          w3.errored = err;
        }
        if (r5 && !r5.errored) {
          r5.errored = err;
        }
        if (sync) {
          process$1.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r5 = stream._readableState;
      const w3 = stream._writableState;
      if (r5) {
        r5.constructed = false;
      }
      if (w3) {
        w3.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process$1.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r5 = stream._readableState;
        const w3 = stream._writableState;
        const s5 = w3 || r5;
        if (r5) {
          r5.constructed = true;
        }
        if (w3) {
          w3.constructed = true;
        }
        if (s5.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process$1.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process$1.nextTick(onConstruct, err);
        });
      } catch (err) {
        process$1.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process$1.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process$1.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process$1.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    exports$i3 = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
    return exports$i3;
  }
  function dew$g4() {
    if (_dewExec$g4) return exports$h3;
    _dewExec$g4 = true;
    const {
      ArrayIsArray,
      ObjectSetPrototypeOf
    } = dew$o();
    const {
      EventEmitter: EE
    } = exports13;
    function Stream2(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream2.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream2, EE);
    Stream2.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener2(source, "error", onerror);
      prependListener2(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener2(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    exports$h3 = {
      Stream: Stream2,
      prependListener: prependListener2
    };
    return exports$h3;
  }
  function dew$f4() {
    if (_dewExec$f4) return exports$g4;
    _dewExec$f4 = true;
    const {
      SymbolDispose
    } = dew$o();
    const {
      AbortError,
      codes
    } = dew$l();
    const {
      isNodeStream,
      isWebStream,
      kControllerErrorFunction
    } = dew$j3();
    const eos = dew$i3();
    const {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2
    } = codes;
    let addAbortListener;
    const validateAbortSignal = (signal, name2) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "AbortSignal", signal);
      }
    };
    exports$g4.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return exports$g4.addAbortSignalNoValidate(signal, stream);
    };
    exports$g4.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(new AbortError(void 0, {
          cause: signal.reason
        }));
      } : () => {
        stream[kControllerErrorFunction](new AbortError(void 0, {
          cause: signal.reason
        }));
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || dew$m().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
    return exports$g4;
  }
  function dew$e4() {
    if (_dewExec$e4) return exports$f4;
    _dewExec$e4 = true;
    const {
      StringPrototypeSlice,
      SymbolIterator,
      TypedArrayPrototypeSet,
      Uint8Array: Uint8Array2
    } = dew$o();
    const {
      Buffer: Buffer3
    } = dew();
    const {
      inspect: inspect2
    } = dew$m();
    exports$f4 = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v5) {
        const entry = {
          data: v5,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v5) {
        const entry = {
          data: v5,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0) return;
        const ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s5) {
        if (this.length === 0) return "";
        let p5 = this.head;
        let ret = "" + p5.data;
        while ((p5 = p5.next) !== null) ret += s5 + p5.data;
        return ret;
      }
      concat(n5) {
        if (this.length === 0) return Buffer3.alloc(0);
        const ret = Buffer3.allocUnsafe(n5 >>> 0);
        let p5 = this.head;
        let i5 = 0;
        while (p5) {
          TypedArrayPrototypeSet(ret, p5.data, i5);
          i5 += p5.data.length;
          p5 = p5.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n5, hasStrings) {
        const data = this.head.data;
        if (n5 < data.length) {
          const slice = data.slice(0, n5);
          this.head.data = data.slice(n5);
          return slice;
        }
        if (n5 === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n5) : this._getBuffer(n5);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p5 = this.head; p5; p5 = p5.next) {
          yield p5.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n5) {
        let ret = "";
        let p5 = this.head;
        let c5 = 0;
        do {
          const str = p5.data;
          if (n5 > str.length) {
            ret += str;
            n5 -= str.length;
          } else {
            if (n5 === str.length) {
              ret += str;
              ++c5;
              if (p5.next) this.head = p5.next;
              else this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n5);
              this.head = p5;
              p5.data = StringPrototypeSlice(str, n5);
            }
            break;
          }
          ++c5;
        } while ((p5 = p5.next) !== null);
        this.length -= c5;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n5) {
        const ret = Buffer3.allocUnsafe(n5);
        const retLen = n5;
        let p5 = this.head;
        let c5 = 0;
        do {
          const buf = p5.data;
          if (n5 > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n5);
            n5 -= buf.length;
          } else {
            if (n5 === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n5);
              ++c5;
              if (p5.next) this.head = p5.next;
              else this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n5), retLen - n5);
              this.head = p5;
              p5.data = buf.slice(n5);
            }
            break;
          }
          ++c5;
        } while ((p5 = p5.next) !== null);
        this.length -= c5;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_3, options) {
        return inspect2(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
    return exports$f4;
  }
  function dew$d4() {
    if (_dewExec$d4) return exports$e4;
    _dewExec$d4 = true;
    const {
      MathFloor,
      NumberIsInteger
    } = dew$o();
    const {
      validateInteger
    } = dew$k3();
    const {
      ERR_INVALID_ARG_VALUE
    } = dew$l().codes;
    let defaultHighWaterMarkBytes = 16 * 1024;
    let defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name2 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name2, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    exports$e4 = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
    return exports$e4;
  }
  function dew$c4() {
    if (_dewExec$c4) return exports$d4;
    _dewExec$c4 = true;
    const process$1 = process2;
    const {
      PromisePrototypeThen,
      SymbolAsyncIterator,
      SymbolIterator
    } = dew$o();
    const {
      Buffer: Buffer3
    } = dew();
    const {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_STREAM_NULL_VALUES
    } = dew$l().codes;
    function from(Readable2, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer3) {
        return new Readable2({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE2("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable2({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process$1.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e5) => process$1.nextTick(cb, e5 || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const {
            value,
            done
          } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const {
            value
          } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const {
              value,
              done
            } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    exports$d4 = from;
    return exports$d4;
  }
  function dew$b5() {
    if (_dewExec$b5) return exports$c5;
    _dewExec$b5 = true;
    const process$1 = process2;
    const {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = dew$o();
    exports$c5 = Readable2;
    Readable2.ReadableState = ReadableState;
    const {
      EventEmitter: EE
    } = exports13;
    const {
      Stream: Stream2,
      prependListener: prependListener2
    } = dew$g4();
    const {
      Buffer: Buffer3
    } = dew();
    const {
      addAbortSignal
    } = dew$f4();
    const eos = dew$i3();
    let debug = dew$m().debuglog("stream", (fn) => {
      debug = fn;
    });
    const BufferList = dew$e4();
    const destroyImpl = dew$h3();
    const {
      getHighWaterMark,
      getDefaultHighWaterMark
    } = dew$d4();
    const {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError
    } = dew$l();
    const {
      validateObject
    } = dew$k3();
    const kPaused = Symbol2("kPaused");
    const {
      StringDecoder: StringDecoder2
    } = exports6;
    const from = dew$c4();
    ObjectSetPrototypeOf(Readable2.prototype, Stream2.prototype);
    ObjectSetPrototypeOf(Readable2, Stream2);
    const nop = () => {
    };
    const {
      errorOrDestroy
    } = destroyImpl;
    const kObjectMode = 1 << 0;
    const kEnded = 1 << 1;
    const kEndEmitted = 1 << 2;
    const kReading = 1 << 3;
    const kConstructed = 1 << 4;
    const kSync = 1 << 5;
    const kNeedReadable = 1 << 6;
    const kEmittedReadable = 1 << 7;
    const kReadableListening = 1 << 8;
    const kResumeScheduled = 1 << 9;
    const kErrorEmitted = 1 << 10;
    const kEmitClose = 1 << 11;
    const kAutoDestroy = 1 << 12;
    const kDestroyed = 1 << 13;
    const kClosed = 1 << 14;
    const kCloseEmitted = 1 << 15;
    const kMultiAwaitDrain = 1 << 16;
    const kReadingMore = 1 << 17;
    const kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return ((this || _global$25).state & bit) !== 0;
        },
        set(value) {
          if (value) (this || _global$25).state |= bit;
          else (this || _global$25).state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof dew$85();
      (this || _global$25).state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode) (this || _global$25).state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode) (this || _global$25).state |= kObjectMode;
      (this || _global$25).highWaterMark = options ? getHighWaterMark(this || _global$25, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      (this || _global$25).buffer = new BufferList();
      (this || _global$25).length = 0;
      (this || _global$25).pipes = [];
      (this || _global$25).flowing = null;
      (this || _global$25)[kPaused] = null;
      if (options && options.emitClose === false) (this || _global$25).state &= ~kEmitClose;
      if (options && options.autoDestroy === false) (this || _global$25).state &= ~kAutoDestroy;
      (this || _global$25).errored = null;
      (this || _global$25).defaultEncoding = options && options.defaultEncoding || "utf8";
      (this || _global$25).awaitDrainWriters = null;
      (this || _global$25).decoder = null;
      (this || _global$25).encoding = null;
      if (options && options.encoding) {
        (this || _global$25).decoder = new StringDecoder2(options.encoding);
        (this || _global$25).encoding = options.encoding;
      }
    }
    function Readable2(options) {
      if (!((this || _global$25) instanceof Readable2)) return new Readable2(options);
      const isDuplex = (this || _global$25) instanceof dew$85();
      (this || _global$25)._readableState = new ReadableState(options, this || _global$25, isDuplex);
      if (options) {
        if (typeof options.read === "function") (this || _global$25)._read = options.read;
        if (typeof options.destroy === "function") (this || _global$25)._destroy = options.destroy;
        if (typeof options.construct === "function") (this || _global$25)._construct = options.construct;
        if (options.signal && !isDuplex) addAbortSignal(options.signal, this || _global$25);
      }
      Stream2.call(this || _global$25, options);
      destroyImpl.construct(this || _global$25, () => {
        if ((this || _global$25)._readableState.needReadable) {
          maybeReadMore(this || _global$25, (this || _global$25)._readableState);
        }
      });
    }
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable2.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!(this || _global$25).destroyed) {
        error = (this || _global$25).readableEnded ? null : new AbortError();
        this.destroy(error);
      }
      return new Promise2((resolve2, reject) => eos(this || _global$25, (err) => err && err !== error ? reject(err) : resolve2(null)));
    };
    Readable2.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this || _global$25, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this || _global$25, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer3.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer3) {
          encoding = "";
        } else if (Stream2._isUint8Array(chunk)) {
          chunk = Stream2._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored) return false;
          else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
            else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable2.prototype.isPaused = function() {
      const state = (this || _global$25)._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder2(enc);
      (this || _global$25)._readableState.decoder = decoder;
      (this || _global$25)._readableState.encoding = (this || _global$25)._readableState.decoder.encoding;
      const buffer2 = (this || _global$25)._readableState.buffer;
      let content = "";
      for (const data of buffer2) {
        content += decoder.write(data);
      }
      buffer2.clear();
      if (content !== "") buffer2.push(content);
      (this || _global$25)._readableState.length = content.length;
      return this || _global$25;
    };
    const MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n5) {
      if (n5 > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n5);
      } else {
        n5--;
        n5 |= n5 >>> 1;
        n5 |= n5 >>> 2;
        n5 |= n5 >>> 4;
        n5 |= n5 >>> 8;
        n5 |= n5 >>> 16;
        n5++;
      }
      return n5;
    }
    function howMuchToRead(n5, state) {
      if (n5 <= 0 || state.length === 0 && state.ended) return 0;
      if ((state.state & kObjectMode) !== 0) return 1;
      if (NumberIsNaN(n5)) {
        if (state.flowing && state.length) return state.buffer.first().length;
        return state.length;
      }
      if (n5 <= state.length) return n5;
      return state.ended ? state.length : 0;
    }
    Readable2.prototype.read = function(n5) {
      debug("read", n5);
      if (n5 === void 0) {
        n5 = NaN;
      } else if (!NumberIsInteger(n5)) {
        n5 = NumberParseInt(n5, 10);
      }
      const state = (this || _global$25)._readableState;
      const nOrig = n5;
      if (n5 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n5);
      if (n5 !== 0) state.state &= ~kEmittedReadable;
      if (n5 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this || _global$25);
        else emitReadable(this || _global$25);
        return null;
      }
      n5 = howMuchToRead(n5, state);
      if (n5 === 0 && state.ended) {
        if (state.length === 0) endReadable(this || _global$25);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n5 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0) state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this || _global$25, err);
        }
        state.state &= ~kSync;
        if (!state.reading) n5 = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n5 > 0) ret = fromList(n5, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n5 = 0;
      } else {
        state.length -= n5;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n5 && state.ended) endReadable(this || _global$25);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process$1.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process$1.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n5) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      const src = this || _global$25;
      const state = (this || _global$25)._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process$1.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s5 = dest._writableState || dest._readableState;
          if (s5 && !s5.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      const state = (this || _global$25)._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0) return this || _global$25;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i5 = 0; i5 < dests.length; i5++) dests[i5].emit("unpipe", this || _global$25, {
          hasUnpiped: false
        });
        return this || _global$25;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1) return this || _global$25;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0) this.pause();
      dest.emit("unpipe", this || _global$25, unpipeInfo);
      return this || _global$25;
    };
    Readable2.prototype.on = function(ev, fn) {
      const res = Stream2.prototype.on.call(this || _global$25, ev, fn);
      const state = (this || _global$25)._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this || _global$25);
          } else if (!state.reading) {
            process$1.nextTick(nReadingNextTick, this || _global$25);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      const res = Stream2.prototype.removeListener.call(this || _global$25, ev, fn);
      if (ev === "readable") {
        process$1.nextTick(updateReadableListening, this || _global$25);
      }
      return res;
    };
    Readable2.prototype.off = Readable2.prototype.removeListener;
    Readable2.prototype.removeAllListeners = function(ev) {
      const res = Stream2.prototype.removeAllListeners.apply(this || _global$25, arguments);
      if (ev === "readable" || ev === void 0) {
        process$1.nextTick(updateReadableListening, this || _global$25);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      const state = (this || _global$25)._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this || _global$25, state);
      }
      state[kPaused] = false;
      return this || _global$25;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process$1.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", (this || _global$25)._readableState.flowing);
      if ((this || _global$25)._readableState.flowing !== false) {
        debug("pause");
        (this || _global$25)._readableState.flowing = false;
        this.emit("pause");
      }
      (this || _global$25)._readableState[kPaused] = true;
      return this || _global$25;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable2.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this || _global$25, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      (this || _global$25)._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j3 = 1; j3 < streamKeys.length; j3++) {
        const i5 = streamKeys[j3];
        if ((this || _global$25)[i5] === void 0 && typeof stream[i5] === "function") {
          (this || _global$25)[i5] = stream[i5].bind(stream);
        }
      }
      return this || _global$25;
    };
    Readable2.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this || _global$25);
    };
    Readable2.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this || _global$25, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable2.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve2) {
        if ((this || _global$25) === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve2;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(stream, {
        writable: false
      }, (err) => {
        error = err ? aggregateTwoErrors(error, err) : null;
        callback();
        callback = nop;
      });
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable2.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r5 = (this || _global$25)._readableState;
          return !!r5 && r5.readable !== false && !r5.destroyed && !r5.errorEmitted && !r5.endEmitted;
        },
        set(val) {
          if ((this || _global$25)._readableState) {
            (this || _global$25)._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return (this || _global$25)._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!((this || _global$25)._readableState.readable !== false && ((this || _global$25)._readableState.destroyed || (this || _global$25)._readableState.errored) && !(this || _global$25)._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return (this || _global$25)._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return (this || _global$25)._readableState && (this || _global$25)._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return (this || _global$25)._readableState.flowing;
        },
        set: function(state) {
          if ((this || _global$25)._readableState) {
            (this || _global$25)._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$25)._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$25)._readableState ? (this || _global$25)._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$25)._readableState ? (this || _global$25)._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$25)._readableState ? (this || _global$25)._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return (this || _global$25)._readableState ? (this || _global$25)._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$25)._readableState ? (this || _global$25)._readableState.destroyed : false;
        },
        set(value) {
          if (!(this || _global$25)._readableState) {
            return;
          }
          (this || _global$25)._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$25)._readableState ? (this || _global$25)._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return (this || _global$25).pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return (this || _global$25)[kPaused] !== false;
        },
        set(value) {
          (this || _global$25)[kPaused] = !!value;
        }
      }
    });
    Readable2._fromList = fromList;
    function fromList(n5, state) {
      if (state.length === 0) return null;
      let ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n5 || n5 >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n5, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process$1.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process$1.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable2.from = function(iterable, opts) {
      return from(Readable2, iterable, opts);
    };
    let webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable2.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable2.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable2.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable2({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
    return exports$c5;
  }
  function dew$a5() {
    if (_dewExec$a5) return exports$b5;
    _dewExec$a5 = true;
    const process$1 = process2;
    const {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = dew$o();
    exports$b5 = Writable2;
    Writable2.WritableState = WritableState;
    const {
      EventEmitter: EE
    } = exports13;
    const Stream2 = dew$g4().Stream;
    const {
      Buffer: Buffer3
    } = dew();
    const destroyImpl = dew$h3();
    const {
      addAbortSignal
    } = dew$f4();
    const {
      getHighWaterMark,
      getDefaultHighWaterMark
    } = dew$d4();
    const {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = dew$l().codes;
    const {
      errorOrDestroy
    } = destroyImpl;
    ObjectSetPrototypeOf(Writable2.prototype, Stream2.prototype);
    ObjectSetPrototypeOf(Writable2, Stream2);
    function nop() {
    }
    const kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof dew$85();
      (this || _global$15).objectMode = !!(options && options.objectMode);
      if (isDuplex) (this || _global$15).objectMode = (this || _global$15).objectMode || !!(options && options.writableObjectMode);
      (this || _global$15).highWaterMark = options ? getHighWaterMark(this || _global$15, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      (this || _global$15).finalCalled = false;
      (this || _global$15).needDrain = false;
      (this || _global$15).ending = false;
      (this || _global$15).ended = false;
      (this || _global$15).finished = false;
      (this || _global$15).destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      (this || _global$15).decodeStrings = !noDecode;
      (this || _global$15).defaultEncoding = options && options.defaultEncoding || "utf8";
      (this || _global$15).length = 0;
      (this || _global$15).writing = false;
      (this || _global$15).corked = 0;
      (this || _global$15).sync = true;
      (this || _global$15).bufferProcessing = false;
      (this || _global$15).onwrite = onwrite.bind(void 0, stream);
      (this || _global$15).writecb = null;
      (this || _global$15).writelen = 0;
      (this || _global$15).afterWriteTickInfo = null;
      resetBuffer(this || _global$15);
      (this || _global$15).pendingcb = 0;
      (this || _global$15).constructed = true;
      (this || _global$15).prefinished = false;
      (this || _global$15).errorEmitted = false;
      (this || _global$15).emitClose = !options || options.emitClose !== false;
      (this || _global$15).autoDestroy = !options || options.autoDestroy !== false;
      (this || _global$15).errored = null;
      (this || _global$15).closed = false;
      (this || _global$15).closeEmitted = false;
      (this || _global$15)[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice((this || _global$15).buffered, (this || _global$15).bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return (this || _global$15).buffered.length - (this || _global$15).bufferedIndex;
      }
    });
    function Writable2(options) {
      const isDuplex = (this || _global$15) instanceof dew$85();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable2, this || _global$15)) return new Writable2(options);
      (this || _global$15)._writableState = new WritableState(options, this || _global$15, isDuplex);
      if (options) {
        if (typeof options.write === "function") (this || _global$15)._write = options.write;
        if (typeof options.writev === "function") (this || _global$15)._writev = options.writev;
        if (typeof options.destroy === "function") (this || _global$15)._destroy = options.destroy;
        if (typeof options.final === "function") (this || _global$15)._final = options.final;
        if (typeof options.construct === "function") (this || _global$15)._construct = options.construct;
        if (options.signal) addAbortSignal(options.signal, this || _global$15);
      }
      Stream2.call(this || _global$15, options);
      destroyImpl.construct(this || _global$15, () => {
        const state = (this || _global$15)._writableState;
        if (!state.writing) {
          clearBuffer(this || _global$15, state);
        }
        finishMaybe(this || _global$15, state);
      });
    }
    ObjectDefineProperty(Writable2, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this || _global$15, object)) return true;
        if ((this || _global$15) !== Writable2) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this || _global$15, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding) encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function") cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer3) {
          encoding = "buffer";
        } else if (Stream2._isUint8Array(chunk)) {
          chunk = Stream2._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process$1.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      return _write(this || _global$15, chunk, encoding, cb) === true;
    };
    Writable2.prototype.cork = function() {
      (this || _global$15)._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      const state = (this || _global$15)._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing) clearBuffer(this || _global$15, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer3.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
      (this || _global$15)._writableState.defaultEncoding = encoding;
      return this || _global$15;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process$1.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process$1.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({
      stream,
      state,
      count,
      cb
    }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n5 = state.bufferedIndex; n5 < state.buffered.length; ++n5) {
        var _state$errored;
        const {
          chunk,
          callback
        } = state.buffered[n5];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback((_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write"));
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i5 = 0; i5 < onfinishCallbacks.length; i5++) {
        var _state$errored2;
        onfinishCallbacks[i5]((_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const {
        buffered,
        bufferedIndex,
        objectMode
      } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i5 = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n5 = i5; n5 < buffered.length; ++n5) {
            buffered[n5].callback(err);
          }
        };
        const chunks = state.allNoop && i5 === 0 ? buffered : ArrayPrototypeSlice(buffered, i5);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const {
            chunk,
            encoding,
            callback
          } = buffered[i5];
          buffered[i5++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i5 < buffered.length && !state.writing);
        if (i5 === buffered.length) {
          resetBuffer(state);
        } else if (i5 > 256) {
          buffered.splice(0, i5);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i5;
        }
      }
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      if ((this || _global$15)._writev) {
        this._writev([{
          chunk,
          encoding
        }], cb);
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      const state = (this || _global$15)._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this || _global$15, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) ;
      else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this || _global$15, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process$1.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this || _global$15;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i5 = 0; i5 < onfinishCallbacks.length; i5++) {
            onfinishCallbacks[i5](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process$1.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process$1.nextTick((stream2, state2) => {
              if (needFinish(state2)) {
                finish(stream2, state2);
              } else {
                state2.pendingcb--;
              }
            }, stream, state);
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i5 = 0; i5 < onfinishCallbacks.length; i5++) {
        onfinishCallbacks[i5]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable2.prototype, {
      closed: {
        __proto__: null,
        get() {
          return (this || _global$15)._writableState ? (this || _global$15)._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return (this || _global$15)._writableState ? (this || _global$15)._writableState.destroyed : false;
        },
        set(value) {
          if ((this || _global$15)._writableState) {
            (this || _global$15)._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w3 = (this || _global$15)._writableState;
          return !!w3 && w3.writable !== false && !w3.destroyed && !w3.errored && !w3.ending && !w3.ended;
        },
        set(val) {
          if ((this || _global$15)._writableState) {
            (this || _global$15)._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return (this || _global$15)._writableState ? (this || _global$15)._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return (this || _global$15)._writableState ? (this || _global$15)._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return (this || _global$15)._writableState && (this || _global$15)._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return (this || _global$15)._writableState ? (this || _global$15)._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = (this || _global$15)._writableState;
          if (!wState) return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return (this || _global$15)._writableState && (this || _global$15)._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return (this || _global$15)._writableState ? (this || _global$15)._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return (this || _global$15)._writableState && (this || _global$15)._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return (this || _global$15)._writableState ? (this || _global$15)._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!((this || _global$15)._writableState.writable !== false && ((this || _global$15)._writableState.destroyed || (this || _global$15)._writableState.errored) && !(this || _global$15)._writableState.finished);
        }
      }
    });
    const destroy = destroyImpl.destroy;
    Writable2.prototype.destroy = function(err, cb) {
      const state = (this || _global$15)._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process$1.nextTick(errorBuffer, state);
      }
      destroy.call(this || _global$15, err, cb);
      return this || _global$15;
    };
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    let webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable2.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable2.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
    return exports$b5;
  }
  function dew$95() {
    if (_dewExec$95) return exports$a5;
    _dewExec$95 = true;
    const process$1 = process2;
    const bufferModule = dew();
    const {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = dew$j3();
    const eos = dew$i3();
    const {
      AbortError,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_INVALID_RETURN_VALUE
      }
    } = dew$l();
    const {
      destroyer
    } = dew$h3();
    const Duplex2 = dew$85();
    const Readable2 = dew$b5();
    const Writable2 = dew$a5();
    const {
      createDeferredPromise
    } = dew$m();
    const from = dew$c4();
    const Blob2 = globalThis.Blob || bufferModule.Blob;
    const isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b4) {
      return b4 instanceof Blob2;
    } : function isBlob2(b4) {
      return false;
    };
    const AbortController2 = globalThis.AbortController || dew$n().AbortController;
    const {
      FunctionPrototypeCall
    } = dew$o();
    class Duplexify extends Duplex2 {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    }
    exports$a5 = function duplexify(body, name2) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable2.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable2.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const {
          value,
          write,
          final,
          destroy
        } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d4;
          const promise = FunctionPrototypeCall(then2, value, (val) => {
            if (val != null) {
              throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
            }
          }, (err) => {
            destroyer(d4, err);
          });
          return d4 = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process$1.nextTick(cb, null);
                } catch (err) {
                  process$1.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name2, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d4;
        FunctionPrototypeCall(then, body, (val) => {
          if (val != null) {
            d4.push(val);
          }
          d4.push(null);
        }, (err) => {
          destroyer(d4, err);
        });
        return d4 = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE2(name2, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], body);
    };
    function fromAsyncGen(fn) {
      let {
        promise,
        resolve: resolve2
      } = createDeferredPromise();
      const ac = new AbortController2();
      const signal = ac.signal;
      const value = fn(async function* () {
        while (true) {
          const _promise = promise;
          promise = null;
          const {
            chunk,
            done,
            cb
          } = await _promise;
          process$1.nextTick(cb);
          if (done) return;
          if (signal.aborted) throw new AbortError(void 0, {
            cause: signal.reason
          });
          ({
            promise,
            resolve: resolve2
          } = createDeferredPromise());
          yield chunk;
        }
      }(), {
        signal
      });
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve2;
          resolve2 = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve2;
          resolve2 = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r5 = pair.readable && typeof pair.readable.read !== "function" ? Readable2.wrap(pair.readable) : pair.readable;
      const w3 = pair.writable;
      let readable = !!isReadable(r5);
      let writable = !!isWritable(w3);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d4;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d4.destroy(err);
        }
      }
      d4 = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r5 !== null && r5 !== void 0 && r5.readableObjectMode),
        writableObjectMode: !!(w3 !== null && w3 !== void 0 && w3.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w3, (err) => {
          writable = false;
          if (err) {
            destroyer(r5, err);
          }
          onfinished(err);
        });
        d4._write = function(chunk, encoding, callback) {
          if (w3.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d4._final = function(callback) {
          w3.end();
          onfinish = callback;
        };
        w3.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w3.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r5, (err) => {
          readable = false;
          if (err) {
            destroyer(r5, err);
          }
          onfinished(err);
        });
        r5.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r5.on("end", function() {
          d4.push(null);
        });
        d4._read = function() {
          while (true) {
            const buf = r5.read();
            if (buf === null) {
              onreadable = d4._read;
              return;
            }
            if (!d4.push(buf)) {
              return;
            }
          }
        };
      }
      d4._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w3, err);
          destroyer(r5, err);
        }
      };
      return d4;
    }
    return exports$a5;
  }
  function dew$85() {
    if (_dewExec$85) return exports$95;
    _dewExec$85 = true;
    const {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = dew$o();
    exports$95 = Duplex2;
    const Readable2 = dew$b5();
    const Writable2 = dew$a5();
    ObjectSetPrototypeOf(Duplex2.prototype, Readable2.prototype);
    ObjectSetPrototypeOf(Duplex2, Readable2);
    {
      const keys = ObjectKeys(Writable2.prototype);
      for (let i5 = 0; i5 < keys.length; i5++) {
        const method = keys[i5];
        if (!Duplex2.prototype[method]) Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    function Duplex2(options) {
      if (!(this instanceof Duplex2)) return new Duplex2(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex2.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    let webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex2.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex2.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    let duplexify;
    Duplex2.from = function(body) {
      if (!duplexify) {
        duplexify = dew$95();
      }
      return duplexify(body, "body");
    };
    return exports$95;
  }
  function dew$75() {
    if (_dewExec$75) return exports$85;
    _dewExec$75 = true;
    const {
      ObjectSetPrototypeOf,
      Symbol: Symbol2
    } = dew$o();
    exports$85 = Transform2;
    const {
      ERR_METHOD_NOT_IMPLEMENTED
    } = dew$l().codes;
    const Duplex2 = dew$85();
    const {
      getHighWaterMark
    } = dew$d4();
    ObjectSetPrototypeOf(Transform2.prototype, Duplex2.prototype);
    ObjectSetPrototypeOf(Transform2, Duplex2);
    const kCallback = Symbol2("kCallback");
    function Transform2(options) {
      if (!(this instanceof Transform2)) return new Transform2(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex2.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform2.prototype._final = final;
    Transform2.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform2.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform2.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
    return exports$85;
  }
  function dew$66() {
    if (_dewExec$66) return exports$76;
    _dewExec$66 = true;
    const {
      ObjectSetPrototypeOf
    } = dew$o();
    exports$76 = PassThrough2;
    const Transform2 = dew$75();
    ObjectSetPrototypeOf(PassThrough2.prototype, Transform2.prototype);
    ObjectSetPrototypeOf(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2)) return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    return exports$76;
  }
  function dew$56() {
    if (_dewExec$56) return exports$66;
    _dewExec$56 = true;
    const process$1 = process2;
    const {
      ArrayIsArray,
      Promise: Promise2,
      SymbolAsyncIterator,
      SymbolDispose
    } = dew$o();
    const eos = dew$i3();
    const {
      once: once3
    } = dew$m();
    const destroyImpl = dew$h3();
    const Duplex2 = dew$85();
    const {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = dew$l();
    const {
      validateFunction,
      validateAbortSignal
    } = dew$k3();
    const {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = dew$j3();
    const AbortController2 = globalThis.AbortController || dew$n().AbortController;
    let PassThrough2;
    let Readable2;
    let addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished2 = false;
      stream.on("close", () => {
        finished2 = true;
      });
      const cleanup = eos(stream, {
        readable: reading,
        writable: writing
      }, (err) => {
        finished2 = !err;
      });
      return {
        destroy: (err) => {
          if (finished2) return;
          finished2 = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable2) {
        Readable2 = dew$b5();
      }
      yield* Readable2.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, {
      end
    }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve2, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve2();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(writable, {
        readable: false
      }, resume);
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, {
      end
    }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline2(...streams) {
      return pipelineImpl(streams, once3(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort2() {
        finishImpl(new AbortError());
      }
      addAbortListener = addAbortListener || dew$m().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort2);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process$1.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i5 = 0; i5 < streams.length; i5++) {
        const stream = streams[i5];
        const reading = i5 < streams.length - 1;
        const writing = i5 > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i5 === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          if (end) {
            const {
              destroy,
              cleanup
            } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError);
            });
          }
        }
        if (i5 === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex2.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i5 - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough2) {
              PassThrough2 = dew$66();
            }
            const pt = new PassThrough2({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(ret, (val) => {
                value = val;
                if (val != null) {
                  pt.write(val);
                }
                if (end) {
                  pt.end();
                }
                process$1.nextTick(finish);
              }, (err) => {
                pt.destroy(err);
                process$1.nextTick(finish, err);
              });
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const {
              destroy,
              cleanup
            } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          }
          ret = stream;
        } else {
          ret = Duplex2.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process$1.nextTick(abort2);
      }
      return ret;
    }
    function pipe(src, dst, finish, {
      end
    }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn = function() {
          ended = true;
          dst.end();
        };
        if (isReadableFinished(src)) {
          process$1.nextTick(endFn);
        } else {
          src.once("end", endFn);
        }
      } else {
        finish();
      }
      eos(src, {
        readable: true,
        writable: false
      }, (err) => {
        const rState = src._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
          src.once("end", finish).once("error", finish);
        } else {
          finish(err);
        }
      });
      return eos(dst, {
        readable: false,
        writable: true
      }, finish);
    }
    exports$66 = {
      pipelineImpl,
      pipeline: pipeline2
    };
    return exports$66;
  }
  function dew$46() {
    if (_dewExec$46) return exports$56;
    _dewExec$46 = true;
    const {
      pipeline: pipeline2
    } = dew$56();
    const Duplex2 = dew$85();
    const {
      destroyer
    } = dew$h3();
    const {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = dew$j3();
    const {
      AbortError,
      codes: {
        ERR_INVALID_ARG_VALUE,
        ERR_MISSING_ARGS
      }
    } = dew$l();
    const eos = dew$i3();
    exports$56 = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex2.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex2.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex2.from(streams[idx]);
      }
      for (let n5 = 0; n5 < streams.length; ++n5) {
        if (!isNodeStream(streams[n5]) && !isWebStream(streams[n5])) {
          continue;
        }
        if (n5 < streams.length - 1 && !(isReadable(streams[n5]) || isReadableStream(streams[n5]) || isTransformStream(streams[n5]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n5}]`, orgStreams[n5], "must be readable");
        }
        if (n5 > 0 && !(isWritable(streams[n5]) || isWritableStream(streams[n5]) || isTransformStream(streams[n5]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n5}]`, orgStreams[n5], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d4;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d4.destroy(err);
        } else if (!readable && !writable) {
          d4.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline2(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d4 = new Duplex2({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d4._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d4._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d4._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d4._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d4.push(null);
          });
          d4._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d4._read;
                return;
              }
              if (!d4.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d4._read = async function() {
            while (true) {
              try {
                const {
                  value,
                  done
                } = await reader.read();
                if (!d4.push(value)) {
                  return;
                }
                if (done) {
                  d4.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d4._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d4;
    };
    return exports$56;
  }
  function dew$36() {
    if (_dewExec$36) return exports$46;
    _dewExec$36 = true;
    const AbortController2 = globalThis.AbortController || dew$n().AbortController;
    const {
      codes: {
        ERR_INVALID_ARG_VALUE,
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_MISSING_ARGS,
        ERR_OUT_OF_RANGE
      },
      AbortError
    } = dew$l();
    const {
      validateAbortSignal,
      validateInteger,
      validateObject
    } = dew$k3();
    const kWeakHandler = dew$o().Symbol("kWeak");
    const kResistStopPropagation = dew$o().Symbol("kResistStopPropagation");
    const {
      finished: finished2
    } = dew$i3();
    const staticCompose = dew$46();
    const {
      addAbortSignalNoValidate
    } = dew$f4();
    const {
      isWritable,
      isNodeStream
    } = dew$j3();
    const {
      deprecate: deprecate2
    } = dew$m();
    const {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = dew$o();
    const kEmpty = Symbol2("kEmpty");
    const kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return async function* map2() {
        const signal = dew$m().AbortSignalAny([options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2));
        const stream = this;
        const queue2 = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue2.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue2.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue2.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve2) => {
                  resume = resolve2;
                });
              }
            }
            queue2.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue2.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue2.length > 0) {
              const val = await queue2[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue2.shift();
              maybeResume();
            }
            await new Promise2((resolve2) => {
              next = resolve2;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(this, async (...args) => {
        return !await fn(...args);
      }, options);
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options)) ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    }
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished2(this.destroy(err));
        throw err;
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }.call(this);
    }
    exports$46.streamReturningOperators = {
      asIndexedPairs: deprecate2(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    exports$46.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
    return exports$46;
  }
  function dew$27() {
    if (_dewExec$27) return exports$36;
    _dewExec$27 = true;
    const {
      ArrayPrototypePop,
      Promise: Promise2
    } = dew$o();
    const {
      isIterable,
      isNodeStream,
      isWebStream
    } = dew$j3();
    const {
      pipelineImpl: pl
    } = dew$56();
    const {
      finished: finished2
    } = dew$i3();
    dew$19();
    function pipeline2(...streams) {
      return new Promise2((resolve2, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(streams, (err, value) => {
          if (err) {
            reject(err);
          } else {
            resolve2(value);
          }
        }, {
          signal,
          end
        });
      });
    }
    exports$36 = {
      finished: finished2,
      pipeline: pipeline2
    };
    return exports$36;
  }
  function dew$19() {
    if (_dewExec$19) return exports$29;
    _dewExec$19 = true;
    const {
      Buffer: Buffer3
    } = dew();
    const {
      ObjectDefineProperty,
      ObjectKeys,
      ReflectApply
    } = dew$o();
    const {
      promisify: {
        custom: customPromisify
      }
    } = dew$m();
    const {
      streamReturningOperators,
      promiseReturningOperators
    } = dew$36();
    const {
      codes: {
        ERR_ILLEGAL_CONSTRUCTOR
      }
    } = dew$l();
    const compose = dew$46();
    const {
      setDefaultHighWaterMark,
      getDefaultHighWaterMark
    } = dew$d4();
    const {
      pipeline: pipeline2
    } = dew$56();
    const {
      destroyer
    } = dew$h3();
    const eos = dew$i3();
    const promises2 = dew$27();
    const utils = dew$j3();
    const Stream2 = exports$29 = dew$g4().Stream;
    Stream2.isDestroyed = utils.isDestroyed;
    Stream2.isDisturbed = utils.isDisturbed;
    Stream2.isErrored = utils.isErrored;
    Stream2.isReadable = utils.isReadable;
    Stream2.isWritable = utils.isWritable;
    Stream2.Readable = dew$b5();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream2.Readable.from(ReflectApply(op, this || _global7, args));
      };
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream2.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this || _global7, args);
      };
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream2.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    Stream2.Writable = dew$a5();
    Stream2.Duplex = dew$85();
    Stream2.Transform = dew$75();
    Stream2.PassThrough = dew$66();
    Stream2.pipeline = pipeline2;
    const {
      addAbortSignal
    } = dew$f4();
    Stream2.addAbortSignal = addAbortSignal;
    Stream2.finished = eos;
    Stream2.destroy = destroyer;
    Stream2.compose = compose;
    Stream2.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream2.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream2, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises2;
      }
    });
    ObjectDefineProperty(pipeline2, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises2.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises2.finished;
      }
    });
    Stream2.Stream = Stream2;
    Stream2._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream2._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
    return exports$29;
  }
  function dew15() {
    if (_dewExec15) return exports$111;
    _dewExec15 = true;
    const CustomStream = dew$19();
    const promises2 = dew$27();
    const originalDestroy = CustomStream.Readable.destroy;
    exports$111 = CustomStream.Readable;
    exports$111._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    exports$111._isUint8Array = CustomStream._isUint8Array;
    exports$111.isDisturbed = CustomStream.isDisturbed;
    exports$111.isErrored = CustomStream.isErrored;
    exports$111.isReadable = CustomStream.isReadable;
    exports$111.Readable = CustomStream.Readable;
    exports$111.Writable = CustomStream.Writable;
    exports$111.Duplex = CustomStream.Duplex;
    exports$111.Transform = CustomStream.Transform;
    exports$111.PassThrough = CustomStream.PassThrough;
    exports$111.addAbortSignal = CustomStream.addAbortSignal;
    exports$111.finished = CustomStream.finished;
    exports$111.destroy = CustomStream.destroy;
    exports$111.destroy = originalDestroy;
    exports$111.pipeline = CustomStream.pipeline;
    exports$111.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises2;
      }
    });
    exports$111.Stream = CustomStream.Stream;
    exports$111.default = exports$111;
    return exports$111;
  }
  var exports$p, _dewExec$o, exports$o, _dewExec$n, exports$n, _dewExec$m, exports$m, _dewExec$l, exports$l2, _dewExec$k3, exports$k3, _dewExec$j3, exports$j3, _dewExec$i3, exports$i3, _dewExec$h3, exports$h3, _dewExec$g4, exports$g4, _dewExec$f4, exports$f4, _dewExec$e4, exports$e4, _dewExec$d4, exports$d4, _dewExec$c4, exports$c5, _dewExec$b5, _global$25, exports$b5, _dewExec$a5, _global$15, exports$a5, _dewExec$95, exports$95, _dewExec$85, exports$85, _dewExec$75, exports$76, _dewExec$66, exports$66, _dewExec$56, exports$56, _dewExec$46, exports$46, _dewExec$36, exports$36, _dewExec$27, exports$29, _dewExec$19, _global7, exports$111, _dewExec15, exports16, Readable, Writable, Duplex, Transform, PassThrough, finished, pipeline, Stream, promises;
  var init_stream = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/stream.js"() {
      init_buffer2();
      init_chunk_DtuTasat();
      init_events();
      init_chunk_DEMDiNwt();
      init_chunk_CcCWfKp1();
      init_util();
      init_chunk_DtcTpLWz();
      init_chunk_CkFCi_G1();
      exports$p = {};
      _dewExec$o = false;
      exports$o = {};
      _dewExec$n = false;
      exports$n = {};
      _dewExec$m = false;
      exports$m = {};
      _dewExec$l = false;
      exports$l2 = {};
      _dewExec$k3 = false;
      exports$k3 = {};
      _dewExec$j3 = false;
      exports$j3 = {};
      _dewExec$i3 = false;
      exports$i3 = {};
      _dewExec$h3 = false;
      exports$h3 = {};
      _dewExec$g4 = false;
      exports$g4 = {};
      _dewExec$f4 = false;
      exports$f4 = {};
      _dewExec$e4 = false;
      exports$e4 = {};
      _dewExec$d4 = false;
      exports$d4 = {};
      _dewExec$c4 = false;
      exports$c5 = {};
      _dewExec$b5 = false;
      _global$25 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$b5 = {};
      _dewExec$a5 = false;
      _global$15 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$a5 = {};
      _dewExec$95 = false;
      exports$95 = {};
      _dewExec$85 = false;
      exports$85 = {};
      _dewExec$75 = false;
      exports$76 = {};
      _dewExec$66 = false;
      exports$66 = {};
      _dewExec$56 = false;
      exports$56 = {};
      _dewExec$46 = false;
      exports$46 = {};
      _dewExec$36 = false;
      exports$36 = {};
      _dewExec$27 = false;
      exports$29 = {};
      _dewExec$19 = false;
      _global7 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$111 = {};
      _dewExec15 = false;
      exports16 = dew15();
      exports16["_uint8ArrayToBuffer"];
      exports16["_isUint8Array"];
      exports16["isDisturbed"];
      exports16["isErrored"];
      exports16["isReadable"];
      exports16["Readable"];
      exports16["Writable"];
      exports16["Duplex"];
      exports16["Transform"];
      exports16["PassThrough"];
      exports16["addAbortSignal"];
      exports16["finished"];
      exports16["destroy"];
      exports16["pipeline"];
      exports16["compose"];
      exports16["Stream"];
      Readable = exports16.Readable;
      Readable.wrap = function(src, options) {
        options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
        options.destroy = function(err, callback) {
          src.destroy(err);
          callback(err);
        };
        return new Readable(options).wrap(src);
      };
      Writable = exports16.Writable;
      Duplex = exports16.Duplex;
      Transform = exports16.Transform;
      PassThrough = exports16.PassThrough;
      finished = exports16.finished;
      pipeline = exports16.pipeline;
      Stream = exports16.Stream;
      promises = {
        finished: promisify3(exports16.finished),
        pipeline: promisify3(exports16.pipeline)
      };
    }
  });

  // ../../node_modules/web-streams-polyfill/dist/ponyfill.js
  var require_ponyfill = __commonJS({
    "../../node_modules/web-streams-polyfill/dist/ponyfill.js"(exports21, module) {
      init_buffer2();
      !function(e5, t5) {
        "object" == typeof exports21 && "undefined" != typeof module ? t5(exports21) : "function" == typeof define && define.amd ? define(["exports"], t5) : t5((e5 = "undefined" != typeof globalThis ? globalThis : e5 || self).WebStreamsPolyfill = {});
      }(exports21, function(e5) {
        "use strict";
        function t5() {
        }
        function r5(e6) {
          return "object" == typeof e6 && null !== e6 || "function" == typeof e6;
        }
        const o5 = t5;
        function n5(e6, t6) {
          try {
            Object.defineProperty(e6, "name", { value: t6, configurable: true });
          } catch (e7) {
          }
        }
        const a5 = Promise, i5 = Promise.resolve.bind(a5), l5 = Promise.prototype.then, s5 = Promise.reject.bind(a5), u5 = i5;
        function c5(e6) {
          return new a5(e6);
        }
        function d4(e6) {
          return c5((t6) => t6(e6));
        }
        function f5(e6) {
          return s5(e6);
        }
        function b4(e6, t6, r6) {
          return l5.call(e6, t6, r6);
        }
        function h5(e6, t6, r6) {
          b4(b4(e6, t6, r6), void 0, o5);
        }
        function m4(e6, t6) {
          h5(e6, t6);
        }
        function _3(e6, t6) {
          h5(e6, void 0, t6);
        }
        function p5(e6, t6, r6) {
          return b4(e6, t6, r6);
        }
        function y5(e6) {
          b4(e6, void 0, o5);
        }
        let S3 = (e6) => {
          if ("function" == typeof queueMicrotask) S3 = queueMicrotask;
          else {
            const e7 = d4(void 0);
            S3 = (t6) => b4(e7, t6);
          }
          return S3(e6);
        };
        function g4(e6, t6, r6) {
          if ("function" != typeof e6) throw new TypeError("Argument is not a function");
          return Function.prototype.apply.call(e6, t6, r6);
        }
        function v5(e6, t6, r6) {
          try {
            return d4(g4(e6, t6, r6));
          } catch (e7) {
            return f5(e7);
          }
        }
        class w3 {
          constructor() {
            this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(e6) {
            const t6 = this._back;
            let r6 = t6;
            16383 === t6._elements.length && (r6 = { _elements: [], _next: void 0 }), t6._elements.push(e6), r6 !== t6 && (this._back = r6, t6._next = r6), ++this._size;
          }
          shift() {
            const e6 = this._front;
            let t6 = e6;
            const r6 = this._cursor;
            let o6 = r6 + 1;
            const n6 = e6._elements, a6 = n6[r6];
            return 16384 === o6 && (t6 = e6._next, o6 = 0), --this._size, this._cursor = o6, e6 !== t6 && (this._front = t6), n6[r6] = void 0, a6;
          }
          forEach(e6) {
            let t6 = this._cursor, r6 = this._front, o6 = r6._elements;
            for (; !(t6 === o6.length && void 0 === r6._next || t6 === o6.length && (r6 = r6._next, o6 = r6._elements, t6 = 0, 0 === o6.length)); ) e6(o6[t6]), ++t6;
          }
          peek() {
            const e6 = this._front, t6 = this._cursor;
            return e6._elements[t6];
          }
        }
        const R3 = Symbol("[[AbortSteps]]"), T3 = Symbol("[[ErrorSteps]]"), C3 = Symbol("[[CancelSteps]]"), P3 = Symbol("[[PullSteps]]"), q2 = Symbol("[[ReleaseSteps]]");
        function E3(e6, t6) {
          e6._ownerReadableStream = t6, t6._reader = e6, "readable" === t6._state ? j3(e6) : "closed" === t6._state ? function(e7) {
            j3(e7), z3(e7);
          }(e6) : k3(e6, t6._storedError);
        }
        function W2(e6, t6) {
          return Or(e6._ownerReadableStream, t6);
        }
        function B3(e6) {
          const t6 = e6._ownerReadableStream;
          "readable" === t6._state ? A3(e6, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e7, t7) {
            k3(e7, t7);
          }(e6, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), t6._readableStreamController[q2](), t6._reader = void 0, e6._ownerReadableStream = void 0;
        }
        function O4(e6) {
          return new TypeError("Cannot " + e6 + " a stream using a released reader");
        }
        function j3(e6) {
          e6._closedPromise = c5((t6, r6) => {
            e6._closedPromise_resolve = t6, e6._closedPromise_reject = r6;
          });
        }
        function k3(e6, t6) {
          j3(e6), A3(e6, t6);
        }
        function A3(e6, t6) {
          void 0 !== e6._closedPromise_reject && (y5(e6._closedPromise), e6._closedPromise_reject(t6), e6._closedPromise_resolve = void 0, e6._closedPromise_reject = void 0);
        }
        function z3(e6) {
          void 0 !== e6._closedPromise_resolve && (e6._closedPromise_resolve(void 0), e6._closedPromise_resolve = void 0, e6._closedPromise_reject = void 0);
        }
        const D3 = Number.isFinite || function(e6) {
          return "number" == typeof e6 && isFinite(e6);
        }, L3 = Math.trunc || function(e6) {
          return e6 < 0 ? Math.ceil(e6) : Math.floor(e6);
        };
        function F3(e6, t6) {
          if (void 0 !== e6 && ("object" != typeof (r6 = e6) && "function" != typeof r6)) throw new TypeError(`${t6} is not an object.`);
          var r6;
        }
        function I3(e6, t6) {
          if ("function" != typeof e6) throw new TypeError(`${t6} is not a function.`);
        }
        function $2(e6, t6) {
          if (!/* @__PURE__ */ function(e7) {
            return "object" == typeof e7 && null !== e7 || "function" == typeof e7;
          }(e6)) throw new TypeError(`${t6} is not an object.`);
        }
        function M3(e6, t6, r6) {
          if (void 0 === e6) throw new TypeError(`Parameter ${t6} is required in '${r6}'.`);
        }
        function Y3(e6, t6, r6) {
          if (void 0 === e6) throw new TypeError(`${t6} is required in '${r6}'.`);
        }
        function x3(e6) {
          return Number(e6);
        }
        function Q2(e6) {
          return 0 === e6 ? 0 : e6;
        }
        function N3(e6, t6) {
          const r6 = Number.MAX_SAFE_INTEGER;
          let o6 = Number(e6);
          if (o6 = Q2(o6), !D3(o6)) throw new TypeError(`${t6} is not a finite number`);
          if (o6 = function(e7) {
            return Q2(L3(e7));
          }(o6), o6 < 0 || o6 > r6) throw new TypeError(`${t6} is outside the accepted range of 0 to ${r6}, inclusive`);
          return D3(o6) && 0 !== o6 ? o6 : 0;
        }
        function H2(e6, t6) {
          if (!Wr(e6)) throw new TypeError(`${t6} is not a ReadableStream.`);
        }
        function V2(e6) {
          return new ReadableStreamDefaultReader(e6);
        }
        function U3(e6, t6) {
          e6._reader._readRequests.push(t6);
        }
        function G2(e6, t6, r6) {
          const o6 = e6._reader._readRequests.shift();
          r6 ? o6._closeSteps() : o6._chunkSteps(t6);
        }
        function X2(e6) {
          return e6._reader._readRequests.length;
        }
        function J2(e6) {
          const t6 = e6._reader;
          return void 0 !== t6 && !!K2(t6);
        }
        class ReadableStreamDefaultReader {
          constructor(e6) {
            if (M3(e6, 1, "ReadableStreamDefaultReader"), H2(e6, "First parameter"), Br(e6)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            E3(this, e6), this._readRequests = new w3();
          }
          get closed() {
            return K2(this) ? this._closedPromise : f5(te2("closed"));
          }
          cancel(e6 = void 0) {
            return K2(this) ? void 0 === this._ownerReadableStream ? f5(O4("cancel")) : W2(this, e6) : f5(te2("cancel"));
          }
          read() {
            if (!K2(this)) return f5(te2("read"));
            if (void 0 === this._ownerReadableStream) return f5(O4("read from"));
            let e6, t6;
            const r6 = c5((r7, o6) => {
              e6 = r7, t6 = o6;
            });
            return Z2(this, { _chunkSteps: (t7) => e6({ value: t7, done: false }), _closeSteps: () => e6({ value: void 0, done: true }), _errorSteps: (e7) => t6(e7) }), r6;
          }
          releaseLock() {
            if (!K2(this)) throw te2("releaseLock");
            void 0 !== this._ownerReadableStream && function(e6) {
              B3(e6);
              const t6 = new TypeError("Reader was released");
              ee2(e6, t6);
            }(this);
          }
        }
        function K2(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_readRequests") && e6 instanceof ReadableStreamDefaultReader);
        }
        function Z2(e6, t6) {
          const r6 = e6._ownerReadableStream;
          r6._disturbed = true, "closed" === r6._state ? t6._closeSteps() : "errored" === r6._state ? t6._errorSteps(r6._storedError) : r6._readableStreamController[P3](t6);
        }
        function ee2(e6, t6) {
          const r6 = e6._readRequests;
          e6._readRequests = new w3(), r6.forEach((e7) => {
            e7._errorSteps(t6);
          });
        }
        function te2(e6) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${e6} can only be used on a ReadableStreamDefaultReader`);
        }
        var re2, oe2, ne2;
        function ae2(e6) {
          return e6.slice();
        }
        function ie(e6, t6, r6, o6, n6) {
          new Uint8Array(e6).set(new Uint8Array(r6, o6, n6), t6);
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n5(ReadableStreamDefaultReader.prototype.cancel, "cancel"), n5(ReadableStreamDefaultReader.prototype.read, "read"), n5(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true });
        let le2 = (e6) => (le2 = "function" == typeof e6.transfer ? (e7) => e7.transfer() : "function" == typeof structuredClone ? (e7) => structuredClone(e7, { transfer: [e7] }) : (e7) => e7, le2(e6)), se2 = (e6) => (se2 = "boolean" == typeof e6.detached ? (e7) => e7.detached : (e7) => 0 === e7.byteLength, se2(e6));
        function ue2(e6, t6, r6) {
          if (e6.slice) return e6.slice(t6, r6);
          const o6 = r6 - t6, n6 = new ArrayBuffer(o6);
          return ie(n6, 0, e6, t6, o6), n6;
        }
        function ce2(e6, t6) {
          const r6 = e6[t6];
          if (null != r6) {
            if ("function" != typeof r6) throw new TypeError(`${String(t6)} is not a function`);
            return r6;
          }
        }
        function de2(e6) {
          try {
            const t6 = e6.done, r6 = e6.value;
            return b4(u5(r6), (e7) => ({ done: t6, value: e7 }));
          } catch (e7) {
            return f5(e7);
          }
        }
        const fe2 = null !== (ne2 = null !== (re2 = Symbol.asyncIterator) && void 0 !== re2 ? re2 : null === (oe2 = Symbol.for) || void 0 === oe2 ? void 0 : oe2.call(Symbol, "Symbol.asyncIterator")) && void 0 !== ne2 ? ne2 : "@@asyncIterator";
        function be2(e6, t6 = "sync", o6) {
          if (void 0 === o6) if ("async" === t6) {
            if (void 0 === (o6 = ce2(e6, fe2))) {
              return function(e7) {
                const t7 = { next() {
                  let t8;
                  try {
                    t8 = he2(e7);
                  } catch (e8) {
                    return f5(e8);
                  }
                  return de2(t8);
                }, return(t8) {
                  let o7;
                  try {
                    const r6 = ce2(e7.iterator, "return");
                    if (void 0 === r6) return d4({ done: true, value: t8 });
                    o7 = g4(r6, e7.iterator, [t8]);
                  } catch (e8) {
                    return f5(e8);
                  }
                  return r5(o7) ? de2(o7) : f5(new TypeError("The iterator.return() method must return an object"));
                } };
                return { iterator: t7, nextMethod: t7.next, done: false };
              }(be2(e6, "sync", ce2(e6, Symbol.iterator)));
            }
          } else o6 = ce2(e6, Symbol.iterator);
          if (void 0 === o6) throw new TypeError("The object is not iterable");
          const n6 = g4(o6, e6, []);
          if (!r5(n6)) throw new TypeError("The iterator method must return an object");
          return { iterator: n6, nextMethod: n6.next, done: false };
        }
        function he2(e6) {
          const t6 = g4(e6.nextMethod, e6.iterator, []);
          if (!r5(t6)) throw new TypeError("The iterator.next() method must return an object");
          return t6;
        }
        class me2 {
          constructor(e6, t6) {
            this._ongoingPromise = void 0, this._isFinished = false, this._reader = e6, this._preventCancel = t6;
          }
          next() {
            const e6 = () => this._nextSteps();
            return this._ongoingPromise = this._ongoingPromise ? p5(this._ongoingPromise, e6, e6) : e6(), this._ongoingPromise;
          }
          return(e6) {
            const t6 = () => this._returnSteps(e6);
            return this._ongoingPromise = this._ongoingPromise ? p5(this._ongoingPromise, t6, t6) : t6(), this._ongoingPromise;
          }
          _nextSteps() {
            if (this._isFinished) return Promise.resolve({ value: void 0, done: true });
            const e6 = this._reader;
            let t6, r6;
            const o6 = c5((e7, o7) => {
              t6 = e7, r6 = o7;
            });
            return Z2(e6, { _chunkSteps: (e7) => {
              this._ongoingPromise = void 0, S3(() => t6({ value: e7, done: false }));
            }, _closeSteps: () => {
              this._ongoingPromise = void 0, this._isFinished = true, B3(e6), t6({ value: void 0, done: true });
            }, _errorSteps: (t7) => {
              this._ongoingPromise = void 0, this._isFinished = true, B3(e6), r6(t7);
            } }), o6;
          }
          _returnSteps(e6) {
            if (this._isFinished) return Promise.resolve({ value: e6, done: true });
            this._isFinished = true;
            const t6 = this._reader;
            if (!this._preventCancel) {
              const r6 = W2(t6, e6);
              return B3(t6), p5(r6, () => ({ value: e6, done: true }));
            }
            return B3(t6), d4({ value: e6, done: true });
          }
        }
        const _e = { next() {
          return pe2(this) ? this._asyncIteratorImpl.next() : f5(ye2("next"));
        }, return(e6) {
          return pe2(this) ? this._asyncIteratorImpl.return(e6) : f5(ye2("return"));
        }, [fe2]() {
          return this;
        } };
        function pe2(e6) {
          if (!r5(e6)) return false;
          if (!Object.prototype.hasOwnProperty.call(e6, "_asyncIteratorImpl")) return false;
          try {
            return e6._asyncIteratorImpl instanceof me2;
          } catch (e7) {
            return false;
          }
        }
        function ye2(e6) {
          return new TypeError(`ReadableStreamAsyncIterator.${e6} can only be used on a ReadableSteamAsyncIterator`);
        }
        Object.defineProperty(_e, fe2, { enumerable: false });
        const Se2 = Number.isNaN || function(e6) {
          return e6 != e6;
        };
        function ge2(e6) {
          const t6 = ue2(e6.buffer, e6.byteOffset, e6.byteOffset + e6.byteLength);
          return new Uint8Array(t6);
        }
        function ve2(e6) {
          const t6 = e6._queue.shift();
          return e6._queueTotalSize -= t6.size, e6._queueTotalSize < 0 && (e6._queueTotalSize = 0), t6.value;
        }
        function we2(e6, t6, r6) {
          if ("number" != typeof (o6 = r6) || Se2(o6) || o6 < 0 || r6 === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          var o6;
          e6._queue.push({ value: t6, size: r6 }), e6._queueTotalSize += r6;
        }
        function Re(e6) {
          e6._queue = new w3(), e6._queueTotalSize = 0;
        }
        function Te(e6) {
          return e6 === DataView;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!Pe(this)) throw Ze("view");
            return this._view;
          }
          respond(e6) {
            if (!Pe(this)) throw Ze("respond");
            if (M3(e6, 1, "respond"), e6 = N3(e6, "First parameter"), void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
            if (se2(this._view.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
            Xe(this._associatedReadableByteStreamController, e6);
          }
          respondWithNewView(e6) {
            if (!Pe(this)) throw Ze("respondWithNewView");
            if (M3(e6, 1, "respondWithNewView"), !ArrayBuffer.isView(e6)) throw new TypeError("You can only respond with array buffer views");
            if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
            if (se2(e6.buffer)) throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
            Je(this._associatedReadableByteStreamController, e6);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), n5(ReadableStreamBYOBRequest.prototype.respond, "respond"), n5(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!Ce(this)) throw et("byobRequest");
            return Ue(this);
          }
          get desiredSize() {
            if (!Ce(this)) throw et("desiredSize");
            return Ge(this);
          }
          close() {
            if (!Ce(this)) throw et("close");
            if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
            const e6 = this._controlledReadableByteStream._state;
            if ("readable" !== e6) throw new TypeError(`The stream (in ${e6} state) is not in the readable state and cannot be closed`);
            Qe(this);
          }
          enqueue(e6) {
            if (!Ce(this)) throw et("enqueue");
            if (M3(e6, 1, "enqueue"), !ArrayBuffer.isView(e6)) throw new TypeError("chunk must be an array buffer view");
            if (0 === e6.byteLength) throw new TypeError("chunk must have non-zero byteLength");
            if (0 === e6.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength");
            if (this._closeRequested) throw new TypeError("stream is closed or draining");
            const t6 = this._controlledReadableByteStream._state;
            if ("readable" !== t6) throw new TypeError(`The stream (in ${t6} state) is not in the readable state and cannot be enqueued to`);
            Ne(this, e6);
          }
          error(e6 = void 0) {
            if (!Ce(this)) throw et("error");
            He(this, e6);
          }
          [C3](e6) {
            Ee2(this), Re(this);
            const t6 = this._cancelAlgorithm(e6);
            return xe(this), t6;
          }
          [P3](e6) {
            const t6 = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) return void Ve(this, e6);
            const r6 = this._autoAllocateChunkSize;
            if (void 0 !== r6) {
              let t7;
              try {
                t7 = new ArrayBuffer(r6);
              } catch (t8) {
                return void e6._errorSteps(t8);
              }
              const o6 = { buffer: t7, bufferByteLength: r6, byteOffset: 0, byteLength: r6, bytesFilled: 0, minimumFill: 1, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
              this._pendingPullIntos.push(o6);
            }
            U3(t6, e6), qe(this);
          }
          [q2]() {
            if (this._pendingPullIntos.length > 0) {
              const e6 = this._pendingPullIntos.peek();
              e6.readerType = "none", this._pendingPullIntos = new w3(), this._pendingPullIntos.push(e6);
            }
          }
        }
        function Ce(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_controlledReadableByteStream") && e6 instanceof ReadableByteStreamController);
        }
        function Pe(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_associatedReadableByteStreamController") && e6 instanceof ReadableStreamBYOBRequest);
        }
        function qe(e6) {
          const t6 = function(e7) {
            const t7 = e7._controlledReadableByteStream;
            if ("readable" !== t7._state) return false;
            if (e7._closeRequested) return false;
            if (!e7._started) return false;
            if (J2(t7) && X2(t7) > 0) return true;
            if (at(t7) && nt(t7) > 0) return true;
            const r6 = Ge(e7);
            if (r6 > 0) return true;
            return false;
          }(e6);
          if (!t6) return;
          if (e6._pulling) return void (e6._pullAgain = true);
          e6._pulling = true;
          h5(e6._pullAlgorithm(), () => (e6._pulling = false, e6._pullAgain && (e6._pullAgain = false, qe(e6)), null), (t7) => (He(e6, t7), null));
        }
        function Ee2(e6) {
          Fe(e6), e6._pendingPullIntos = new w3();
        }
        function We(e6, t6) {
          let r6 = false;
          "closed" === e6._state && (r6 = true);
          const o6 = Oe2(t6);
          "default" === t6.readerType ? G2(e6, o6, r6) : function(e7, t7, r7) {
            const o7 = e7._reader, n6 = o7._readIntoRequests.shift();
            r7 ? n6._closeSteps(t7) : n6._chunkSteps(t7);
          }(e6, o6, r6);
        }
        function Be2(e6, t6) {
          for (let r6 = 0; r6 < t6.length; ++r6) We(e6, t6[r6]);
        }
        function Oe2(e6) {
          const t6 = e6.bytesFilled, r6 = e6.elementSize;
          return new e6.viewConstructor(e6.buffer, e6.byteOffset, t6 / r6);
        }
        function je2(e6, t6, r6, o6) {
          e6._queue.push({ buffer: t6, byteOffset: r6, byteLength: o6 }), e6._queueTotalSize += o6;
        }
        function ke2(e6, t6, r6, o6) {
          let n6;
          try {
            n6 = ue2(t6, r6, r6 + o6);
          } catch (t7) {
            throw He(e6, t7), t7;
          }
          je2(e6, n6, 0, o6);
        }
        function Ae2(e6, t6) {
          t6.bytesFilled > 0 && ke2(e6, t6.buffer, t6.byteOffset, t6.bytesFilled), Ye(e6);
        }
        function ze(e6, t6) {
          const r6 = Math.min(e6._queueTotalSize, t6.byteLength - t6.bytesFilled), o6 = t6.bytesFilled + r6;
          let n6 = r6, a6 = false;
          const i6 = o6 - o6 % t6.elementSize;
          i6 >= t6.minimumFill && (n6 = i6 - t6.bytesFilled, a6 = true);
          const l6 = e6._queue;
          for (; n6 > 0; ) {
            const r7 = l6.peek(), o7 = Math.min(n6, r7.byteLength), a7 = t6.byteOffset + t6.bytesFilled;
            ie(t6.buffer, a7, r7.buffer, r7.byteOffset, o7), r7.byteLength === o7 ? l6.shift() : (r7.byteOffset += o7, r7.byteLength -= o7), e6._queueTotalSize -= o7, De2(e6, o7, t6), n6 -= o7;
          }
          return a6;
        }
        function De2(e6, t6, r6) {
          r6.bytesFilled += t6;
        }
        function Le(e6) {
          0 === e6._queueTotalSize && e6._closeRequested ? (xe(e6), jr(e6._controlledReadableByteStream)) : qe(e6);
        }
        function Fe(e6) {
          null !== e6._byobRequest && (e6._byobRequest._associatedReadableByteStreamController = void 0, e6._byobRequest._view = null, e6._byobRequest = null);
        }
        function Ie(e6) {
          const t6 = [];
          for (; e6._pendingPullIntos.length > 0 && 0 !== e6._queueTotalSize; ) {
            const r6 = e6._pendingPullIntos.peek();
            ze(e6, r6) && (Ye(e6), t6.push(r6));
          }
          return t6;
        }
        function $e(e6, t6, r6, o6) {
          const n6 = e6._controlledReadableByteStream, a6 = t6.constructor, i6 = function(e7) {
            return Te(e7) ? 1 : e7.BYTES_PER_ELEMENT;
          }(a6), { byteOffset: l6, byteLength: s6 } = t6, u6 = r6 * i6;
          let c6;
          try {
            c6 = le2(t6.buffer);
          } catch (e7) {
            return void o6._errorSteps(e7);
          }
          const d5 = { buffer: c6, bufferByteLength: c6.byteLength, byteOffset: l6, byteLength: s6, bytesFilled: 0, minimumFill: u6, elementSize: i6, viewConstructor: a6, readerType: "byob" };
          if (e6._pendingPullIntos.length > 0) return e6._pendingPullIntos.push(d5), void ot(n6, o6);
          if ("closed" !== n6._state) {
            if (e6._queueTotalSize > 0) {
              if (ze(e6, d5)) {
                const t7 = Oe2(d5);
                return Le(e6), void o6._chunkSteps(t7);
              }
              if (e6._closeRequested) {
                const t7 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                return He(e6, t7), void o6._errorSteps(t7);
              }
            }
            e6._pendingPullIntos.push(d5), ot(n6, o6), qe(e6);
          } else {
            const e7 = new a6(d5.buffer, d5.byteOffset, 0);
            o6._closeSteps(e7);
          }
        }
        function Me(e6, t6) {
          const r6 = e6._pendingPullIntos.peek();
          Fe(e6);
          "closed" === e6._controlledReadableByteStream._state ? function(e7, t7) {
            "none" === t7.readerType && Ye(e7);
            const r7 = e7._controlledReadableByteStream;
            if (at(r7)) {
              const t8 = [];
              for (let o6 = 0; o6 < nt(r7); ++o6) t8.push(Ye(e7));
              Be2(r7, t8);
            }
          }(e6, r6) : function(e7, t7, r7) {
            if (De2(0, t7, r7), "none" === r7.readerType) {
              Ae2(e7, r7);
              const t8 = Ie(e7);
              return void Be2(e7._controlledReadableByteStream, t8);
            }
            if (r7.bytesFilled < r7.minimumFill) return;
            Ye(e7);
            const o6 = r7.bytesFilled % r7.elementSize;
            if (o6 > 0) {
              const t8 = r7.byteOffset + r7.bytesFilled;
              ke2(e7, r7.buffer, t8 - o6, o6);
            }
            r7.bytesFilled -= o6;
            const n6 = Ie(e7);
            We(e7._controlledReadableByteStream, r7), Be2(e7._controlledReadableByteStream, n6);
          }(e6, t6, r6), qe(e6);
        }
        function Ye(e6) {
          return e6._pendingPullIntos.shift();
        }
        function xe(e6) {
          e6._pullAlgorithm = void 0, e6._cancelAlgorithm = void 0;
        }
        function Qe(e6) {
          const t6 = e6._controlledReadableByteStream;
          if (!e6._closeRequested && "readable" === t6._state) if (e6._queueTotalSize > 0) e6._closeRequested = true;
          else {
            if (e6._pendingPullIntos.length > 0) {
              const t7 = e6._pendingPullIntos.peek();
              if (t7.bytesFilled % t7.elementSize != 0) {
                const t8 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                throw He(e6, t8), t8;
              }
            }
            xe(e6), jr(t6);
          }
        }
        function Ne(e6, t6) {
          const r6 = e6._controlledReadableByteStream;
          if (e6._closeRequested || "readable" !== r6._state) return;
          const { buffer: o6, byteOffset: n6, byteLength: a6 } = t6;
          if (se2(o6)) throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
          const i6 = le2(o6);
          if (e6._pendingPullIntos.length > 0) {
            const t7 = e6._pendingPullIntos.peek();
            if (se2(t7.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
            Fe(e6), t7.buffer = le2(t7.buffer), "none" === t7.readerType && Ae2(e6, t7);
          }
          if (J2(r6)) if (function(e7) {
            const t7 = e7._controlledReadableByteStream._reader;
            for (; t7._readRequests.length > 0; ) {
              if (0 === e7._queueTotalSize) return;
              Ve(e7, t7._readRequests.shift());
            }
          }(e6), 0 === X2(r6)) je2(e6, i6, n6, a6);
          else {
            e6._pendingPullIntos.length > 0 && Ye(e6);
            G2(r6, new Uint8Array(i6, n6, a6), false);
          }
          else if (at(r6)) {
            je2(e6, i6, n6, a6);
            const t7 = Ie(e6);
            Be2(e6._controlledReadableByteStream, t7);
          } else je2(e6, i6, n6, a6);
          qe(e6);
        }
        function He(e6, t6) {
          const r6 = e6._controlledReadableByteStream;
          "readable" === r6._state && (Ee2(e6), Re(e6), xe(e6), kr(r6, t6));
        }
        function Ve(e6, t6) {
          const r6 = e6._queue.shift();
          e6._queueTotalSize -= r6.byteLength, Le(e6);
          const o6 = new Uint8Array(r6.buffer, r6.byteOffset, r6.byteLength);
          t6._chunkSteps(o6);
        }
        function Ue(e6) {
          if (null === e6._byobRequest && e6._pendingPullIntos.length > 0) {
            const t6 = e6._pendingPullIntos.peek(), r6 = new Uint8Array(t6.buffer, t6.byteOffset + t6.bytesFilled, t6.byteLength - t6.bytesFilled), o6 = Object.create(ReadableStreamBYOBRequest.prototype);
            !function(e7, t7, r7) {
              e7._associatedReadableByteStreamController = t7, e7._view = r7;
            }(o6, e6, r6), e6._byobRequest = o6;
          }
          return e6._byobRequest;
        }
        function Ge(e6) {
          const t6 = e6._controlledReadableByteStream._state;
          return "errored" === t6 ? null : "closed" === t6 ? 0 : e6._strategyHWM - e6._queueTotalSize;
        }
        function Xe(e6, t6) {
          const r6 = e6._pendingPullIntos.peek();
          if ("closed" === e6._controlledReadableByteStream._state) {
            if (0 !== t6) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          } else {
            if (0 === t6) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            if (r6.bytesFilled + t6 > r6.byteLength) throw new RangeError("bytesWritten out of range");
          }
          r6.buffer = le2(r6.buffer), Me(e6, t6);
        }
        function Je(e6, t6) {
          const r6 = e6._pendingPullIntos.peek();
          if ("closed" === e6._controlledReadableByteStream._state) {
            if (0 !== t6.byteLength) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          } else if (0 === t6.byteLength) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          if (r6.byteOffset + r6.bytesFilled !== t6.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
          if (r6.bufferByteLength !== t6.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
          if (r6.bytesFilled + t6.byteLength > r6.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
          const o6 = t6.byteLength;
          r6.buffer = le2(t6.buffer), Me(e6, o6);
        }
        function Ke(e6, t6, r6, o6, n6, a6, i6) {
          t6._controlledReadableByteStream = e6, t6._pullAgain = false, t6._pulling = false, t6._byobRequest = null, t6._queue = t6._queueTotalSize = void 0, Re(t6), t6._closeRequested = false, t6._started = false, t6._strategyHWM = a6, t6._pullAlgorithm = o6, t6._cancelAlgorithm = n6, t6._autoAllocateChunkSize = i6, t6._pendingPullIntos = new w3(), e6._readableStreamController = t6;
          h5(d4(r6()), () => (t6._started = true, qe(t6), null), (e7) => (He(t6, e7), null));
        }
        function Ze(e6) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${e6} can only be used on a ReadableStreamBYOBRequest`);
        }
        function et(e6) {
          return new TypeError(`ReadableByteStreamController.prototype.${e6} can only be used on a ReadableByteStreamController`);
        }
        function tt(e6, t6) {
          if ("byob" !== (e6 = `${e6}`)) throw new TypeError(`${t6} '${e6}' is not a valid enumeration value for ReadableStreamReaderMode`);
          return e6;
        }
        function rt(e6) {
          return new ReadableStreamBYOBReader(e6);
        }
        function ot(e6, t6) {
          e6._reader._readIntoRequests.push(t6);
        }
        function nt(e6) {
          return e6._reader._readIntoRequests.length;
        }
        function at(e6) {
          const t6 = e6._reader;
          return void 0 !== t6 && !!it(t6);
        }
        Object.defineProperties(ReadableByteStreamController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), n5(ReadableByteStreamController.prototype.close, "close"), n5(ReadableByteStreamController.prototype.enqueue, "enqueue"), n5(ReadableByteStreamController.prototype.error, "error"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, { value: "ReadableByteStreamController", configurable: true });
        class ReadableStreamBYOBReader {
          constructor(e6) {
            if (M3(e6, 1, "ReadableStreamBYOBReader"), H2(e6, "First parameter"), Br(e6)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            if (!Ce(e6._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            E3(this, e6), this._readIntoRequests = new w3();
          }
          get closed() {
            return it(this) ? this._closedPromise : f5(ut("closed"));
          }
          cancel(e6 = void 0) {
            return it(this) ? void 0 === this._ownerReadableStream ? f5(O4("cancel")) : W2(this, e6) : f5(ut("cancel"));
          }
          read(e6, t6 = {}) {
            if (!it(this)) return f5(ut("read"));
            if (!ArrayBuffer.isView(e6)) return f5(new TypeError("view must be an array buffer view"));
            if (0 === e6.byteLength) return f5(new TypeError("view must have non-zero byteLength"));
            if (0 === e6.buffer.byteLength) return f5(new TypeError("view's buffer must have non-zero byteLength"));
            if (se2(e6.buffer)) return f5(new TypeError("view's buffer has been detached"));
            let r6;
            try {
              r6 = function(e7, t7) {
                var r7;
                return F3(e7, t7), { min: N3(null !== (r7 = null == e7 ? void 0 : e7.min) && void 0 !== r7 ? r7 : 1, `${t7} has member 'min' that`) };
              }(t6, "options");
            } catch (e7) {
              return f5(e7);
            }
            const o6 = r6.min;
            if (0 === o6) return f5(new TypeError("options.min must be greater than 0"));
            if (function(e7) {
              return Te(e7.constructor);
            }(e6)) {
              if (o6 > e6.byteLength) return f5(new RangeError("options.min must be less than or equal to view's byteLength"));
            } else if (o6 > e6.length) return f5(new RangeError("options.min must be less than or equal to view's length"));
            if (void 0 === this._ownerReadableStream) return f5(O4("read from"));
            let n6, a6;
            const i6 = c5((e7, t7) => {
              n6 = e7, a6 = t7;
            });
            return lt(this, e6, o6, { _chunkSteps: (e7) => n6({ value: e7, done: false }), _closeSteps: (e7) => n6({ value: e7, done: true }), _errorSteps: (e7) => a6(e7) }), i6;
          }
          releaseLock() {
            if (!it(this)) throw ut("releaseLock");
            void 0 !== this._ownerReadableStream && function(e6) {
              B3(e6);
              const t6 = new TypeError("Reader was released");
              st(e6, t6);
            }(this);
          }
        }
        function it(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_readIntoRequests") && e6 instanceof ReadableStreamBYOBReader);
        }
        function lt(e6, t6, r6, o6) {
          const n6 = e6._ownerReadableStream;
          n6._disturbed = true, "errored" === n6._state ? o6._errorSteps(n6._storedError) : $e(n6._readableStreamController, t6, r6, o6);
        }
        function st(e6, t6) {
          const r6 = e6._readIntoRequests;
          e6._readIntoRequests = new w3(), r6.forEach((e7) => {
            e7._errorSteps(t6);
          });
        }
        function ut(e6) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${e6} can only be used on a ReadableStreamBYOBReader`);
        }
        function ct(e6, t6) {
          const { highWaterMark: r6 } = e6;
          if (void 0 === r6) return t6;
          if (Se2(r6) || r6 < 0) throw new RangeError("Invalid highWaterMark");
          return r6;
        }
        function dt(e6) {
          const { size: t6 } = e6;
          return t6 || (() => 1);
        }
        function ft(e6, t6) {
          F3(e6, t6);
          const r6 = null == e6 ? void 0 : e6.highWaterMark, o6 = null == e6 ? void 0 : e6.size;
          return { highWaterMark: void 0 === r6 ? void 0 : x3(r6), size: void 0 === o6 ? void 0 : bt(o6, `${t6} has member 'size' that`) };
        }
        function bt(e6, t6) {
          return I3(e6, t6), (t7) => x3(e6(t7));
        }
        function ht(e6, t6, r6) {
          return I3(e6, r6), (r7) => v5(e6, t6, [r7]);
        }
        function mt(e6, t6, r6) {
          return I3(e6, r6), () => v5(e6, t6, []);
        }
        function _t(e6, t6, r6) {
          return I3(e6, r6), (r7) => g4(e6, t6, [r7]);
        }
        function pt(e6, t6, r6) {
          return I3(e6, r6), (r7, o6) => v5(e6, t6, [r7, o6]);
        }
        function yt(e6, t6) {
          if (!vt(e6)) throw new TypeError(`${t6} is not a WritableStream.`);
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n5(ReadableStreamBYOBReader.prototype.cancel, "cancel"), n5(ReadableStreamBYOBReader.prototype.read, "read"), n5(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
        class WritableStream2 {
          constructor(e6 = {}, t6 = {}) {
            void 0 === e6 ? e6 = null : $2(e6, "First parameter");
            const r6 = ft(t6, "Second parameter"), o6 = function(e7, t7) {
              F3(e7, t7);
              const r7 = null == e7 ? void 0 : e7.abort, o7 = null == e7 ? void 0 : e7.close, n7 = null == e7 ? void 0 : e7.start, a6 = null == e7 ? void 0 : e7.type, i6 = null == e7 ? void 0 : e7.write;
              return { abort: void 0 === r7 ? void 0 : ht(r7, e7, `${t7} has member 'abort' that`), close: void 0 === o7 ? void 0 : mt(o7, e7, `${t7} has member 'close' that`), start: void 0 === n7 ? void 0 : _t(n7, e7, `${t7} has member 'start' that`), write: void 0 === i6 ? void 0 : pt(i6, e7, `${t7} has member 'write' that`), type: a6 };
            }(e6, "First parameter");
            gt(this);
            if (void 0 !== o6.type) throw new RangeError("Invalid type is specified");
            const n6 = dt(r6);
            !function(e7, t7, r7, o7) {
              const n7 = Object.create(WritableStreamDefaultController.prototype);
              let a6, i6, l6, s6;
              a6 = void 0 !== t7.start ? () => t7.start(n7) : () => {
              };
              i6 = void 0 !== t7.write ? (e8) => t7.write(e8, n7) : () => d4(void 0);
              l6 = void 0 !== t7.close ? () => t7.close() : () => d4(void 0);
              s6 = void 0 !== t7.abort ? (e8) => t7.abort(e8) : () => d4(void 0);
              It(e7, n7, a6, i6, l6, s6, r7, o7);
            }(this, o6, ct(r6, 1), n6);
          }
          get locked() {
            if (!vt(this)) throw Ht("locked");
            return wt(this);
          }
          abort(e6 = void 0) {
            return vt(this) ? wt(this) ? f5(new TypeError("Cannot abort a stream that already has a writer")) : Rt(this, e6) : f5(Ht("abort"));
          }
          close() {
            return vt(this) ? wt(this) ? f5(new TypeError("Cannot close a stream that already has a writer")) : Et(this) ? f5(new TypeError("Cannot close an already-closing stream")) : Tt(this) : f5(Ht("close"));
          }
          getWriter() {
            if (!vt(this)) throw Ht("getWriter");
            return St(this);
          }
        }
        function St(e6) {
          return new WritableStreamDefaultWriter(e6);
        }
        function gt(e6) {
          e6._state = "writable", e6._storedError = void 0, e6._writer = void 0, e6._writableStreamController = void 0, e6._writeRequests = new w3(), e6._inFlightWriteRequest = void 0, e6._closeRequest = void 0, e6._inFlightCloseRequest = void 0, e6._pendingAbortRequest = void 0, e6._backpressure = false;
        }
        function vt(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_writableStreamController") && e6 instanceof WritableStream2);
        }
        function wt(e6) {
          return void 0 !== e6._writer;
        }
        function Rt(e6, t6) {
          var r6;
          if ("closed" === e6._state || "errored" === e6._state) return d4(void 0);
          e6._writableStreamController._abortReason = t6, null === (r6 = e6._writableStreamController._abortController) || void 0 === r6 || r6.abort(t6);
          const o6 = e6._state;
          if ("closed" === o6 || "errored" === o6) return d4(void 0);
          if (void 0 !== e6._pendingAbortRequest) return e6._pendingAbortRequest._promise;
          let n6 = false;
          "erroring" === o6 && (n6 = true, t6 = void 0);
          const a6 = c5((r7, o7) => {
            e6._pendingAbortRequest = { _promise: void 0, _resolve: r7, _reject: o7, _reason: t6, _wasAlreadyErroring: n6 };
          });
          return e6._pendingAbortRequest._promise = a6, n6 || Pt(e6, t6), a6;
        }
        function Tt(e6) {
          const t6 = e6._state;
          if ("closed" === t6 || "errored" === t6) return f5(new TypeError(`The stream (in ${t6} state) is not in the writable state and cannot be closed`));
          const r6 = c5((t7, r7) => {
            const o7 = { _resolve: t7, _reject: r7 };
            e6._closeRequest = o7;
          }), o6 = e6._writer;
          var n6;
          return void 0 !== o6 && e6._backpressure && "writable" === t6 && nr(o6), we2(n6 = e6._writableStreamController, Lt, 0), Yt(n6), r6;
        }
        function Ct(e6, t6) {
          "writable" !== e6._state ? qt(e6) : Pt(e6, t6);
        }
        function Pt(e6, t6) {
          const r6 = e6._writableStreamController;
          e6._state = "erroring", e6._storedError = t6;
          const o6 = e6._writer;
          void 0 !== o6 && At(o6, t6), !function(e7) {
            if (void 0 === e7._inFlightWriteRequest && void 0 === e7._inFlightCloseRequest) return false;
            return true;
          }(e6) && r6._started && qt(e6);
        }
        function qt(e6) {
          e6._state = "errored", e6._writableStreamController[T3]();
          const t6 = e6._storedError;
          if (e6._writeRequests.forEach((e7) => {
            e7._reject(t6);
          }), e6._writeRequests = new w3(), void 0 === e6._pendingAbortRequest) return void Wt(e6);
          const r6 = e6._pendingAbortRequest;
          if (e6._pendingAbortRequest = void 0, r6._wasAlreadyErroring) return r6._reject(t6), void Wt(e6);
          h5(e6._writableStreamController[R3](r6._reason), () => (r6._resolve(), Wt(e6), null), (t7) => (r6._reject(t7), Wt(e6), null));
        }
        function Et(e6) {
          return void 0 !== e6._closeRequest || void 0 !== e6._inFlightCloseRequest;
        }
        function Wt(e6) {
          void 0 !== e6._closeRequest && (e6._closeRequest._reject(e6._storedError), e6._closeRequest = void 0);
          const t6 = e6._writer;
          void 0 !== t6 && Kt(t6, e6._storedError);
        }
        function Bt(e6, t6) {
          const r6 = e6._writer;
          void 0 !== r6 && t6 !== e6._backpressure && (t6 ? function(e7) {
            er(e7);
          }(r6) : nr(r6)), e6._backpressure = t6;
        }
        Object.defineProperties(WritableStream2.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), n5(WritableStream2.prototype.abort, "abort"), n5(WritableStream2.prototype.close, "close"), n5(WritableStream2.prototype.getWriter, "getWriter"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStream2.prototype, Symbol.toStringTag, { value: "WritableStream", configurable: true });
        class WritableStreamDefaultWriter {
          constructor(e6) {
            if (M3(e6, 1, "WritableStreamDefaultWriter"), yt(e6, "First parameter"), wt(e6)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            this._ownerWritableStream = e6, e6._writer = this;
            const t6 = e6._state;
            if ("writable" === t6) !Et(e6) && e6._backpressure ? er(this) : rr(this), Xt(this);
            else if ("erroring" === t6) tr(this, e6._storedError), Xt(this);
            else if ("closed" === t6) rr(this), Xt(r6 = this), Zt(r6);
            else {
              const t7 = e6._storedError;
              tr(this, t7), Jt(this, t7);
            }
            var r6;
          }
          get closed() {
            return Ot(this) ? this._closedPromise : f5(Ut("closed"));
          }
          get desiredSize() {
            if (!Ot(this)) throw Ut("desiredSize");
            if (void 0 === this._ownerWritableStream) throw Gt("desiredSize");
            return function(e6) {
              const t6 = e6._ownerWritableStream, r6 = t6._state;
              if ("errored" === r6 || "erroring" === r6) return null;
              if ("closed" === r6) return 0;
              return Mt(t6._writableStreamController);
            }(this);
          }
          get ready() {
            return Ot(this) ? this._readyPromise : f5(Ut("ready"));
          }
          abort(e6 = void 0) {
            return Ot(this) ? void 0 === this._ownerWritableStream ? f5(Gt("abort")) : function(e7, t6) {
              return Rt(e7._ownerWritableStream, t6);
            }(this, e6) : f5(Ut("abort"));
          }
          close() {
            if (!Ot(this)) return f5(Ut("close"));
            const e6 = this._ownerWritableStream;
            return void 0 === e6 ? f5(Gt("close")) : Et(e6) ? f5(new TypeError("Cannot close an already-closing stream")) : jt(this);
          }
          releaseLock() {
            if (!Ot(this)) throw Ut("releaseLock");
            void 0 !== this._ownerWritableStream && zt(this);
          }
          write(e6 = void 0) {
            return Ot(this) ? void 0 === this._ownerWritableStream ? f5(Gt("write to")) : Dt(this, e6) : f5(Ut("write"));
          }
        }
        function Ot(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_ownerWritableStream") && e6 instanceof WritableStreamDefaultWriter);
        }
        function jt(e6) {
          return Tt(e6._ownerWritableStream);
        }
        function kt(e6, t6) {
          "pending" === e6._closedPromiseState ? Kt(e6, t6) : function(e7, t7) {
            Jt(e7, t7);
          }(e6, t6);
        }
        function At(e6, t6) {
          "pending" === e6._readyPromiseState ? or(e6, t6) : function(e7, t7) {
            tr(e7, t7);
          }(e6, t6);
        }
        function zt(e6) {
          const t6 = e6._ownerWritableStream, r6 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
          At(e6, r6), kt(e6, r6), t6._writer = void 0, e6._ownerWritableStream = void 0;
        }
        function Dt(e6, t6) {
          const r6 = e6._ownerWritableStream, o6 = r6._writableStreamController, n6 = function(e7, t7) {
            if (void 0 === e7._strategySizeAlgorithm) return 1;
            try {
              return e7._strategySizeAlgorithm(t7);
            } catch (t8) {
              return xt(e7, t8), 1;
            }
          }(o6, t6);
          if (r6 !== e6._ownerWritableStream) return f5(Gt("write to"));
          const a6 = r6._state;
          if ("errored" === a6) return f5(r6._storedError);
          if (Et(r6) || "closed" === a6) return f5(new TypeError("The stream is closing or closed and cannot be written to"));
          if ("erroring" === a6) return f5(r6._storedError);
          const i6 = function(e7) {
            return c5((t7, r7) => {
              const o7 = { _resolve: t7, _reject: r7 };
              e7._writeRequests.push(o7);
            });
          }(r6);
          return function(e7, t7, r7) {
            try {
              we2(e7, t7, r7);
            } catch (t8) {
              return void xt(e7, t8);
            }
            const o7 = e7._controlledWritableStream;
            if (!Et(o7) && "writable" === o7._state) {
              Bt(o7, Qt(e7));
            }
            Yt(e7);
          }(o6, t6, n6), i6;
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), n5(WritableStreamDefaultWriter.prototype.abort, "abort"), n5(WritableStreamDefaultWriter.prototype.close, "close"), n5(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock"), n5(WritableStreamDefaultWriter.prototype.write, "write"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
        const Lt = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!Ft(this)) throw Vt("abortReason");
            return this._abortReason;
          }
          get signal() {
            if (!Ft(this)) throw Vt("signal");
            if (void 0 === this._abortController) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            return this._abortController.signal;
          }
          error(e6 = void 0) {
            if (!Ft(this)) throw Vt("error");
            "writable" === this._controlledWritableStream._state && Nt(this, e6);
          }
          [R3](e6) {
            const t6 = this._abortAlgorithm(e6);
            return $t(this), t6;
          }
          [T3]() {
            Re(this);
          }
        }
        function Ft(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_controlledWritableStream") && e6 instanceof WritableStreamDefaultController);
        }
        function It(e6, t6, r6, o6, n6, a6, i6, l6) {
          t6._controlledWritableStream = e6, e6._writableStreamController = t6, t6._queue = void 0, t6._queueTotalSize = void 0, Re(t6), t6._abortReason = void 0, t6._abortController = function() {
            if ("function" == typeof AbortController) return new AbortController();
          }(), t6._started = false, t6._strategySizeAlgorithm = l6, t6._strategyHWM = i6, t6._writeAlgorithm = o6, t6._closeAlgorithm = n6, t6._abortAlgorithm = a6;
          const s6 = Qt(t6);
          Bt(e6, s6);
          h5(d4(r6()), () => (t6._started = true, Yt(t6), null), (r7) => (t6._started = true, Ct(e6, r7), null));
        }
        function $t(e6) {
          e6._writeAlgorithm = void 0, e6._closeAlgorithm = void 0, e6._abortAlgorithm = void 0, e6._strategySizeAlgorithm = void 0;
        }
        function Mt(e6) {
          return e6._strategyHWM - e6._queueTotalSize;
        }
        function Yt(e6) {
          const t6 = e6._controlledWritableStream;
          if (!e6._started) return;
          if (void 0 !== t6._inFlightWriteRequest) return;
          if ("erroring" === t6._state) return void qt(t6);
          if (0 === e6._queue.length) return;
          const r6 = e6._queue.peek().value;
          r6 === Lt ? function(e7) {
            const t7 = e7._controlledWritableStream;
            (function(e8) {
              e8._inFlightCloseRequest = e8._closeRequest, e8._closeRequest = void 0;
            })(t7), ve2(e7);
            const r7 = e7._closeAlgorithm();
            $t(e7), h5(r7, () => (function(e8) {
              e8._inFlightCloseRequest._resolve(void 0), e8._inFlightCloseRequest = void 0, "erroring" === e8._state && (e8._storedError = void 0, void 0 !== e8._pendingAbortRequest && (e8._pendingAbortRequest._resolve(), e8._pendingAbortRequest = void 0)), e8._state = "closed";
              const t8 = e8._writer;
              void 0 !== t8 && Zt(t8);
            }(t7), null), (e8) => (function(e9, t8) {
              e9._inFlightCloseRequest._reject(t8), e9._inFlightCloseRequest = void 0, void 0 !== e9._pendingAbortRequest && (e9._pendingAbortRequest._reject(t8), e9._pendingAbortRequest = void 0), Ct(e9, t8);
            }(t7, e8), null));
          }(e6) : function(e7, t7) {
            const r7 = e7._controlledWritableStream;
            !function(e8) {
              e8._inFlightWriteRequest = e8._writeRequests.shift();
            }(r7);
            const o6 = e7._writeAlgorithm(t7);
            h5(o6, () => {
              !function(e8) {
                e8._inFlightWriteRequest._resolve(void 0), e8._inFlightWriteRequest = void 0;
              }(r7);
              const t8 = r7._state;
              if (ve2(e7), !Et(r7) && "writable" === t8) {
                const t9 = Qt(e7);
                Bt(r7, t9);
              }
              return Yt(e7), null;
            }, (t8) => ("writable" === r7._state && $t(e7), function(e8, t9) {
              e8._inFlightWriteRequest._reject(t9), e8._inFlightWriteRequest = void 0, Ct(e8, t9);
            }(r7, t8), null));
          }(e6, r6);
        }
        function xt(e6, t6) {
          "writable" === e6._controlledWritableStream._state && Nt(e6, t6);
        }
        function Qt(e6) {
          return Mt(e6) <= 0;
        }
        function Nt(e6, t6) {
          const r6 = e6._controlledWritableStream;
          $t(e6), Pt(r6, t6);
        }
        function Ht(e6) {
          return new TypeError(`WritableStream.prototype.${e6} can only be used on a WritableStream`);
        }
        function Vt(e6) {
          return new TypeError(`WritableStreamDefaultController.prototype.${e6} can only be used on a WritableStreamDefaultController`);
        }
        function Ut(e6) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${e6} can only be used on a WritableStreamDefaultWriter`);
        }
        function Gt(e6) {
          return new TypeError("Cannot " + e6 + " a stream using a released writer");
        }
        function Xt(e6) {
          e6._closedPromise = c5((t6, r6) => {
            e6._closedPromise_resolve = t6, e6._closedPromise_reject = r6, e6._closedPromiseState = "pending";
          });
        }
        function Jt(e6, t6) {
          Xt(e6), Kt(e6, t6);
        }
        function Kt(e6, t6) {
          void 0 !== e6._closedPromise_reject && (y5(e6._closedPromise), e6._closedPromise_reject(t6), e6._closedPromise_resolve = void 0, e6._closedPromise_reject = void 0, e6._closedPromiseState = "rejected");
        }
        function Zt(e6) {
          void 0 !== e6._closedPromise_resolve && (e6._closedPromise_resolve(void 0), e6._closedPromise_resolve = void 0, e6._closedPromise_reject = void 0, e6._closedPromiseState = "resolved");
        }
        function er(e6) {
          e6._readyPromise = c5((t6, r6) => {
            e6._readyPromise_resolve = t6, e6._readyPromise_reject = r6;
          }), e6._readyPromiseState = "pending";
        }
        function tr(e6, t6) {
          er(e6), or(e6, t6);
        }
        function rr(e6) {
          er(e6), nr(e6);
        }
        function or(e6, t6) {
          void 0 !== e6._readyPromise_reject && (y5(e6._readyPromise), e6._readyPromise_reject(t6), e6._readyPromise_resolve = void 0, e6._readyPromise_reject = void 0, e6._readyPromiseState = "rejected");
        }
        function nr(e6) {
          void 0 !== e6._readyPromise_resolve && (e6._readyPromise_resolve(void 0), e6._readyPromise_resolve = void 0, e6._readyPromise_reject = void 0, e6._readyPromiseState = "fulfilled");
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, { abortReason: { enumerable: true }, signal: { enumerable: true }, error: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
        const ar = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof global ? global : void 0;
        const ir = function() {
          const e6 = null == ar ? void 0 : ar.DOMException;
          return function(e7) {
            if ("function" != typeof e7 && "object" != typeof e7) return false;
            if ("DOMException" !== e7.name) return false;
            try {
              return new e7(), true;
            } catch (e8) {
              return false;
            }
          }(e6) ? e6 : void 0;
        }() || function() {
          const e6 = function(e7, t6) {
            this.message = e7 || "", this.name = t6 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
          };
          return n5(e6, "DOMException"), e6.prototype = Object.create(Error.prototype), Object.defineProperty(e6.prototype, "constructor", { value: e6, writable: true, configurable: true }), e6;
        }();
        function lr(e6, r6, o6, n6, a6, i6) {
          const l6 = V2(e6), s6 = St(r6);
          e6._disturbed = true;
          let u6 = false, p6 = d4(void 0);
          return c5((S4, g5) => {
            let v6;
            if (void 0 !== i6) {
              if (v6 = () => {
                const t6 = void 0 !== i6.reason ? i6.reason : new ir("Aborted", "AbortError"), o7 = [];
                n6 || o7.push(() => "writable" === r6._state ? Rt(r6, t6) : d4(void 0)), a6 || o7.push(() => "readable" === e6._state ? Or(e6, t6) : d4(void 0)), q3(() => Promise.all(o7.map((e7) => e7())), true, t6);
              }, i6.aborted) return void v6();
              i6.addEventListener("abort", v6);
            }
            var w4, R4, T4;
            if (P4(e6, l6._closedPromise, (e7) => (n6 ? E4(true, e7) : q3(() => Rt(r6, e7), true, e7), null)), P4(r6, s6._closedPromise, (t6) => (a6 ? E4(true, t6) : q3(() => Or(e6, t6), true, t6), null)), w4 = e6, R4 = l6._closedPromise, T4 = () => (o6 ? E4() : q3(() => function(e7) {
              const t6 = e7._ownerWritableStream, r7 = t6._state;
              return Et(t6) || "closed" === r7 ? d4(void 0) : "errored" === r7 ? f5(t6._storedError) : jt(e7);
            }(s6)), null), "closed" === w4._state ? T4() : m4(R4, T4), Et(r6) || "closed" === r6._state) {
              const t6 = new TypeError("the destination writable stream closed before all data could be piped to it");
              a6 ? E4(true, t6) : q3(() => Or(e6, t6), true, t6);
            }
            function C4() {
              const e7 = p6;
              return b4(p6, () => e7 !== p6 ? C4() : void 0);
            }
            function P4(e7, t6, r7) {
              "errored" === e7._state ? r7(e7._storedError) : _3(t6, r7);
            }
            function q3(e7, t6, o7) {
              function n7() {
                return h5(e7(), () => W3(t6, o7), (e8) => W3(true, e8)), null;
              }
              u6 || (u6 = true, "writable" !== r6._state || Et(r6) ? n7() : m4(C4(), n7));
            }
            function E4(e7, t6) {
              u6 || (u6 = true, "writable" !== r6._state || Et(r6) ? W3(e7, t6) : m4(C4(), () => W3(e7, t6)));
            }
            function W3(e7, t6) {
              return zt(s6), B3(l6), void 0 !== i6 && i6.removeEventListener("abort", v6), e7 ? g5(t6) : S4(void 0), null;
            }
            y5(c5((e7, r7) => {
              !function o7(n7) {
                n7 ? e7() : b4(u6 ? d4(true) : b4(s6._readyPromise, () => c5((e8, r8) => {
                  Z2(l6, { _chunkSteps: (r9) => {
                    p6 = b4(Dt(s6, r9), void 0, t5), e8(false);
                  }, _closeSteps: () => e8(true), _errorSteps: r8 });
                })), o7, r7);
              }(false);
            }));
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!sr(this)) throw yr("desiredSize");
            return mr(this);
          }
          close() {
            if (!sr(this)) throw yr("close");
            if (!_r(this)) throw new TypeError("The stream is not in a state that permits close");
            fr(this);
          }
          enqueue(e6 = void 0) {
            if (!sr(this)) throw yr("enqueue");
            if (!_r(this)) throw new TypeError("The stream is not in a state that permits enqueue");
            return br(this, e6);
          }
          error(e6 = void 0) {
            if (!sr(this)) throw yr("error");
            hr(this, e6);
          }
          [C3](e6) {
            Re(this);
            const t6 = this._cancelAlgorithm(e6);
            return dr(this), t6;
          }
          [P3](e6) {
            const t6 = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const r6 = ve2(this);
              this._closeRequested && 0 === this._queue.length ? (dr(this), jr(t6)) : ur(this), e6._chunkSteps(r6);
            } else U3(t6, e6), ur(this);
          }
          [q2]() {
          }
        }
        function sr(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_controlledReadableStream") && e6 instanceof ReadableStreamDefaultController);
        }
        function ur(e6) {
          if (!cr(e6)) return;
          if (e6._pulling) return void (e6._pullAgain = true);
          e6._pulling = true;
          h5(e6._pullAlgorithm(), () => (e6._pulling = false, e6._pullAgain && (e6._pullAgain = false, ur(e6)), null), (t6) => (hr(e6, t6), null));
        }
        function cr(e6) {
          const t6 = e6._controlledReadableStream;
          if (!_r(e6)) return false;
          if (!e6._started) return false;
          if (Br(t6) && X2(t6) > 0) return true;
          return mr(e6) > 0;
        }
        function dr(e6) {
          e6._pullAlgorithm = void 0, e6._cancelAlgorithm = void 0, e6._strategySizeAlgorithm = void 0;
        }
        function fr(e6) {
          if (!_r(e6)) return;
          const t6 = e6._controlledReadableStream;
          e6._closeRequested = true, 0 === e6._queue.length && (dr(e6), jr(t6));
        }
        function br(e6, t6) {
          if (!_r(e6)) return;
          const r6 = e6._controlledReadableStream;
          if (Br(r6) && X2(r6) > 0) G2(r6, t6, false);
          else {
            let r7;
            try {
              r7 = e6._strategySizeAlgorithm(t6);
            } catch (t7) {
              throw hr(e6, t7), t7;
            }
            try {
              we2(e6, t6, r7);
            } catch (t7) {
              throw hr(e6, t7), t7;
            }
          }
          ur(e6);
        }
        function hr(e6, t6) {
          const r6 = e6._controlledReadableStream;
          "readable" === r6._state && (Re(e6), dr(e6), kr(r6, t6));
        }
        function mr(e6) {
          const t6 = e6._controlledReadableStream._state;
          return "errored" === t6 ? null : "closed" === t6 ? 0 : e6._strategyHWM - e6._queueTotalSize;
        }
        function _r(e6) {
          const t6 = e6._controlledReadableStream._state;
          return !e6._closeRequested && "readable" === t6;
        }
        function pr(e6, t6, r6, o6, n6, a6, i6) {
          t6._controlledReadableStream = e6, t6._queue = void 0, t6._queueTotalSize = void 0, Re(t6), t6._started = false, t6._closeRequested = false, t6._pullAgain = false, t6._pulling = false, t6._strategySizeAlgorithm = i6, t6._strategyHWM = a6, t6._pullAlgorithm = o6, t6._cancelAlgorithm = n6, e6._readableStreamController = t6;
          h5(d4(r6()), () => (t6._started = true, ur(t6), null), (e7) => (hr(t6, e7), null));
        }
        function yr(e6) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${e6} can only be used on a ReadableStreamDefaultController`);
        }
        function Sr(e6, t6) {
          return Ce(e6._readableStreamController) ? function(e7) {
            let t7, r6, o6, n6, a6, i6 = V2(e7), l6 = false, s6 = false, u6 = false, f6 = false, b5 = false;
            const h6 = c5((e8) => {
              a6 = e8;
            });
            function m5(e8) {
              _3(e8._closedPromise, (t8) => (e8 !== i6 || (He(o6._readableStreamController, t8), He(n6._readableStreamController, t8), f6 && b5 || a6(void 0)), null));
            }
            function p6() {
              it(i6) && (B3(i6), i6 = V2(e7), m5(i6));
              Z2(i6, { _chunkSteps: (t8) => {
                S3(() => {
                  s6 = false, u6 = false;
                  const r7 = t8;
                  let i7 = t8;
                  if (!f6 && !b5) try {
                    i7 = ge2(t8);
                  } catch (t9) {
                    return He(o6._readableStreamController, t9), He(n6._readableStreamController, t9), void a6(Or(e7, t9));
                  }
                  f6 || Ne(o6._readableStreamController, r7), b5 || Ne(n6._readableStreamController, i7), l6 = false, s6 ? g5() : u6 && v6();
                });
              }, _closeSteps: () => {
                l6 = false, f6 || Qe(o6._readableStreamController), b5 || Qe(n6._readableStreamController), o6._readableStreamController._pendingPullIntos.length > 0 && Xe(o6._readableStreamController, 0), n6._readableStreamController._pendingPullIntos.length > 0 && Xe(n6._readableStreamController, 0), f6 && b5 || a6(void 0);
              }, _errorSteps: () => {
                l6 = false;
              } });
            }
            function y6(t8, r7) {
              K2(i6) && (B3(i6), i6 = rt(e7), m5(i6));
              const c6 = r7 ? n6 : o6, d5 = r7 ? o6 : n6;
              lt(i6, t8, 1, { _chunkSteps: (t9) => {
                S3(() => {
                  s6 = false, u6 = false;
                  const o7 = r7 ? b5 : f6;
                  if (r7 ? f6 : b5) o7 || Je(c6._readableStreamController, t9);
                  else {
                    let r8;
                    try {
                      r8 = ge2(t9);
                    } catch (t10) {
                      return He(c6._readableStreamController, t10), He(d5._readableStreamController, t10), void a6(Or(e7, t10));
                    }
                    o7 || Je(c6._readableStreamController, t9), Ne(d5._readableStreamController, r8);
                  }
                  l6 = false, s6 ? g5() : u6 && v6();
                });
              }, _closeSteps: (e8) => {
                l6 = false;
                const t9 = r7 ? b5 : f6, o7 = r7 ? f6 : b5;
                t9 || Qe(c6._readableStreamController), o7 || Qe(d5._readableStreamController), void 0 !== e8 && (t9 || Je(c6._readableStreamController, e8), !o7 && d5._readableStreamController._pendingPullIntos.length > 0 && Xe(d5._readableStreamController, 0)), t9 && o7 || a6(void 0);
              }, _errorSteps: () => {
                l6 = false;
              } });
            }
            function g5() {
              if (l6) return s6 = true, d4(void 0);
              l6 = true;
              const e8 = Ue(o6._readableStreamController);
              return null === e8 ? p6() : y6(e8._view, false), d4(void 0);
            }
            function v6() {
              if (l6) return u6 = true, d4(void 0);
              l6 = true;
              const e8 = Ue(n6._readableStreamController);
              return null === e8 ? p6() : y6(e8._view, true), d4(void 0);
            }
            function w4(o7) {
              if (f6 = true, t7 = o7, b5) {
                const o8 = ae2([t7, r6]), n7 = Or(e7, o8);
                a6(n7);
              }
              return h6;
            }
            function R4(o7) {
              if (b5 = true, r6 = o7, f6) {
                const o8 = ae2([t7, r6]), n7 = Or(e7, o8);
                a6(n7);
              }
              return h6;
            }
            function T4() {
            }
            return o6 = qr(T4, g5, w4), n6 = qr(T4, v6, R4), m5(i6), [o6, n6];
          }(e6) : function(e7, t7) {
            const r6 = V2(e7);
            let o6, n6, a6, i6, l6, s6 = false, u6 = false, f6 = false, b5 = false;
            const h6 = c5((e8) => {
              l6 = e8;
            });
            function m5() {
              if (s6) return u6 = true, d4(void 0);
              s6 = true;
              return Z2(r6, { _chunkSteps: (e8) => {
                S3(() => {
                  u6 = false;
                  const t8 = e8, r7 = e8;
                  f6 || br(a6._readableStreamController, t8), b5 || br(i6._readableStreamController, r7), s6 = false, u6 && m5();
                });
              }, _closeSteps: () => {
                s6 = false, f6 || fr(a6._readableStreamController), b5 || fr(i6._readableStreamController), f6 && b5 || l6(void 0);
              }, _errorSteps: () => {
                s6 = false;
              } }), d4(void 0);
            }
            function p6(t8) {
              if (f6 = true, o6 = t8, b5) {
                const t9 = ae2([o6, n6]), r7 = Or(e7, t9);
                l6(r7);
              }
              return h6;
            }
            function y6(t8) {
              if (b5 = true, n6 = t8, f6) {
                const t9 = ae2([o6, n6]), r7 = Or(e7, t9);
                l6(r7);
              }
              return h6;
            }
            function g5() {
            }
            return a6 = Pr(g5, m5, p6), i6 = Pr(g5, m5, y6), _3(r6._closedPromise, (e8) => (hr(a6._readableStreamController, e8), hr(i6._readableStreamController, e8), f6 && b5 || l6(void 0), null)), [a6, i6];
          }(e6);
        }
        function gr(e6) {
          return r5(o6 = e6) && void 0 !== o6.getReader ? function(e7) {
            let o7;
            function n6() {
              let t6;
              try {
                t6 = e7.read();
              } catch (e8) {
                return f5(e8);
              }
              return p5(t6, (e8) => {
                if (!r5(e8)) throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
                if (e8.done) fr(o7._readableStreamController);
                else {
                  const t7 = e8.value;
                  br(o7._readableStreamController, t7);
                }
              });
            }
            function a6(t6) {
              try {
                return d4(e7.cancel(t6));
              } catch (e8) {
                return f5(e8);
              }
            }
            return o7 = Pr(t5, n6, a6, 0), o7;
          }(e6.getReader()) : function(e7) {
            let o7;
            const n6 = be2(e7, "async");
            function a6() {
              let e8;
              try {
                e8 = he2(n6);
              } catch (e9) {
                return f5(e9);
              }
              return p5(d4(e8), (e9) => {
                if (!r5(e9)) throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
                if (e9.done) fr(o7._readableStreamController);
                else {
                  const t6 = e9.value;
                  br(o7._readableStreamController, t6);
                }
              });
            }
            function i6(e8) {
              const t6 = n6.iterator;
              let o8;
              try {
                o8 = ce2(t6, "return");
              } catch (e9) {
                return f5(e9);
              }
              if (void 0 === o8) return d4(void 0);
              return p5(v5(o8, t6, [e8]), (e9) => {
                if (!r5(e9)) throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
              });
            }
            return o7 = Pr(t5, a6, i6, 0), o7;
          }(e6);
          var o6;
        }
        function vr(e6, t6, r6) {
          return I3(e6, r6), (r7) => v5(e6, t6, [r7]);
        }
        function wr(e6, t6, r6) {
          return I3(e6, r6), (r7) => v5(e6, t6, [r7]);
        }
        function Rr(e6, t6, r6) {
          return I3(e6, r6), (r7) => g4(e6, t6, [r7]);
        }
        function Tr(e6, t6) {
          if ("bytes" !== (e6 = `${e6}`)) throw new TypeError(`${t6} '${e6}' is not a valid enumeration value for ReadableStreamType`);
          return e6;
        }
        function Cr(e6, t6) {
          F3(e6, t6);
          const r6 = null == e6 ? void 0 : e6.preventAbort, o6 = null == e6 ? void 0 : e6.preventCancel, n6 = null == e6 ? void 0 : e6.preventClose, a6 = null == e6 ? void 0 : e6.signal;
          return void 0 !== a6 && function(e7, t7) {
            if (!function(e8) {
              if ("object" != typeof e8 || null === e8) return false;
              try {
                return "boolean" == typeof e8.aborted;
              } catch (e9) {
                return false;
              }
            }(e7)) throw new TypeError(`${t7} is not an AbortSignal.`);
          }(a6, `${t6} has member 'signal' that`), { preventAbort: Boolean(r6), preventCancel: Boolean(o6), preventClose: Boolean(n6), signal: a6 };
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), n5(ReadableStreamDefaultController.prototype.close, "close"), n5(ReadableStreamDefaultController.prototype.enqueue, "enqueue"), n5(ReadableStreamDefaultController.prototype.error, "error"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
        class ReadableStream2 {
          constructor(e6 = {}, t6 = {}) {
            void 0 === e6 ? e6 = null : $2(e6, "First parameter");
            const r6 = ft(t6, "Second parameter"), o6 = function(e7, t7) {
              F3(e7, t7);
              const r7 = e7, o7 = null == r7 ? void 0 : r7.autoAllocateChunkSize, n6 = null == r7 ? void 0 : r7.cancel, a6 = null == r7 ? void 0 : r7.pull, i6 = null == r7 ? void 0 : r7.start, l6 = null == r7 ? void 0 : r7.type;
              return { autoAllocateChunkSize: void 0 === o7 ? void 0 : N3(o7, `${t7} has member 'autoAllocateChunkSize' that`), cancel: void 0 === n6 ? void 0 : vr(n6, r7, `${t7} has member 'cancel' that`), pull: void 0 === a6 ? void 0 : wr(a6, r7, `${t7} has member 'pull' that`), start: void 0 === i6 ? void 0 : Rr(i6, r7, `${t7} has member 'start' that`), type: void 0 === l6 ? void 0 : Tr(l6, `${t7} has member 'type' that`) };
            }(e6, "First parameter");
            if (Er(this), "bytes" === o6.type) {
              if (void 0 !== r6.size) throw new RangeError("The strategy for a byte stream cannot have a size function");
              !function(e7, t7, r7) {
                const o7 = Object.create(ReadableByteStreamController.prototype);
                let n6, a6, i6;
                n6 = void 0 !== t7.start ? () => t7.start(o7) : () => {
                }, a6 = void 0 !== t7.pull ? () => t7.pull(o7) : () => d4(void 0), i6 = void 0 !== t7.cancel ? (e8) => t7.cancel(e8) : () => d4(void 0);
                const l6 = t7.autoAllocateChunkSize;
                if (0 === l6) throw new TypeError("autoAllocateChunkSize must be greater than 0");
                Ke(e7, o7, n6, a6, i6, r7, l6);
              }(this, o6, ct(r6, 0));
            } else {
              const e7 = dt(r6);
              !function(e8, t7, r7, o7) {
                const n6 = Object.create(ReadableStreamDefaultController.prototype);
                let a6, i6, l6;
                a6 = void 0 !== t7.start ? () => t7.start(n6) : () => {
                }, i6 = void 0 !== t7.pull ? () => t7.pull(n6) : () => d4(void 0), l6 = void 0 !== t7.cancel ? (e9) => t7.cancel(e9) : () => d4(void 0), pr(e8, n6, a6, i6, l6, r7, o7);
              }(this, o6, ct(r6, 1), e7);
            }
          }
          get locked() {
            if (!Wr(this)) throw Ar("locked");
            return Br(this);
          }
          cancel(e6 = void 0) {
            return Wr(this) ? Br(this) ? f5(new TypeError("Cannot cancel a stream that already has a reader")) : Or(this, e6) : f5(Ar("cancel"));
          }
          getReader(e6 = void 0) {
            if (!Wr(this)) throw Ar("getReader");
            return void 0 === function(e7, t6) {
              F3(e7, t6);
              const r6 = null == e7 ? void 0 : e7.mode;
              return { mode: void 0 === r6 ? void 0 : tt(r6, `${t6} has member 'mode' that`) };
            }(e6, "First parameter").mode ? V2(this) : rt(this);
          }
          pipeThrough(e6, t6 = {}) {
            if (!Wr(this)) throw Ar("pipeThrough");
            M3(e6, 1, "pipeThrough");
            const r6 = function(e7, t7) {
              F3(e7, t7);
              const r7 = null == e7 ? void 0 : e7.readable;
              Y3(r7, "readable", "ReadableWritablePair"), H2(r7, `${t7} has member 'readable' that`);
              const o7 = null == e7 ? void 0 : e7.writable;
              return Y3(o7, "writable", "ReadableWritablePair"), yt(o7, `${t7} has member 'writable' that`), { readable: r7, writable: o7 };
            }(e6, "First parameter"), o6 = Cr(t6, "Second parameter");
            if (Br(this)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            if (wt(r6.writable)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            return y5(lr(this, r6.writable, o6.preventClose, o6.preventAbort, o6.preventCancel, o6.signal)), r6.readable;
          }
          pipeTo(e6, t6 = {}) {
            if (!Wr(this)) return f5(Ar("pipeTo"));
            if (void 0 === e6) return f5("Parameter 1 is required in 'pipeTo'.");
            if (!vt(e6)) return f5(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
            let r6;
            try {
              r6 = Cr(t6, "Second parameter");
            } catch (e7) {
              return f5(e7);
            }
            return Br(this) ? f5(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : wt(e6) ? f5(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : lr(this, e6, r6.preventClose, r6.preventAbort, r6.preventCancel, r6.signal);
          }
          tee() {
            if (!Wr(this)) throw Ar("tee");
            return ae2(Sr(this));
          }
          values(e6 = void 0) {
            if (!Wr(this)) throw Ar("values");
            return function(e7, t6) {
              const r6 = V2(e7), o6 = new me2(r6, t6), n6 = Object.create(_e);
              return n6._asyncIteratorImpl = o6, n6;
            }(this, function(e7, t6) {
              F3(e7, t6);
              const r6 = null == e7 ? void 0 : e7.preventCancel;
              return { preventCancel: Boolean(r6) };
            }(e6, "First parameter").preventCancel);
          }
          [fe2](e6) {
            return this.values(e6);
          }
          static from(e6) {
            return gr(e6);
          }
        }
        function Pr(e6, t6, r6, o6 = 1, n6 = () => 1) {
          const a6 = Object.create(ReadableStream2.prototype);
          Er(a6);
          return pr(a6, Object.create(ReadableStreamDefaultController.prototype), e6, t6, r6, o6, n6), a6;
        }
        function qr(e6, t6, r6) {
          const o6 = Object.create(ReadableStream2.prototype);
          Er(o6);
          return Ke(o6, Object.create(ReadableByteStreamController.prototype), e6, t6, r6, 0, void 0), o6;
        }
        function Er(e6) {
          e6._state = "readable", e6._reader = void 0, e6._storedError = void 0, e6._disturbed = false;
        }
        function Wr(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_readableStreamController") && e6 instanceof ReadableStream2);
        }
        function Br(e6) {
          return void 0 !== e6._reader;
        }
        function Or(e6, r6) {
          if (e6._disturbed = true, "closed" === e6._state) return d4(void 0);
          if ("errored" === e6._state) return f5(e6._storedError);
          jr(e6);
          const o6 = e6._reader;
          if (void 0 !== o6 && it(o6)) {
            const e7 = o6._readIntoRequests;
            o6._readIntoRequests = new w3(), e7.forEach((e8) => {
              e8._closeSteps(void 0);
            });
          }
          return p5(e6._readableStreamController[C3](r6), t5);
        }
        function jr(e6) {
          e6._state = "closed";
          const t6 = e6._reader;
          if (void 0 !== t6 && (z3(t6), K2(t6))) {
            const e7 = t6._readRequests;
            t6._readRequests = new w3(), e7.forEach((e8) => {
              e8._closeSteps();
            });
          }
        }
        function kr(e6, t6) {
          e6._state = "errored", e6._storedError = t6;
          const r6 = e6._reader;
          void 0 !== r6 && (A3(r6, t6), K2(r6) ? ee2(r6, t6) : st(r6, t6));
        }
        function Ar(e6) {
          return new TypeError(`ReadableStream.prototype.${e6} can only be used on a ReadableStream`);
        }
        function zr(e6, t6) {
          F3(e6, t6);
          const r6 = null == e6 ? void 0 : e6.highWaterMark;
          return Y3(r6, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: x3(r6) };
        }
        Object.defineProperties(ReadableStream2, { from: { enumerable: true } }), Object.defineProperties(ReadableStream2.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), n5(ReadableStream2.from, "from"), n5(ReadableStream2.prototype.cancel, "cancel"), n5(ReadableStream2.prototype.getReader, "getReader"), n5(ReadableStream2.prototype.pipeThrough, "pipeThrough"), n5(ReadableStream2.prototype.pipeTo, "pipeTo"), n5(ReadableStream2.prototype.tee, "tee"), n5(ReadableStream2.prototype.values, "values"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStream2.prototype, Symbol.toStringTag, { value: "ReadableStream", configurable: true }), Object.defineProperty(ReadableStream2.prototype, fe2, { value: ReadableStream2.prototype.values, writable: true, configurable: true });
        const Dr = (e6) => e6.byteLength;
        n5(Dr, "size");
        class ByteLengthQueuingStrategy {
          constructor(e6) {
            M3(e6, 1, "ByteLengthQueuingStrategy"), e6 = zr(e6, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e6.highWaterMark;
          }
          get highWaterMark() {
            if (!Fr(this)) throw Lr("highWaterMark");
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!Fr(this)) throw Lr("size");
            return Dr;
          }
        }
        function Lr(e6) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${e6} can only be used on a ByteLengthQueuingStrategy`);
        }
        function Fr(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_byteLengthQueuingStrategyHighWaterMark") && e6 instanceof ByteLengthQueuingStrategy);
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
        const Ir = () => 1;
        n5(Ir, "size");
        class CountQueuingStrategy {
          constructor(e6) {
            M3(e6, 1, "CountQueuingStrategy"), e6 = zr(e6, "First parameter"), this._countQueuingStrategyHighWaterMark = e6.highWaterMark;
          }
          get highWaterMark() {
            if (!Mr(this)) throw $r("highWaterMark");
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!Mr(this)) throw $r("size");
            return Ir;
          }
        }
        function $r(e6) {
          return new TypeError(`CountQueuingStrategy.prototype.${e6} can only be used on a CountQueuingStrategy`);
        }
        function Mr(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_countQueuingStrategyHighWaterMark") && e6 instanceof CountQueuingStrategy);
        }
        function Yr(e6, t6, r6) {
          return I3(e6, r6), (r7) => v5(e6, t6, [r7]);
        }
        function xr(e6, t6, r6) {
          return I3(e6, r6), (r7) => g4(e6, t6, [r7]);
        }
        function Qr(e6, t6, r6) {
          return I3(e6, r6), (r7, o6) => v5(e6, t6, [r7, o6]);
        }
        function Nr(e6, t6, r6) {
          return I3(e6, r6), (r7) => v5(e6, t6, [r7]);
        }
        Object.defineProperties(CountQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, { value: "CountQueuingStrategy", configurable: true });
        class TransformStream {
          constructor(e6 = {}, t6 = {}, r6 = {}) {
            void 0 === e6 && (e6 = null);
            const o6 = ft(t6, "Second parameter"), n6 = ft(r6, "Third parameter"), a6 = function(e7, t7) {
              F3(e7, t7);
              const r7 = null == e7 ? void 0 : e7.cancel, o7 = null == e7 ? void 0 : e7.flush, n7 = null == e7 ? void 0 : e7.readableType, a7 = null == e7 ? void 0 : e7.start, i7 = null == e7 ? void 0 : e7.transform, l7 = null == e7 ? void 0 : e7.writableType;
              return { cancel: void 0 === r7 ? void 0 : Nr(r7, e7, `${t7} has member 'cancel' that`), flush: void 0 === o7 ? void 0 : Yr(o7, e7, `${t7} has member 'flush' that`), readableType: n7, start: void 0 === a7 ? void 0 : xr(a7, e7, `${t7} has member 'start' that`), transform: void 0 === i7 ? void 0 : Qr(i7, e7, `${t7} has member 'transform' that`), writableType: l7 };
            }(e6, "First parameter");
            if (void 0 !== a6.readableType) throw new RangeError("Invalid readableType specified");
            if (void 0 !== a6.writableType) throw new RangeError("Invalid writableType specified");
            const i6 = ct(n6, 0), l6 = dt(n6), s6 = ct(o6, 1), u6 = dt(o6);
            let b5;
            !function(e7, t7, r7, o7, n7, a7) {
              function i7() {
                return t7;
              }
              function l7(t8) {
                return function(e8, t9) {
                  const r8 = e8._transformStreamController;
                  if (e8._backpressure) {
                    return p5(e8._backpressureChangePromise, () => {
                      const o8 = e8._writable;
                      if ("erroring" === o8._state) throw o8._storedError;
                      return eo(r8, t9);
                    });
                  }
                  return eo(r8, t9);
                }(e7, t8);
              }
              function s7(t8) {
                return function(e8, t9) {
                  const r8 = e8._transformStreamController;
                  if (void 0 !== r8._finishPromise) return r8._finishPromise;
                  const o8 = e8._readable;
                  r8._finishPromise = c5((e9, t10) => {
                    r8._finishPromise_resolve = e9, r8._finishPromise_reject = t10;
                  });
                  const n8 = r8._cancelAlgorithm(t9);
                  return Kr(r8), h5(n8, () => ("errored" === o8._state ? oo(r8, o8._storedError) : (hr(o8._readableStreamController, t9), ro(r8)), null), (e9) => (hr(o8._readableStreamController, e9), oo(r8, e9), null)), r8._finishPromise;
                }(e7, t8);
              }
              function u7() {
                return function(e8) {
                  const t8 = e8._transformStreamController;
                  if (void 0 !== t8._finishPromise) return t8._finishPromise;
                  const r8 = e8._readable;
                  t8._finishPromise = c5((e9, r9) => {
                    t8._finishPromise_resolve = e9, t8._finishPromise_reject = r9;
                  });
                  const o8 = t8._flushAlgorithm();
                  return Kr(t8), h5(o8, () => ("errored" === r8._state ? oo(t8, r8._storedError) : (fr(r8._readableStreamController), ro(t8)), null), (e9) => (hr(r8._readableStreamController, e9), oo(t8, e9), null)), t8._finishPromise;
                }(e7);
              }
              function d5() {
                return function(e8) {
                  return Xr(e8, false), e8._backpressureChangePromise;
                }(e7);
              }
              function f6(t8) {
                return function(e8, t9) {
                  const r8 = e8._transformStreamController;
                  if (void 0 !== r8._finishPromise) return r8._finishPromise;
                  const o8 = e8._writable;
                  r8._finishPromise = c5((e9, t10) => {
                    r8._finishPromise_resolve = e9, r8._finishPromise_reject = t10;
                  });
                  const n8 = r8._cancelAlgorithm(t9);
                  return Kr(r8), h5(n8, () => ("errored" === o8._state ? oo(r8, o8._storedError) : (xt(o8._writableStreamController, t9), Gr(e8), ro(r8)), null), (t10) => (xt(o8._writableStreamController, t10), Gr(e8), oo(r8, t10), null)), r8._finishPromise;
                }(e7, t8);
              }
              e7._writable = function(e8, t8, r8, o8, n8 = 1, a8 = () => 1) {
                const i8 = Object.create(WritableStream2.prototype);
                return gt(i8), It(i8, Object.create(WritableStreamDefaultController.prototype), e8, t8, r8, o8, n8, a8), i8;
              }(i7, l7, u7, s7, r7, o7), e7._readable = Pr(i7, d5, f6, n7, a7), e7._backpressure = void 0, e7._backpressureChangePromise = void 0, e7._backpressureChangePromise_resolve = void 0, Xr(e7, true), e7._transformStreamController = void 0;
            }(this, c5((e7) => {
              b5 = e7;
            }), s6, u6, i6, l6), function(e7, t7) {
              const r7 = Object.create(TransformStreamDefaultController.prototype);
              let o7, n7, a7;
              o7 = void 0 !== t7.transform ? (e8) => t7.transform(e8, r7) : (e8) => {
                try {
                  return Zr(r7, e8), d4(void 0);
                } catch (e9) {
                  return f5(e9);
                }
              };
              n7 = void 0 !== t7.flush ? () => t7.flush(r7) : () => d4(void 0);
              a7 = void 0 !== t7.cancel ? (e8) => t7.cancel(e8) : () => d4(void 0);
              !function(e8, t8, r8, o8, n8) {
                t8._controlledTransformStream = e8, e8._transformStreamController = t8, t8._transformAlgorithm = r8, t8._flushAlgorithm = o8, t8._cancelAlgorithm = n8, t8._finishPromise = void 0, t8._finishPromise_resolve = void 0, t8._finishPromise_reject = void 0;
              }(e7, r7, o7, n7, a7);
            }(this, a6), void 0 !== a6.start ? b5(a6.start(this._transformStreamController)) : b5(void 0);
          }
          get readable() {
            if (!Hr(this)) throw no("readable");
            return this._readable;
          }
          get writable() {
            if (!Hr(this)) throw no("writable");
            return this._writable;
          }
        }
        function Hr(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_transformStreamController") && e6 instanceof TransformStream);
        }
        function Vr(e6, t6) {
          hr(e6._readable._readableStreamController, t6), Ur(e6, t6);
        }
        function Ur(e6, t6) {
          Kr(e6._transformStreamController), xt(e6._writable._writableStreamController, t6), Gr(e6);
        }
        function Gr(e6) {
          e6._backpressure && Xr(e6, false);
        }
        function Xr(e6, t6) {
          void 0 !== e6._backpressureChangePromise && e6._backpressureChangePromise_resolve(), e6._backpressureChangePromise = c5((t7) => {
            e6._backpressureChangePromise_resolve = t7;
          }), e6._backpressure = t6;
        }
        Object.defineProperties(TransformStream.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, { value: "TransformStream", configurable: true });
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!Jr(this)) throw to("desiredSize");
            return mr(this._controlledTransformStream._readable._readableStreamController);
          }
          enqueue(e6 = void 0) {
            if (!Jr(this)) throw to("enqueue");
            Zr(this, e6);
          }
          error(e6 = void 0) {
            if (!Jr(this)) throw to("error");
            var t6;
            t6 = e6, Vr(this._controlledTransformStream, t6);
          }
          terminate() {
            if (!Jr(this)) throw to("terminate");
            !function(e6) {
              const t6 = e6._controlledTransformStream;
              fr(t6._readable._readableStreamController);
              const r6 = new TypeError("TransformStream terminated");
              Ur(t6, r6);
            }(this);
          }
        }
        function Jr(e6) {
          return !!r5(e6) && (!!Object.prototype.hasOwnProperty.call(e6, "_controlledTransformStream") && e6 instanceof TransformStreamDefaultController);
        }
        function Kr(e6) {
          e6._transformAlgorithm = void 0, e6._flushAlgorithm = void 0, e6._cancelAlgorithm = void 0;
        }
        function Zr(e6, t6) {
          const r6 = e6._controlledTransformStream, o6 = r6._readable._readableStreamController;
          if (!_r(o6)) throw new TypeError("Readable side is not in a state that permits enqueue");
          try {
            br(o6, t6);
          } catch (e7) {
            throw Ur(r6, e7), r6._readable._storedError;
          }
          const n6 = function(e7) {
            return !cr(e7);
          }(o6);
          n6 !== r6._backpressure && Xr(r6, true);
        }
        function eo(e6, t6) {
          return p5(e6._transformAlgorithm(t6), void 0, (t7) => {
            throw Vr(e6._controlledTransformStream, t7), t7;
          });
        }
        function to(e6) {
          return new TypeError(`TransformStreamDefaultController.prototype.${e6} can only be used on a TransformStreamDefaultController`);
        }
        function ro(e6) {
          void 0 !== e6._finishPromise_resolve && (e6._finishPromise_resolve(), e6._finishPromise_resolve = void 0, e6._finishPromise_reject = void 0);
        }
        function oo(e6, t6) {
          void 0 !== e6._finishPromise_reject && (y5(e6._finishPromise), e6._finishPromise_reject(t6), e6._finishPromise_resolve = void 0, e6._finishPromise_reject = void 0);
        }
        function no(e6) {
          return new TypeError(`TransformStream.prototype.${e6} can only be used on a TransformStream`);
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), n5(TransformStreamDefaultController.prototype.enqueue, "enqueue"), n5(TransformStreamDefaultController.prototype.error, "error"), n5(TransformStreamDefaultController.prototype.terminate, "terminate"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, { value: "TransformStreamDefaultController", configurable: true }), e5.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, e5.CountQueuingStrategy = CountQueuingStrategy, e5.ReadableByteStreamController = ReadableByteStreamController, e5.ReadableStream = ReadableStream2, e5.ReadableStreamBYOBReader = ReadableStreamBYOBReader, e5.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, e5.ReadableStreamDefaultController = ReadableStreamDefaultController, e5.ReadableStreamDefaultReader = ReadableStreamDefaultReader, e5.TransformStream = TransformStream, e5.TransformStreamDefaultController = TransformStreamDefaultController, e5.WritableStream = WritableStream2, e5.WritableStreamDefaultController = WritableStreamDefaultController, e5.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
      });
    }
  });

  // ../core/dist/protocol-helpers.js
  var require_protocol_helpers = __commonJS({
    "../core/dist/protocol-helpers.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var stream_1 = (init_stream(), __toCommonJS(stream_exports));
      var web_streams_polyfill_1 = require_ponyfill();
      var logger_1 = require_logger();
      var { debug, warn } = (0, logger_1.createLoggers)("core", "protocol-helpers");
      function ManagedStream(Base) {
        return class extends Base {
          set nodeStream(nodeStream) {
            this._nodeStream = nodeStream;
          }
          get nodeStream() {
            if (!this._nodeStream) {
              throw new Error("ManagedStream not correctly initialized nodeStream is undefined");
            }
            return this._nodeStream;
          }
          set wotStream(wotStream) {
            this._wotStream = wotStream;
          }
          get wotStream() {
            if (!this._wotStream) {
              throw new Error("ManagedStream not correctly initialized wotStream is undefined");
            }
            return this._wotStream;
          }
        };
      }
      var ManagedReadable = ManagedStream(stream_1.Readable);
      var ManagedReadableStream = ManagedStream(web_streams_polyfill_1.ReadableStream);
      function isManaged(obj) {
        return obj instanceof ManagedReadableStream || obj instanceof ManagedReadable;
      }
      var ProtocolHelpers = class {
        static updatePropertyFormWithTemplate(form, property) {
          for (const formTemplate of property.forms ?? []) {
            if (formTemplate.href) {
            }
            if (formTemplate.contentType != null) {
              form.contentType = formTemplate.contentType;
              return;
            }
          }
        }
        static updateActionFormWithTemplate(form, action) {
          for (const formTemplate of action.forms ?? []) {
            if (formTemplate.href) {
            }
            if (formTemplate.contentType != null) {
              form.contentType = formTemplate.contentType;
              return;
            }
          }
        }
        static updateEventFormWithTemplate(form, event) {
          for (const formTemplate of event.forms ?? []) {
            if (formTemplate.href) {
            }
            if (formTemplate.contentType != null) {
              form.contentType = formTemplate.contentType;
              return;
            }
          }
        }
        static getPropertyContentType(td, propertyName, uriScheme) {
          if (propertyName != null && uriScheme != null && td?.properties != null && td.properties[propertyName] != null && td.properties[propertyName].forms != null && Array.isArray(td.properties[propertyName].forms)) {
            for (const form of td.properties[propertyName].forms) {
              if (form.href?.startsWith(uriScheme) && form.contentType != null) {
                return form.contentType;
              }
            }
          }
          return void 0;
        }
        static getActionContentType(td, actionName, uriScheme) {
          if (actionName != null && uriScheme != null && td?.actions && td.actions != null && Array.isArray(td.actions[actionName]?.forms)) {
            for (const form of td.actions[actionName].forms) {
              if (form.href && form.href.startsWith(uriScheme) && form.contentType != null) {
                return form.contentType;
              }
            }
          }
          return void 0;
        }
        static getEventContentType(td, eventName, uriScheme) {
          if (eventName != null && uriScheme != null && td?.events && td?.events[eventName]?.forms != null && Array.isArray(td.events[eventName].forms)) {
            for (const form of td.events[eventName].forms) {
              if (form.href && form.href.startsWith(uriScheme) && form.contentType != null) {
                return form.contentType;
              }
            }
          }
          return void 0;
        }
        static toWoTStream(stream) {
          if (isManaged(stream)) {
            return stream.wotStream;
          }
          const result = new ManagedReadableStream({
            start: (controller) => {
              stream.on("data", (data) => controller.enqueue(data));
              stream.on("error", (e5) => controller.error(e5));
              stream.on("end", () => controller.close());
            },
            cancel: (reason) => {
              if (stream instanceof stream_1.Readable) {
                stream.destroy(reason);
              }
            }
          });
          if (stream instanceof stream_1.Readable) {
            result.nodeStream = stream;
          } else {
            result.nodeStream = new stream_1.Readable(stream);
          }
          return result;
        }
        static toNodeStream(stream) {
          if (isManaged(stream)) {
            return stream.nodeStream;
          }
          if (stream instanceof stream_1.Readable) {
            return stream;
          }
          const reader = stream.getReader();
          const result = new ManagedReadable({
            read: (size) => {
              reader.read().then((data) => {
                result.push(data.value);
                if (data.done) {
                  result.push(null);
                }
              });
            },
            destroy: (error, callback) => {
              reader.releaseLock();
              stream.cancel(error).then(() => callback(error));
            }
          });
          result.wotStream = stream;
          result.nodeStream = result;
          return result;
        }
        static readStreamFully(stream) {
          return new Promise((resolve2, reject) => {
            if (stream != null) {
              const chunks = [];
              stream.on("data", (data) => chunks.push(data));
              stream.on("error", reject);
              stream.on("end", () => {
                if (chunks[0] != null && (chunks[0] instanceof Array || chunks[0] instanceof Buffer2 || chunks[0] instanceof Uint8Array)) {
                  resolve2(Buffer2.concat(chunks));
                } else if (chunks[0] != null && typeof chunks[0] === "string") {
                  resolve2(Buffer2.from(chunks.join()));
                } else {
                  resolve2(Buffer2.from(chunks));
                }
              });
            } else {
              debug(`Protocol-Helper returns empty buffer for readStreamFully due to undefined stream`);
              resolve2(Buffer2.alloc(0));
            }
          });
        }
        static findRequestMatchingFormIndex(forms, uriScheme, requestUrl, contentType) {
          if (forms === void 0)
            return 0;
          let matchingForms = forms.filter((form) => {
            const formUrl = new URL(form.href.replace(/(\{[\S]*\})/, ""));
            const reqUrl = requestUrl !== void 0 ? requestUrl.indexOf("?") !== -1 ? requestUrl.split("?")[0] : requestUrl : void 0;
            return formUrl.protocol === uriScheme + ":" && (reqUrl === void 0 || formUrl.pathname === reqUrl);
          });
          if (contentType != null) {
            const contentTypeMatchingForms = matchingForms.filter((form) => {
              return form.contentType === contentType;
            });
            if (contentTypeMatchingForms.length > 0)
              matchingForms = contentTypeMatchingForms;
          }
          return matchingForms.length > 0 ? forms.indexOf(matchingForms[0]) : 0;
        }
        static getFormIndexForOperation(interaction, type2, operationName, formIndex) {
          let finalFormIndex = -1;
          let defaultOps = [];
          switch (type2) {
            case "property":
              if (interaction.readOnly === true && operationName === "writeproperty" || interaction.writeOnly === true && operationName === "readproperty")
                return finalFormIndex;
              if (interaction.readOnly !== true)
                defaultOps.push("writeproperty");
              if (interaction.writeOnly !== true)
                defaultOps.push("readproperty");
              break;
            case "action":
              defaultOps = ["invokeaction"];
              break;
            case "event":
              defaultOps = ["subscribeevent", "unsubscribeevent"];
              break;
          }
          if (defaultOps.indexOf(operationName) !== -1) {
            operationName = void 0;
          }
          if (interaction.forms !== void 0 && formIndex !== void 0 && interaction.forms.length > formIndex) {
            const form = interaction.forms[formIndex];
            if (form != null && (operationName == null || form.op?.includes(operationName) === true)) {
              finalFormIndex = formIndex;
            }
          }
          if (interaction.forms !== void 0 && finalFormIndex === -1) {
            if (operationName !== void 0) {
              interaction.forms.every((form) => {
                if (form.op?.includes(operationName) === true) {
                  finalFormIndex = interaction.forms.indexOf(form);
                }
                return finalFormIndex === -1;
              });
            } else {
              interaction.forms.every((form) => {
                finalFormIndex = interaction.forms.indexOf(form);
                return false;
              });
            }
          }
          return finalFormIndex;
        }
        static getPropertyOpValues(property) {
          const op = [];
          if (property.readOnly !== true) {
            op.push("writeproperty");
          }
          if (property.writeOnly !== true) {
            op.push("readproperty");
          }
          if (op.length === 0) {
            warn("Property was declared both as readOnly and writeOnly.");
          }
          if (property.observable === true) {
            op.push("observeproperty");
            op.push("unobserveproperty");
          }
          return op;
        }
      };
      exports21.default = ProtocolHelpers;
    }
  });

  // ../core/dist/content.js
  var require_content = __commonJS({
    "../core/dist/content.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.DefaultContent = exports21.Content = void 0;
      var content_serdes_1 = require_content_serdes();
      var protocol_helpers_1 = __importDefault(require_protocol_helpers());
      var Content = class {
        constructor(type2, body) {
          this.type = type2;
          this.body = body;
        }
        toBuffer() {
          return protocol_helpers_1.default.readStreamFully(this.body);
        }
      };
      exports21.Content = Content;
      var DefaultContent = class extends Content {
        constructor(body) {
          super(content_serdes_1.ContentSerdes.DEFAULT, body);
        }
      };
      exports21.DefaultContent = DefaultContent;
    }
  });

  // ../../node_modules/nofilter/lib/index.js
  var require_lib = __commonJS({
    "../../node_modules/nofilter/lib/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var stream = (init_stream(), __toCommonJS(stream_exports));
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var td = new TextDecoder("utf8", { fatal: true, ignoreBOM: true });
      var NoFilter = class _NoFilter extends stream.Transform {
        /**
         * Create an instance of NoFilter.
         *
         * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.
         * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding
         *   name for input, ignored if input is not a String.
         * @param {NoFilterOptions} [options] Other options.
         */
        constructor(input, inputEncoding, options = {}) {
          let inp = null;
          let inpE = (
            /** @type {BufferEncoding?} */
            null
          );
          switch (typeof input) {
            case "object":
              if (Buffer3.isBuffer(input)) {
                inp = input;
              } else if (input) {
                options = input;
              }
              break;
            case "string":
              inp = input;
              break;
            case "undefined":
              break;
            default:
              throw new TypeError("Invalid input");
          }
          switch (typeof inputEncoding) {
            case "object":
              if (inputEncoding) {
                options = inputEncoding;
              }
              break;
            case "string":
              inpE = /** @type {BufferEncoding} */
              inputEncoding;
              break;
            case "undefined":
              break;
            default:
              throw new TypeError("Invalid inputEncoding");
          }
          if (!options || typeof options !== "object") {
            throw new TypeError("Invalid options");
          }
          if (inp == null) {
            inp = options.input;
          }
          if (inpE == null) {
            inpE = options.inputEncoding;
          }
          delete options.input;
          delete options.inputEncoding;
          const watchPipe = options.watchPipe == null ? true : options.watchPipe;
          delete options.watchPipe;
          const readError = Boolean(options.readError);
          delete options.readError;
          super(options);
          this.readError = readError;
          if (watchPipe) {
            this.on("pipe", (readable) => {
              const om = readable._readableState.objectMode;
              if (this.length > 0 && om !== this._readableState.objectMode) {
                throw new Error(
                  "Do not switch objectMode in the middle of the stream"
                );
              }
              this._readableState.objectMode = om;
              this._writableState.objectMode = om;
            });
          }
          if (inp != null) {
            this.end(inp, inpE);
          }
        }
        /**
         * Is the given object a {NoFilter}?
         *
         * @param {object} obj The object to test.
         * @returns {boolean} True if obj is a NoFilter.
         */
        static isNoFilter(obj) {
          return obj instanceof this;
        }
        /**
         * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.
         *
         * @param {NoFilter} nf1 The first object to compare.
         * @param {NoFilter} nf2 The second object to compare.
         * @returns {number} -1, 0, 1 for less, equal, greater.
         * @throws {TypeError} Arguments not NoFilter instances.
         * @example
         * const arr = [new NoFilter('1234'), new NoFilter('0123')]
         * arr.sort(NoFilter.compare)
         */
        static compare(nf1, nf2) {
          if (!(nf1 instanceof this)) {
            throw new TypeError("Arguments must be NoFilters");
          }
          if (nf1 === nf2) {
            return 0;
          }
          return nf1.compare(nf2);
        }
        /**
         * Returns a buffer which is the result of concatenating all the
         * NoFilters in the list together. If the list has no items, or if
         * the totalLength is 0, then it returns a zero-length buffer.
         *
         * If length is not provided, it is read from the buffers in the
         * list. However, this adds an additional loop to the function, so
         * it is faster to provide the length explicitly if you already know it.
         *
         * @param {Array<NoFilter>} list Inputs.  Must not be all either in object
         *   mode, or all not in object mode.
         * @param {number} [length=null] Number of bytes or objects to read.
         * @returns {Buffer|Array} The concatenated values as an array if in object
         *   mode, otherwise a Buffer.
         * @throws {TypeError} List not array of NoFilters.
         */
        static concat(list, length) {
          if (!Array.isArray(list)) {
            throw new TypeError("list argument must be an Array of NoFilters");
          }
          if (list.length === 0 || length === 0) {
            return Buffer3.alloc(0);
          }
          if (length == null) {
            length = list.reduce((tot, nf) => {
              if (!(nf instanceof _NoFilter)) {
                throw new TypeError("list argument must be an Array of NoFilters");
              }
              return tot + nf.length;
            }, 0);
          }
          let allBufs = true;
          let allObjs = true;
          const bufs = list.map((nf) => {
            if (!(nf instanceof _NoFilter)) {
              throw new TypeError("list argument must be an Array of NoFilters");
            }
            const buf = nf.slice();
            if (Buffer3.isBuffer(buf)) {
              allObjs = false;
            } else {
              allBufs = false;
            }
            return buf;
          });
          if (allBufs) {
            return Buffer3.concat(bufs, length);
          }
          if (allObjs) {
            return [].concat(...bufs).slice(0, length);
          }
          throw new Error("Concatenating mixed object and byte streams not supported");
        }
        /**
         * @ignore
         */
        _transform(chunk, encoding, callback) {
          if (!this._readableState.objectMode && !Buffer3.isBuffer(chunk)) {
            chunk = Buffer3.from(chunk, encoding);
          }
          this.push(chunk);
          callback();
        }
        /**
         * @returns {Buffer[]} The current internal buffers.  They are layed out
         *   end to end.
         * @ignore
         */
        _bufArray() {
          let bufs = this._readableState.buffer;
          if (!Array.isArray(bufs)) {
            let b4 = bufs.head;
            bufs = [];
            while (b4 != null) {
              bufs.push(b4.data);
              b4 = b4.next;
            }
          }
          return bufs;
        }
        /**
         * Pulls some data out of the internal buffer and returns it.
         * If there is no data available, then it will return null.
         *
         * If you pass in a size argument, then it will return that many bytes. If
         * size bytes are not available, then it will return null, unless we've
         * ended, in which case it will return the data remaining in the buffer.
         *
         * If you do not specify a size argument, then it will return all the data in
         * the internal buffer.
         *
         * @param {number} [size=null] Number of bytes to read.
         * @returns {string|Buffer|null} If no data or not enough data, null.  If
         *   decoding output a string, otherwise a Buffer.
         * @throws Error If readError is true and there was underflow.
         * @fires NoFilter#read When read from.
         */
        read(size) {
          const buf = super.read(size);
          if (buf != null) {
            this.emit("read", buf);
            if (this.readError && buf.length < size) {
              throw new Error(`Read ${buf.length}, wanted ${size}`);
            }
          } else if (this.readError) {
            throw new Error(`No data available, wanted ${size}`);
          }
          return buf;
        }
        /**
         * Read the full number of bytes asked for, no matter how long it takes.
         * Fail if an error occurs in the meantime, or if the stream finishes before
         * enough data is available.
         *
         * Note: This function won't work fully correctly if you are using
         * stream-browserify (for example, on the Web).
         *
         * @param {number} size The number of bytes to read.
         * @returns {Promise<string|Buffer>} A promise for the data read.
         */
        readFull(size) {
          let onReadable = null;
          let onFinish = null;
          let onError = null;
          return new Promise((resolve2, reject) => {
            if (this.length >= size) {
              resolve2(this.read(size));
              return;
            }
            if (this.writableFinished) {
              reject(new Error(`Stream finished before ${size} bytes were available`));
              return;
            }
            onReadable = (chunk) => {
              if (this.length >= size) {
                resolve2(this.read(size));
              }
            };
            onFinish = () => {
              reject(new Error(`Stream finished before ${size} bytes were available`));
            };
            onError = reject;
            this.on("readable", onReadable);
            this.on("error", onError);
            this.on("finish", onFinish);
          }).finally(() => {
            if (onReadable) {
              this.removeListener("readable", onReadable);
              this.removeListener("error", onError);
              this.removeListener("finish", onFinish);
            }
          });
        }
        /**
         * Return a promise fulfilled with the full contents, after the 'finish'
         * event fires.  Errors on the stream cause the promise to be rejected.
         *
         * @param {Function} [cb=null] Finished/error callback used in *addition*
         *   to the promise.
         * @returns {Promise<Buffer|string>} Fulfilled when complete.
         */
        promise(cb) {
          let done = false;
          return new Promise((resolve2, reject) => {
            this.on("finish", () => {
              const data = this.read();
              if (cb != null && !done) {
                done = true;
                cb(null, data);
              }
              resolve2(data);
            });
            this.on("error", (er) => {
              if (cb != null && !done) {
                done = true;
                cb(er);
              }
              reject(er);
            });
          });
        }
        /**
         * Returns a number indicating whether this comes before or after or is the
         * same as the other NoFilter in sort order.
         *
         * @param {NoFilter} other The other object to compare.
         * @returns {number} -1, 0, 1 for less, equal, greater.
         * @throws {TypeError} Arguments must be NoFilters.
         */
        compare(other) {
          if (!(other instanceof _NoFilter)) {
            throw new TypeError("Arguments must be NoFilters");
          }
          if (this === other) {
            return 0;
          }
          const buf1 = this.slice();
          const buf2 = other.slice();
          if (Buffer3.isBuffer(buf1) && Buffer3.isBuffer(buf2)) {
            return buf1.compare(buf2);
          }
          throw new Error("Cannot compare streams in object mode");
        }
        /**
         * Do these NoFilter's contain the same bytes?  Doesn't work if either is
         * in object mode.
         *
         * @param {NoFilter} other Other NoFilter to compare against.
         * @returns {boolean} Equal?
         */
        equals(other) {
          return this.compare(other) === 0;
        }
        /**
         * Read bytes or objects without consuming them.  Useful for diagnostics.
         * Note: as a side-effect, concatenates multiple writes together into what
         * looks like a single write, so that this concat doesn't have to happen
         * multiple times when you're futzing with the same NoFilter.
         *
         * @param {number} [start=0] Beginning offset.
         * @param {number} [end=length] Ending offset.
         * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,
         *   concatenated array of contents.
         */
        slice(start, end) {
          if (this._readableState.objectMode) {
            return this._bufArray().slice(start, end);
          }
          const bufs = this._bufArray();
          switch (bufs.length) {
            case 0:
              return Buffer3.alloc(0);
            case 1:
              return bufs[0].slice(start, end);
            default: {
              const b4 = Buffer3.concat(bufs);
              return b4.slice(start, end);
            }
          }
        }
        /**
         * Get a byte by offset.  I didn't want to get into metaprogramming
         * to give you the `NoFilter[0]` syntax.
         *
         * @param {number} index The byte to retrieve.
         * @returns {number} 0-255.
         */
        get(index) {
          return this.slice()[index];
        }
        /**
         * Return an object compatible with Buffer's toJSON implementation, so that
         * round-tripping will produce a Buffer.
         *
         * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,
         *   the objects.  Otherwise, JSON text.
         * @example <caption>output for 'foo', not in object mode</caption>
         * ({
         *   type: 'Buffer',
         *   data: [102, 111, 111],
         * })
         */
        toJSON() {
          const b4 = this.slice();
          if (Buffer3.isBuffer(b4)) {
            return b4.toJSON();
          }
          return b4;
        }
        /**
         * Decodes and returns a string from buffer data encoded using the specified
         * character set encoding. If encoding is undefined or null, then encoding
         * defaults to 'utf8'. The start and end parameters default to 0 and
         * NoFilter.length when undefined.
         *
         * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?
         * @param {number} [start=0] Start offset.
         * @param {number} [end=length] End offset.
         * @returns {string} String version of the contents.
         */
        toString(encoding, start, end) {
          const buf = this.slice(start, end);
          if (!Buffer3.isBuffer(buf)) {
            return JSON.stringify(buf);
          }
          if (!encoding || encoding === "utf8") {
            return td.decode(buf);
          }
          return buf.toString(encoding);
        }
        /**
         * @ignore
         */
        [Symbol.for("nodejs.util.inspect.custom")](depth, options) {
          const bufs = this._bufArray();
          const hex = bufs.map((b4) => {
            if (Buffer3.isBuffer(b4)) {
              return options.stylize(b4.toString("hex"), "string");
            }
            return JSON.stringify(b4);
          }).join(", ");
          return `${this.constructor.name} [${hex}]`;
        }
        /**
         * Current readable length, in bytes.
         *
         * @returns {number} Length of the contents.
         */
        get length() {
          return this._readableState.length;
        }
        /**
         * Write a JavaScript BigInt to the stream.  Negative numbers will be
         * written as their 2's complement version.
         *
         * @param {bigint} val The value to write.
         * @returns {boolean} True on success.
         */
        writeBigInt(val) {
          let str = val.toString(16);
          if (val < 0) {
            const sz = BigInt(Math.floor(str.length / 2));
            const mask = BigInt(1) << sz * BigInt(8);
            val = mask + val;
            str = val.toString(16);
          }
          if (str.length % 2) {
            str = `0${str}`;
          }
          return this.push(Buffer3.from(str, "hex"));
        }
        /**
         * Read a variable-sized JavaScript unsigned BigInt from the stream.
         *
         * @param {number} [len=null] Number of bytes to read or all remaining
         *   if null.
         * @returns {bigint} A BigInt.
         */
        readUBigInt(len) {
          const b4 = this.read(len);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return BigInt(`0x${b4.toString("hex")}`);
        }
        /**
         * Read a variable-sized JavaScript signed BigInt from the stream in 2's
         * complement format.
         *
         * @param {number} [len=null] Number of bytes to read or all remaining
         *   if null.
         * @returns {bigint} A BigInt.
         */
        readBigInt(len) {
          const b4 = this.read(len);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          let ret = BigInt(`0x${b4.toString("hex")}`);
          if (b4[0] & 128) {
            const mask = BigInt(1) << BigInt(b4.length) * BigInt(8);
            ret -= mask;
          }
          return ret;
        }
        /**
         * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.
         *
         * @param {number} value 0..255.
         * @returns {boolean} True on success.
         */
        writeUInt8(value) {
          const b4 = Buffer3.from([value]);
          return this.push(b4);
        }
        /**
         * Write a little-endian 16-bit unsigned integer to the stream.  Adds
         * 2 bytes.
         *
         * @param {number} value 0..65535.
         * @returns {boolean} True on success.
         */
        writeUInt16LE(value) {
          const b4 = Buffer3.alloc(2);
          b4.writeUInt16LE(value);
          return this.push(b4);
        }
        /**
         * Write a big-endian 16-bit unsigned integer to the stream.  Adds
         * 2 bytes.
         *
         * @param {number} value 0..65535.
         * @returns {boolean} True on success.
         */
        writeUInt16BE(value) {
          const b4 = Buffer3.alloc(2);
          b4.writeUInt16BE(value);
          return this.push(b4);
        }
        /**
         * Write a little-endian 32-bit unsigned integer to the stream.  Adds
         * 4 bytes.
         *
         * @param {number} value 0..2**32-1.
         * @returns {boolean} True on success.
         */
        writeUInt32LE(value) {
          const b4 = Buffer3.alloc(4);
          b4.writeUInt32LE(value);
          return this.push(b4);
        }
        /**
         * Write a big-endian 32-bit unsigned integer to the stream.  Adds
         * 4 bytes.
         *
         * @param {number} value 0..2**32-1.
         * @returns {boolean} True on success.
         */
        writeUInt32BE(value) {
          const b4 = Buffer3.alloc(4);
          b4.writeUInt32BE(value);
          return this.push(b4);
        }
        /**
         * Write a signed 8-bit integer to the stream.  Adds 1 byte.
         *
         * @param {number} value (-128)..127.
         * @returns {boolean} True on success.
         */
        writeInt8(value) {
          const b4 = Buffer3.from([value]);
          return this.push(b4);
        }
        /**
         * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.
         *
         * @param {number} value (-32768)..32767.
         * @returns {boolean} True on success.
         */
        writeInt16LE(value) {
          const b4 = Buffer3.alloc(2);
          b4.writeUInt16LE(value);
          return this.push(b4);
        }
        /**
         * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.
         *
         * @param {number} value (-32768)..32767.
         * @returns {boolean} True on success.
         */
        writeInt16BE(value) {
          const b4 = Buffer3.alloc(2);
          b4.writeUInt16BE(value);
          return this.push(b4);
        }
        /**
         * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.
         *
         * @param {number} value (-2**31)..(2**31-1).
         * @returns {boolean} True on success.
         */
        writeInt32LE(value) {
          const b4 = Buffer3.alloc(4);
          b4.writeUInt32LE(value);
          return this.push(b4);
        }
        /**
         * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.
         *
         * @param {number} value (-2**31)..(2**31-1).
         * @returns {boolean} True on success.
         */
        writeInt32BE(value) {
          const b4 = Buffer3.alloc(4);
          b4.writeUInt32BE(value);
          return this.push(b4);
        }
        /**
         * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.
         *
         * @param {number} value 32-bit float.
         * @returns {boolean} True on success.
         */
        writeFloatLE(value) {
          const b4 = Buffer3.alloc(4);
          b4.writeFloatLE(value);
          return this.push(b4);
        }
        /**
         * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.
         *
         * @param {number} value 32-bit float.
         * @returns {boolean} True on success.
         */
        writeFloatBE(value) {
          const b4 = Buffer3.alloc(4);
          b4.writeFloatBE(value);
          return this.push(b4);
        }
        /**
         * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.
         *
         * @param {number} value 64-bit float.
         * @returns {boolean} True on success.
         */
        writeDoubleLE(value) {
          const b4 = Buffer3.alloc(8);
          b4.writeDoubleLE(value);
          return this.push(b4);
        }
        /**
         * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.
         *
         * @param {number} value 64-bit float.
         * @returns {boolean} True on success.
         */
        writeDoubleBE(value) {
          const b4 = Buffer3.alloc(8);
          b4.writeDoubleBE(value);
          return this.push(b4);
        }
        /**
         * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.
         *
         * @param {bigint} value BigInt.
         * @returns {boolean} True on success.
         */
        writeBigInt64LE(value) {
          const b4 = Buffer3.alloc(8);
          b4.writeBigInt64LE(value);
          return this.push(b4);
        }
        /**
         * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.
         *
         * @param {bigint} value BigInt.
         * @returns {boolean} True on success.
         */
        writeBigInt64BE(value) {
          const b4 = Buffer3.alloc(8);
          b4.writeBigInt64BE(value);
          return this.push(b4);
        }
        /**
         * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.
         *
         * @param {bigint} value Non-negative BigInt.
         * @returns {boolean} True on success.
         */
        writeBigUInt64LE(value) {
          const b4 = Buffer3.alloc(8);
          b4.writeBigUInt64LE(value);
          return this.push(b4);
        }
        /**
         * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.
         *
         * @param {bigint} value Non-negative BigInt.
         * @returns {boolean} True on success.
         */
        writeBigUInt64BE(value) {
          const b4 = Buffer3.alloc(8);
          b4.writeBigUInt64BE(value);
          return this.push(b4);
        }
        /**
         * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.
         *
         * @returns {number} Value read.
         */
        readUInt8() {
          const b4 = this.read(1);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readUInt8();
        }
        /**
         * Read a little-endian unsigned 16-bit integer from the stream.
         * Consumes 2 bytes.
         *
         * @returns {number} Value read.
         */
        readUInt16LE() {
          const b4 = this.read(2);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readUInt16LE();
        }
        /**
         * Read a little-endian unsigned 16-bit integer from the stream.
         * Consumes 2 bytes.
         *
         * @returns {number} Value read.
         */
        readUInt16BE() {
          const b4 = this.read(2);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readUInt16BE();
        }
        /**
         * Read a little-endian unsigned 32-bit integer from the stream.
         * Consumes 4 bytes.
         *
         * @returns {number} Value read.
         */
        readUInt32LE() {
          const b4 = this.read(4);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readUInt32LE();
        }
        /**
         * Read a little-endian unsigned 16-bit integer from the stream.
         * Consumes 4 bytes.
         *
         * @returns {number} Value read.
         */
        readUInt32BE() {
          const b4 = this.read(4);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readUInt32BE();
        }
        /**
         * Read a signed 8-bit integer from the stream.  Consumes 1 byte.
         *
         * @returns {number} Value read.
         */
        readInt8() {
          const b4 = this.read(1);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readInt8();
        }
        /**
         * Read a little-endian signed 16-bit integer from the stream.
         * Consumes 2 bytes.
         *
         * @returns {number} Value read.
         */
        readInt16LE() {
          const b4 = this.read(2);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readInt16LE();
        }
        /**
         * Read a little-endian signed 16-bit integer from the stream.
         * Consumes 2 bytes.
         *
         * @returns {number} Value read.
         */
        readInt16BE() {
          const b4 = this.read(2);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readInt16BE();
        }
        /**
         * Read a little-endian signed 32-bit integer from the stream.
         * Consumes 4 bytes.
         *
         * @returns {number} Value read.
         */
        readInt32LE() {
          const b4 = this.read(4);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readInt32LE();
        }
        /**
         * Read a little-endian signed 16-bit integer from the stream.
         * Consumes 4 bytes.
         *
         * @returns {number} Value read.
         */
        readInt32BE() {
          const b4 = this.read(4);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readInt32BE();
        }
        /**
         * Read a 32-bit little-endian float from the stream.
         * Consumes 4 bytes.
         *
         * @returns {number} Value read.
         */
        readFloatLE() {
          const b4 = this.read(4);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readFloatLE();
        }
        /**
         * Read a 32-bit big-endian float from the stream.
         * Consumes 4 bytes.
         *
         * @returns {number} Value read.
         */
        readFloatBE() {
          const b4 = this.read(4);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readFloatBE();
        }
        /**
         * Read a 64-bit little-endian float from the stream.
         * Consumes 8 bytes.
         *
         * @returns {number} Value read.
         */
        readDoubleLE() {
          const b4 = this.read(8);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readDoubleLE();
        }
        /**
         * Read a 64-bit big-endian float from the stream.
         * Consumes 8 bytes.
         *
         * @returns {number} Value read.
         */
        readDoubleBE() {
          const b4 = this.read(8);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readDoubleBE();
        }
        /**
         * Read a signed 64-bit little-endian BigInt from the stream.
         * Consumes 8 bytes.
         *
         * @returns {bigint} Value read.
         */
        readBigInt64LE() {
          const b4 = this.read(8);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readBigInt64LE();
        }
        /**
         * Read a signed 64-bit big-endian BigInt from the stream.
         * Consumes 8 bytes.
         *
         * @returns {bigint} Value read.
         */
        readBigInt64BE() {
          const b4 = this.read(8);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readBigInt64BE();
        }
        /**
         * Read an unsigned 64-bit little-endian BigInt from the stream.
         * Consumes 8 bytes.
         *
         * @returns {bigint} Value read.
         */
        readBigUInt64LE() {
          const b4 = this.read(8);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readBigUInt64LE();
        }
        /**
         * Read an unsigned 64-bit big-endian BigInt from the stream.
         * Consumes 8 bytes.
         *
         * @returns {bigint} Value read.
         */
        readBigUInt64BE() {
          const b4 = this.read(8);
          if (!Buffer3.isBuffer(b4)) {
            return null;
          }
          return b4.readBigUInt64BE();
        }
      };
      module.exports = NoFilter;
    }
  });

  // ../../node_modules/cbor/lib/constants.js
  var require_constants = __commonJS({
    "../../node_modules/cbor/lib/constants.js"(exports21) {
      "use strict";
      init_buffer2();
      exports21.MT = {
        POS_INT: 0,
        NEG_INT: 1,
        BYTE_STRING: 2,
        UTF8_STRING: 3,
        ARRAY: 4,
        MAP: 5,
        TAG: 6,
        SIMPLE_FLOAT: 7
      };
      exports21.TAG = {
        DATE_STRING: 0,
        DATE_EPOCH: 1,
        POS_BIGINT: 2,
        NEG_BIGINT: 3,
        DECIMAL_FRAC: 4,
        BIGFLOAT: 5,
        BASE64URL_EXPECTED: 21,
        BASE64_EXPECTED: 22,
        BASE16_EXPECTED: 23,
        CBOR: 24,
        URI: 32,
        BASE64URL: 33,
        BASE64: 34,
        REGEXP: 35,
        MIME: 36,
        // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
        SET: 258
      };
      exports21.NUMBYTES = {
        ZERO: 0,
        ONE: 24,
        TWO: 25,
        FOUR: 26,
        EIGHT: 27,
        INDEFINITE: 31
      };
      exports21.SIMPLE = {
        FALSE: 20,
        TRUE: 21,
        NULL: 22,
        UNDEFINED: 23
      };
      exports21.SYMS = {
        NULL: Symbol.for("github.com/hildjj/node-cbor/null"),
        UNDEFINED: Symbol.for("github.com/hildjj/node-cbor/undef"),
        PARENT: Symbol.for("github.com/hildjj/node-cbor/parent"),
        BREAK: Symbol.for("github.com/hildjj/node-cbor/break"),
        STREAM: Symbol.for("github.com/hildjj/node-cbor/stream")
      };
      exports21.SHIFT32 = 4294967296;
      exports21.BI = {
        MINUS_ONE: BigInt(-1),
        NEG_MAX: BigInt(-1) - BigInt(Number.MAX_SAFE_INTEGER),
        MAXINT32: BigInt("0xffffffff"),
        MAXINT64: BigInt("0xffffffffffffffff"),
        SHIFT32: BigInt(exports21.SHIFT32)
      };
    }
  });

  // ../../node_modules/cbor/lib/utils.js
  var require_utils2 = __commonJS({
    "../../node_modules/cbor/lib/utils.js"(exports21) {
      "use strict";
      init_buffer2();
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var NoFilter = require_lib();
      var stream = (init_stream(), __toCommonJS(stream_exports));
      var constants2 = require_constants();
      var { NUMBYTES, SHIFT32, BI, SYMS } = constants2;
      var MAX_SAFE_HIGH = 2097151;
      var td = new TextDecoder("utf8", { fatal: true, ignoreBOM: true });
      exports21.utf8 = (buf) => td.decode(buf);
      exports21.utf8.checksUTF8 = true;
      function isReadable(s5) {
        if (s5 instanceof stream.Readable) {
          return true;
        }
        return ["read", "on", "pipe"].every((f5) => typeof s5[f5] === "function");
      }
      exports21.isBufferish = function isBufferish(b4) {
        return b4 && typeof b4 === "object" && (Buffer3.isBuffer(b4) || b4 instanceof Uint8Array || b4 instanceof Uint8ClampedArray || b4 instanceof ArrayBuffer || b4 instanceof DataView);
      };
      exports21.bufferishToBuffer = function bufferishToBuffer(b4) {
        if (Buffer3.isBuffer(b4)) {
          return b4;
        } else if (ArrayBuffer.isView(b4)) {
          return Buffer3.from(b4.buffer, b4.byteOffset, b4.byteLength);
        } else if (b4 instanceof ArrayBuffer) {
          return Buffer3.from(b4);
        }
        return null;
      };
      exports21.parseCBORint = function parseCBORint(ai, buf) {
        switch (ai) {
          case NUMBYTES.ONE:
            return buf.readUInt8(0);
          case NUMBYTES.TWO:
            return buf.readUInt16BE(0);
          case NUMBYTES.FOUR:
            return buf.readUInt32BE(0);
          case NUMBYTES.EIGHT: {
            const f5 = buf.readUInt32BE(0);
            const g4 = buf.readUInt32BE(4);
            if (f5 > MAX_SAFE_HIGH) {
              return BigInt(f5) * BI.SHIFT32 + BigInt(g4);
            }
            return f5 * SHIFT32 + g4;
          }
          default:
            throw new Error(`Invalid additional info for int: ${ai}`);
        }
      };
      exports21.writeHalf = function writeHalf(buf, half) {
        const u32 = Buffer3.allocUnsafe(4);
        u32.writeFloatBE(half, 0);
        const u5 = u32.readUInt32BE(0);
        if ((u5 & 8191) !== 0) {
          return false;
        }
        let s16 = u5 >> 16 & 32768;
        const exp = u5 >> 23 & 255;
        const mant = u5 & 8388607;
        if (exp >= 113 && exp <= 142) {
          s16 += (exp - 112 << 10) + (mant >> 13);
        } else if (exp >= 103 && exp < 113) {
          if (mant & (1 << 126 - exp) - 1) {
            return false;
          }
          s16 += mant + 8388608 >> 126 - exp;
        } else {
          return false;
        }
        buf.writeUInt16BE(s16);
        return true;
      };
      exports21.parseHalf = function parseHalf(buf) {
        const sign = buf[0] & 128 ? -1 : 1;
        const exp = (buf[0] & 124) >> 2;
        const mant = (buf[0] & 3) << 8 | buf[1];
        if (!exp) {
          return sign * 5960464477539063e-23 * mant;
        } else if (exp === 31) {
          return sign * (mant ? NaN : Infinity);
        }
        return sign * 2 ** (exp - 25) * (1024 + mant);
      };
      exports21.parseCBORfloat = function parseCBORfloat(buf) {
        switch (buf.length) {
          case 2:
            return exports21.parseHalf(buf);
          case 4:
            return buf.readFloatBE(0);
          case 8:
            return buf.readDoubleBE(0);
          default:
            throw new Error(`Invalid float size: ${buf.length}`);
        }
      };
      exports21.hex = function hex(s5) {
        return Buffer3.from(s5.replace(/^0x/, ""), "hex");
      };
      exports21.bin = function bin(s5) {
        s5 = s5.replace(/\s/g, "");
        let start = 0;
        let end = s5.length % 8 || 8;
        const chunks = [];
        while (end <= s5.length) {
          chunks.push(parseInt(s5.slice(start, end), 2));
          start = end;
          end += 8;
        }
        return Buffer3.from(chunks);
      };
      exports21.arrayEqual = function arrayEqual(a5, b4) {
        if (a5 == null && b4 == null) {
          return true;
        }
        if (a5 == null || b4 == null) {
          return false;
        }
        return a5.length === b4.length && a5.every((elem, i5) => elem === b4[i5]);
      };
      exports21.bufferToBigInt = function bufferToBigInt(buf) {
        return BigInt(`0x${buf.toString("hex")}`);
      };
      exports21.cborValueToString = function cborValueToString(val, float_bytes = -1) {
        switch (typeof val) {
          case "symbol": {
            switch (val) {
              case SYMS.NULL:
                return "null";
              case SYMS.UNDEFINED:
                return "undefined";
              case SYMS.BREAK:
                return "BREAK";
            }
            if (val.description) {
              return val.description;
            }
            const s5 = val.toString();
            const m4 = s5.match(/^Symbol\((?<name>.*)\)/);
            if (m4 && m4.groups.name) {
              return m4.groups.name;
            }
            return "Symbol";
          }
          case "string":
            return JSON.stringify(val);
          case "bigint":
            return val.toString();
          case "number": {
            const s5 = Object.is(val, -0) ? "-0" : String(val);
            return float_bytes > 0 ? `${s5}_${float_bytes}` : s5;
          }
          case "object": {
            const buf = exports21.bufferishToBuffer(val);
            if (buf) {
              const hex = buf.toString("hex");
              return float_bytes === -Infinity ? hex : `h'${hex}'`;
            }
            if (typeof val[Symbol.for("nodejs.util.inspect.custom")] === "function") {
              return val[Symbol.for("nodejs.util.inspect.custom")]();
            }
            if (Array.isArray(val)) {
              return "[]";
            }
            return "{}";
          }
        }
        return String(val);
      };
      exports21.guessEncoding = function guessEncoding(input, encoding) {
        if (typeof input === "string") {
          return new NoFilter(input, encoding == null ? "hex" : encoding);
        }
        const buf = exports21.bufferishToBuffer(input);
        if (buf) {
          return new NoFilter(buf);
        }
        if (isReadable(input)) {
          return input;
        }
        throw new Error("Unknown input type");
      };
      var B64URL_SWAPS = {
        "=": "",
        "+": "-",
        "/": "_"
      };
      exports21.base64url = function base64url(buf) {
        return exports21.bufferishToBuffer(buf).toString("base64").replace(/[=+/]/g, (c5) => B64URL_SWAPS[c5]);
      };
      exports21.base64 = function base64(buf) {
        return exports21.bufferishToBuffer(buf).toString("base64");
      };
      exports21.isBigEndian = function isBigEndian() {
        const array = new Uint8Array(4);
        const view = new Uint32Array(array.buffer);
        return !((view[0] = 1) & array[0]);
      };
    }
  });

  // ../../node_modules/cbor/vendor/binary-parse-stream/index.js
  var require_binary_parse_stream = __commonJS({
    "../../node_modules/cbor/vendor/binary-parse-stream/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var stream = (init_stream(), __toCommonJS(stream_exports));
      var NoFilter = require_lib();
      var BinaryParseStream = class extends stream.Transform {
        /**
         * Creates an instance of BinaryParseStream.
         *
         * @param {stream.TransformOptions} options Stream options.
         * @memberof BinaryParseStream
         */
        constructor(options) {
          super(options);
          this["_writableState"].objectMode = false;
          this["_readableState"].objectMode = true;
          this.bs = new NoFilter();
          this.__restart();
        }
        _transform(fresh, encoding, cb) {
          this.bs.write(fresh);
          while (this.bs.length >= this.__needed) {
            let ret = null;
            const chunk = this.__needed === null ? void 0 : this.bs.read(this.__needed);
            try {
              ret = this.__parser.next(chunk);
            } catch (e5) {
              return cb(e5);
            }
            if (this.__needed) {
              this.__fresh = false;
            }
            if (ret.done) {
              this.push(ret.value);
              this.__restart();
            } else {
              this.__needed = ret.value || Infinity;
            }
          }
          return cb();
        }
        /**
         * Subclasses must override this to set their parsing behavior.  Yield a
         * number to receive a Buffer of that many bytes.
         *
         * @abstract
         * @returns {Generator<number, undefined, Buffer>}
         */
        /* istanbul ignore next */
        *_parse() {
          throw new Error("Must be implemented in subclass");
        }
        __restart() {
          this.__needed = null;
          this.__parser = this._parse();
          this.__fresh = true;
        }
        _flush(cb) {
          cb(this.__fresh ? null : new Error("unexpected end of input"));
        }
      };
      module.exports = BinaryParseStream;
    }
  });

  // ../../node_modules/cbor/lib/tagged.js
  var require_tagged = __commonJS({
    "../../node_modules/cbor/lib/tagged.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var constants2 = require_constants();
      var utils = require_utils2();
      var INTERNAL_JSON = Symbol("INTERNAL_JSON");
      function setBuffersToJSON(obj, fn) {
        if (utils.isBufferish(obj)) {
          obj.toJSON = fn;
        } else if (Array.isArray(obj)) {
          for (const v5 of obj) {
            setBuffersToJSON(v5, fn);
          }
        } else if (obj && typeof obj === "object") {
          if (!(obj instanceof Tagged) || obj.tag < 21 || obj.tag > 23) {
            for (const v5 of Object.values(obj)) {
              setBuffersToJSON(v5, fn);
            }
          }
        }
      }
      function b64this() {
        return utils.base64(this);
      }
      function b64urlThis() {
        return utils.base64url(this);
      }
      function hexThis() {
        return this.toString("hex");
      }
      function swapEndian(ab, size, byteOffset, byteLength) {
        const dv = new DataView(ab);
        const [getter, setter] = {
          2: [dv.getUint16, dv.setUint16],
          4: [dv.getUint32, dv.setUint32],
          8: [dv.getBigUint64, dv.setBigUint64]
        }[size];
        const end = byteOffset + byteLength;
        for (let offset = byteOffset; offset < end; offset += size) {
          setter.call(dv, offset, getter.call(dv, offset, true));
        }
      }
      var TAGS = {
        // Standard date/time string; see Section 3.4.1
        0: (v5) => new Date(v5),
        // Epoch-based date/time; see Section 3.4.2
        1: (v5) => new Date(v5 * 1e3),
        // Positive bignum; see Section 3.4.3
        2: (v5) => utils.bufferToBigInt(v5),
        // Negative bignum; see Section 3.4.3
        3: (v5) => constants2.BI.MINUS_ONE - utils.bufferToBigInt(v5),
        // Expected conversion to base64url encoding; see Section 3.4.5.2
        21: (v5, tag) => {
          if (utils.isBufferish(v5)) {
            tag[INTERNAL_JSON] = b64urlThis;
          } else {
            setBuffersToJSON(v5, b64urlThis);
          }
          return tag;
        },
        // Expected conversion to base64 encoding; see Section 3.4.5.2
        22: (v5, tag) => {
          if (utils.isBufferish(v5)) {
            tag[INTERNAL_JSON] = b64this;
          } else {
            setBuffersToJSON(v5, b64this);
          }
          return tag;
        },
        // Expected conversion to base16 encoding; see Section Section 3.4.5.2
        23: (v5, tag) => {
          if (utils.isBufferish(v5)) {
            tag[INTERNAL_JSON] = hexThis;
          } else {
            setBuffersToJSON(v5, hexThis);
          }
          return tag;
        },
        // URI; see Section 3.4.5.3
        32: (v5) => new URL(v5),
        // Base64url; see Section 3.4.5.3
        33: (v5, tag) => {
          if (!v5.match(/^[a-zA-Z0-9_-]+$/)) {
            throw new Error("Invalid base64url characters");
          }
          const last = v5.length % 4;
          if (last === 1) {
            throw new Error("Invalid base64url length");
          }
          if (last === 2) {
            if ("AQgw".indexOf(v5[v5.length - 1]) === -1) {
              throw new Error("Invalid base64 padding");
            }
          } else if (last === 3) {
            if ("AEIMQUYcgkosw048".indexOf(v5[v5.length - 1]) === -1) {
              throw new Error("Invalid base64 padding");
            }
          }
          return tag;
        },
        // Base64; see Section 3.4.5.3
        34: (v5, tag) => {
          const m4 = v5.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/);
          if (!m4) {
            throw new Error("Invalid base64 characters");
          }
          if (v5.length % 4 !== 0) {
            throw new Error("Invalid base64 length");
          }
          if (m4.groups.padding === "=") {
            if ("AQgw".indexOf(v5[v5.length - 2]) === -1) {
              throw new Error("Invalid base64 padding");
            }
          } else if (m4.groups.padding === "==") {
            if ("AEIMQUYcgkosw048".indexOf(v5[v5.length - 3]) === -1) {
              throw new Error("Invalid base64 padding");
            }
          }
          return tag;
        },
        // Regular expression; see Section 2.4.4.3
        35: (v5) => new RegExp(v5),
        // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
        258: (v5) => new Set(v5)
      };
      var TYPED_ARRAY_TAGS = {
        64: Uint8Array,
        65: Uint16Array,
        66: Uint32Array,
        // 67: BigUint64Array,  Safari doesn't implement
        68: Uint8ClampedArray,
        69: Uint16Array,
        70: Uint32Array,
        // 71: BigUint64Array,  Safari doesn't implement
        72: Int8Array,
        73: Int16Array,
        74: Int32Array,
        // 75: BigInt64Array,  Safari doesn't implement
        // 76: reserved
        77: Int16Array,
        78: Int32Array,
        // 79: BigInt64Array,  Safari doesn't implement
        // 80: not implemented, float16 array
        81: Float32Array,
        82: Float64Array,
        // 83: not implemented, float128 array
        // 84: not implemented, float16 array
        85: Float32Array,
        86: Float64Array
        // 87: not implemented, float128 array
      };
      if (typeof BigUint64Array !== "undefined") {
        TYPED_ARRAY_TAGS[67] = BigUint64Array;
        TYPED_ARRAY_TAGS[71] = BigUint64Array;
      }
      if (typeof BigInt64Array !== "undefined") {
        TYPED_ARRAY_TAGS[75] = BigInt64Array;
        TYPED_ARRAY_TAGS[79] = BigInt64Array;
      }
      function _toTypedArray(val, tagged) {
        if (!utils.isBufferish(val)) {
          throw new TypeError("val not a buffer");
        }
        const { tag } = tagged;
        const TypedClass = TYPED_ARRAY_TAGS[tag];
        if (!TypedClass) {
          throw new Error(`Invalid typed array tag: ${tag}`);
        }
        const little = tag & 4;
        const float = (tag & 16) >> 4;
        const sz = 2 ** (float + (tag & 3));
        if (!little !== utils.isBigEndian() && sz > 1) {
          swapEndian(val.buffer, sz, val.byteOffset, val.byteLength);
        }
        const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);
        return new TypedClass(ab);
      }
      for (const n5 of Object.keys(TYPED_ARRAY_TAGS)) {
        TAGS[n5] = _toTypedArray;
      }
      var current_TAGS = {};
      var Tagged = class _Tagged {
        /**
         * Creates an instance of Tagged.
         *
         * @param {number} tag The number of the tag.
         * @param {any} value The value inside the tag.
         * @param {Error} [err] The error that was thrown parsing the tag, or null.
         */
        constructor(tag, value, err) {
          this.tag = tag;
          this.value = value;
          this.err = err;
          if (typeof this.tag !== "number") {
            throw new Error(`Invalid tag type (${typeof this.tag})`);
          }
          if (this.tag < 0 || (this.tag | 0) !== this.tag) {
            throw new Error(`Tag must be a positive integer: ${this.tag}`);
          }
        }
        toJSON() {
          if (this[INTERNAL_JSON]) {
            return this[INTERNAL_JSON].call(this.value);
          }
          const ret = {
            tag: this.tag,
            value: this.value
          };
          if (this.err) {
            ret.err = this.err;
          }
          return ret;
        }
        /**
         * Convert to a String.
         *
         * @returns {string} String of the form '1(2)'.
         */
        toString() {
          return `${this.tag}(${JSON.stringify(this.value)})`;
        }
        /**
         * Push the simple value onto the CBOR stream.
         *
         * @param {object} gen The generator to push onto.
         * @returns {boolean} True on success.
         */
        encodeCBOR(gen) {
          gen._pushTag(this.tag);
          return gen.pushAny(this.value);
        }
        /**
         * If we have a converter for this type, do the conversion.  Some converters
         * are built-in.  Additional ones can be passed in.  If you want to remove
         * a built-in converter, pass a converter in whose value is 'null' instead
         * of a function.
         *
         * @param {object} converters Keys in the object are a tag number, the value
         *   is a function that takes the decoded CBOR and returns a JavaScript value
         *   of the appropriate type.  Throw an exception in the function on errors.
         * @returns {any} The converted item.
         */
        convert(converters) {
          let f5 = converters == null ? void 0 : converters[this.tag];
          if (typeof f5 !== "function") {
            f5 = _Tagged.TAGS[this.tag];
            if (typeof f5 !== "function") {
              return this;
            }
          }
          try {
            return f5.call(this, this.value, this);
          } catch (error) {
            if (error && error.message && error.message.length > 0) {
              this.err = error.message;
            } else {
              this.err = error;
            }
            return this;
          }
        }
        /**
         * The current set of supported tags.  May be modified by plugins.
         *
         * @type {TagMap}
         * @static
         */
        static get TAGS() {
          return current_TAGS;
        }
        static set TAGS(val) {
          current_TAGS = val;
        }
        /**
         * Reset the supported tags to the original set, before any plugins modified
         * the list.
         */
        static reset() {
          _Tagged.TAGS = { ...TAGS };
        }
      };
      Tagged.INTERNAL_JSON = INTERNAL_JSON;
      Tagged.reset();
      module.exports = Tagged;
    }
  });

  // ../../node_modules/cbor/lib/simple.js
  var require_simple = __commonJS({
    "../../node_modules/cbor/lib/simple.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var { MT, SIMPLE, SYMS } = require_constants();
      var Simple = class _Simple {
        /**
         * Creates an instance of Simple.
         *
         * @param {number} value The simple value's integer value.
         */
        constructor(value) {
          if (typeof value !== "number") {
            throw new Error(`Invalid Simple type: ${typeof value}`);
          }
          if (value < 0 || value > 255 || (value | 0) !== value) {
            throw new Error(`value must be a small positive integer: ${value}`);
          }
          this.value = value;
        }
        /**
         * Debug string for simple value.
         *
         * @returns {string} Formated string of `simple(value)`.
         */
        toString() {
          return `simple(${this.value})`;
        }
        /**
         * Debug string for simple value.
         *
         * @param {number} depth How deep are we?
         * @param {object} opts Options.
         * @returns {string} Formatted string of `simple(value)`.
         */
        [Symbol.for("nodejs.util.inspect.custom")](depth, opts) {
          return `simple(${this.value})`;
        }
        /**
         * Push the simple value onto the CBOR stream.
         *
         * @param {object} gen The generator to push onto.
         * @returns {boolean} True on success.
         */
        encodeCBOR(gen) {
          return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
        }
        /**
         * Is the given object a Simple?
         *
         * @param {any} obj Object to test.
         * @returns {boolean} Is it Simple?
         */
        static isSimple(obj) {
          return obj instanceof _Simple;
        }
        /**
         * Decode from the CBOR additional information into a JavaScript value.
         * If the CBOR item has no parent, return a "safe" symbol instead of
         * `null` or `undefined`, so that the value can be passed through a
         * stream in object mode.
         *
         * @param {number} val The CBOR additional info to convert.
         * @param {boolean} [has_parent=true] Does the CBOR item have a parent?
         * @param {boolean} [parent_indefinite=false] Is the parent element
         *   indefinitely encoded?
         * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.
         * @throws {Error} Invalid BREAK.
         */
        static decode(val, has_parent = true, parent_indefinite = false) {
          switch (val) {
            case SIMPLE.FALSE:
              return false;
            case SIMPLE.TRUE:
              return true;
            case SIMPLE.NULL:
              if (has_parent) {
                return null;
              }
              return SYMS.NULL;
            case SIMPLE.UNDEFINED:
              if (has_parent) {
                return void 0;
              }
              return SYMS.UNDEFINED;
            case -1:
              if (!has_parent || !parent_indefinite) {
                throw new Error("Invalid BREAK");
              }
              return SYMS.BREAK;
            default:
              return new _Simple(val);
          }
        }
      };
      module.exports = Simple;
    }
  });

  // ../../node_modules/cbor/lib/decoder.js
  var require_decoder = __commonJS({
    "../../node_modules/cbor/lib/decoder.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var BinaryParseStream = require_binary_parse_stream();
      var Tagged = require_tagged();
      var Simple = require_simple();
      var utils = require_utils2();
      var NoFilter = require_lib();
      var stream = (init_stream(), __toCommonJS(stream_exports));
      var constants2 = require_constants();
      var { MT, NUMBYTES, SYMS, BI } = constants2;
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var COUNT = Symbol("count");
      var MAJOR = Symbol("major type");
      var ERROR = Symbol("error");
      var NOT_FOUND = Symbol("not found");
      function parentArray(parent, typ, count) {
        const a5 = [];
        a5[COUNT] = count;
        a5[SYMS.PARENT] = parent;
        a5[MAJOR] = typ;
        return a5;
      }
      function parentBufferStream(parent, typ) {
        const b4 = new NoFilter();
        b4[COUNT] = -1;
        b4[SYMS.PARENT] = parent;
        b4[MAJOR] = typ;
        return b4;
      }
      var UnexpectedDataError = class extends Error {
        constructor(byte, value) {
          super(`Unexpected data: 0x${byte.toString(16)}`);
          this.name = "UnexpectedDataError";
          this.byte = byte;
          this.value = value;
        }
      };
      function normalizeOptions(opts, cb) {
        switch (typeof opts) {
          case "function":
            return { options: {}, cb: (
              /** @type {decodeCallback} */
              opts
            ) };
          case "string":
            return { options: { encoding: (
              /** @type {BufferEncoding} */
              opts
            ) }, cb };
          case "object":
            return { options: opts || {}, cb };
          default:
            throw new TypeError("Unknown option type");
        }
      }
      var Decoder = class _Decoder extends BinaryParseStream {
        /**
         * Create a parsing stream.
         *
         * @param {DecoderOptions} [options={}] Options.
         */
        constructor(options = {}) {
          const {
            tags = {},
            max_depth = -1,
            preferWeb = false,
            required = false,
            encoding = "hex",
            extendedResults = false,
            preventDuplicateKeys = false,
            ...superOpts
          } = options;
          super({ defaultEncoding: encoding, ...superOpts });
          this.running = true;
          this.max_depth = max_depth;
          this.tags = tags;
          this.preferWeb = preferWeb;
          this.extendedResults = extendedResults;
          this.required = required;
          this.preventDuplicateKeys = preventDuplicateKeys;
          if (extendedResults) {
            this.bs.on("read", this._onRead.bind(this));
            this.valueBytes = /** @type {NoFilter} */
            new NoFilter();
          }
        }
        /**
         * Check the given value for a symbol encoding a NULL or UNDEFINED value in
         * the CBOR stream.
         *
         * @static
         * @param {any} val The value to check.
         * @returns {any} The corrected value.
         * @throws {Error} Nothing was found.
         * @example
         * myDecoder.on('data', val => {
         *   val = Decoder.nullcheck(val)
         *   // ...
         * })
         */
        static nullcheck(val) {
          switch (val) {
            case SYMS.NULL:
              return null;
            case SYMS.UNDEFINED:
              return void 0;
            // Leaving this in for now as belt-and-suspenders, but I'm pretty sure
            // it can't happen.
            /* istanbul ignore next */
            case NOT_FOUND:
              throw new Error("Value not found");
            default:
              return val;
          }
        }
        /**
         * Decode the first CBOR item in the input, synchronously.  This will throw
         * an exception if the input is not valid CBOR, or if there are more bytes
         * left over at the end (if options.extendedResults is not true).
         *
         * @static
         * @param {BufferLike} input If a Readable stream, must have
         *   received the `readable` event already, or you will get an error
         *   claiming "Insufficient data".
         * @param {DecoderOptions|string} [options={}] Options or encoding for input.
         * @returns {ExtendedResults|any} The decoded value.
         * @throws {UnexpectedDataError} Data is left over after decoding.
         * @throws {Error} Insufficient data.
         */
        static decodeFirstSync(input, options = {}) {
          if (input == null) {
            throw new TypeError("input required");
          }
          ({ options } = normalizeOptions(options));
          const { encoding = "hex", ...opts } = options;
          const c5 = new _Decoder(opts);
          const s5 = utils.guessEncoding(input, encoding);
          const parser = c5._parse();
          let state = parser.next();
          while (!state.done) {
            const b4 = s5.read(state.value);
            if (b4 == null || b4.length !== state.value) {
              throw new Error("Insufficient data");
            }
            if (c5.extendedResults) {
              c5.valueBytes.write(b4);
            }
            state = parser.next(b4);
          }
          let val = null;
          if (c5.extendedResults) {
            val = state.value;
            val.unused = s5.read();
          } else {
            val = _Decoder.nullcheck(state.value);
            if (s5.length > 0) {
              const nextByte = s5.read(1);
              s5.unshift(nextByte);
              throw new UnexpectedDataError(nextByte[0], val);
            }
          }
          return val;
        }
        /**
         * Decode all of the CBOR items in the input into an array.  This will throw
         * an exception if the input is not valid CBOR; a zero-length input will
         * return an empty array.
         *
         * @static
         * @param {BufferLike} input What to parse?
         * @param {DecoderOptions|string} [options={}] Options or encoding
         *   for input.
         * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.
         * @throws {TypeError} No input provided.
         * @throws {Error} Insufficient data provided.
         */
        static decodeAllSync(input, options = {}) {
          if (input == null) {
            throw new TypeError("input required");
          }
          ({ options } = normalizeOptions(options));
          const { encoding = "hex", ...opts } = options;
          const c5 = new _Decoder(opts);
          const s5 = utils.guessEncoding(input, encoding);
          const res = [];
          while (s5.length > 0) {
            const parser = c5._parse();
            let state = parser.next();
            while (!state.done) {
              const b4 = s5.read(state.value);
              if (b4 == null || b4.length !== state.value) {
                throw new Error("Insufficient data");
              }
              if (c5.extendedResults) {
                c5.valueBytes.write(b4);
              }
              state = parser.next(b4);
            }
            res.push(_Decoder.nullcheck(state.value));
          }
          return res;
        }
        /**
         * Decode the first CBOR item in the input.  This will error if there are
         * more bytes left over at the end (if options.extendedResults is not true),
         * and optionally if there were no valid CBOR bytes in the input.  Emits the
         * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the
         * `required` option is false.
         *
         * @static
         * @param {BufferLike} input What to parse?
         * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the
         *   callback, or input encoding.
         * @param {decodeCallback} [cb] Callback.
         * @returns {Promise<ExtendedResults|any>} Returned even if callback is
         *   specified.
         * @throws {TypeError} No input provided.
         */
        static decodeFirst(input, options = {}, cb = null) {
          if (input == null) {
            throw new TypeError("input required");
          }
          ({ options, cb } = normalizeOptions(options, cb));
          const { encoding = "hex", required = false, ...opts } = options;
          const c5 = new _Decoder(opts);
          let v5 = (
            /** @type {any} */
            NOT_FOUND
          );
          const s5 = utils.guessEncoding(input, encoding);
          const p5 = new Promise((resolve2, reject) => {
            c5.on("data", (val) => {
              v5 = _Decoder.nullcheck(val);
              c5.close();
            });
            c5.once("error", (er) => {
              if (c5.extendedResults && er instanceof UnexpectedDataError) {
                v5.unused = c5.bs.slice();
                return resolve2(v5);
              }
              if (v5 !== NOT_FOUND) {
                er["value"] = v5;
              }
              v5 = ERROR;
              c5.close();
              return reject(er);
            });
            c5.once("end", () => {
              switch (v5) {
                case NOT_FOUND:
                  if (required) {
                    return reject(new Error("No CBOR found"));
                  }
                  return resolve2(v5);
                // Pretty sure this can't happen, but not *certain*.
                /* istanbul ignore next */
                case ERROR:
                  return void 0;
                default:
                  return resolve2(v5);
              }
            });
          });
          if (typeof cb === "function") {
            p5.then((val) => cb(null, val), cb);
          }
          s5.pipe(c5);
          return p5;
        }
        /**
         * @callback decodeAllCallback
         * @param {Error} error If one was generated.
         * @param {Array<ExtendedResults>|Array<any>} value All of the decoded
         *   values, wrapped in an Array.
         */
        /**
         * Decode all of the CBOR items in the input.  This will error if there are
         * more bytes left over at the end.
         *
         * @static
         * @param {BufferLike} input What to parse?
         * @param {DecoderOptions|decodeAllCallback|string} [options={}]
         *   Decoding options, the callback, or the input encoding.
         * @param {decodeAllCallback} [cb] Callback.
         * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback
         *   is specified.
         * @throws {TypeError} No input specified.
         */
        static decodeAll(input, options = {}, cb = null) {
          if (input == null) {
            throw new TypeError("input required");
          }
          ({ options, cb } = normalizeOptions(options, cb));
          const { encoding = "hex", ...opts } = options;
          const c5 = new _Decoder(opts);
          const vals = [];
          c5.on("data", (val) => vals.push(_Decoder.nullcheck(val)));
          const p5 = new Promise((resolve2, reject) => {
            c5.on("error", reject);
            c5.on("end", () => resolve2(vals));
          });
          if (typeof cb === "function") {
            p5.then((v5) => cb(void 0, v5), (er) => cb(er, void 0));
          }
          utils.guessEncoding(input, encoding).pipe(c5);
          return p5;
        }
        /**
         * Stop processing.
         */
        close() {
          this.running = false;
          this.__fresh = true;
        }
        /**
         * Only called if extendedResults is true.
         *
         * @ignore
         */
        _onRead(data) {
          this.valueBytes.write(data);
        }
        /**
         * @yields {number} Number of bytes to read.
         * @returns {Generator<number, any, Buffer>} Yields a number of bytes,
         *   returns anything, next returns a Buffer.
         * @throws {Error} Maximum depth exceeded.
         * @ignore
         */
        *_parse() {
          let parent = null;
          let depth = 0;
          let val = null;
          while (true) {
            if (this.max_depth >= 0 && depth > this.max_depth) {
              throw new Error(`Maximum depth ${this.max_depth} exceeded`);
            }
            const [octet] = yield 1;
            if (!this.running) {
              this.bs.unshift(Buffer3.from([octet]));
              throw new UnexpectedDataError(octet);
            }
            const mt = octet >> 5;
            const ai = octet & 31;
            const parent_major = parent == null ? void 0 : parent[MAJOR];
            const parent_length = parent == null ? void 0 : parent.length;
            switch (ai) {
              case NUMBYTES.ONE:
                this.emit("more-bytes", mt, 1, parent_major, parent_length);
                [val] = yield 1;
                break;
              case NUMBYTES.TWO:
              case NUMBYTES.FOUR:
              case NUMBYTES.EIGHT: {
                const numbytes = 1 << ai - 24;
                this.emit("more-bytes", mt, numbytes, parent_major, parent_length);
                const buf = yield numbytes;
                val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);
                break;
              }
              case 28:
              case 29:
              case 30:
                this.running = false;
                throw new Error(`Additional info not implemented: ${ai}`);
              case NUMBYTES.INDEFINITE:
                switch (mt) {
                  case MT.POS_INT:
                  case MT.NEG_INT:
                  case MT.TAG:
                    throw new Error(`Invalid indefinite encoding for MT ${mt}`);
                }
                val = -1;
                break;
              default:
                val = ai;
            }
            switch (mt) {
              case MT.POS_INT:
                break;
              case MT.NEG_INT:
                if (val === Number.MAX_SAFE_INTEGER) {
                  val = BI.NEG_MAX;
                } else {
                  val = typeof val === "bigint" ? BI.MINUS_ONE - val : -1 - val;
                }
                break;
              case MT.BYTE_STRING:
              case MT.UTF8_STRING:
                switch (val) {
                  case 0:
                    this.emit("start-string", mt, val, parent_major, parent_length);
                    if (mt === MT.UTF8_STRING) {
                      val = "";
                    } else {
                      val = this.preferWeb ? new Uint8Array(0) : Buffer3.allocUnsafe(0);
                    }
                    break;
                  case -1:
                    this.emit("start", mt, SYMS.STREAM, parent_major, parent_length);
                    parent = parentBufferStream(parent, mt);
                    depth++;
                    continue;
                  default:
                    this.emit("start-string", mt, val, parent_major, parent_length);
                    val = yield val;
                    if (mt === MT.UTF8_STRING) {
                      val = utils.utf8(val);
                    } else if (this.preferWeb) {
                      val = new Uint8Array(val.buffer, val.byteOffset, val.length);
                    }
                }
                break;
              case MT.ARRAY:
              case MT.MAP:
                switch (val) {
                  case 0:
                    val = mt === MT.MAP ? {} : [];
                    break;
                  case -1:
                    this.emit("start", mt, SYMS.STREAM, parent_major, parent_length);
                    parent = parentArray(parent, mt, -1);
                    depth++;
                    continue;
                  default:
                    this.emit("start", mt, val, parent_major, parent_length);
                    parent = parentArray(parent, mt, val * (mt - 3));
                    depth++;
                    continue;
                }
                break;
              case MT.TAG:
                this.emit("start", mt, val, parent_major, parent_length);
                parent = parentArray(parent, mt, 1);
                parent.push(val);
                depth++;
                continue;
              case MT.SIMPLE_FLOAT:
                if (typeof val === "number") {
                  if (ai === NUMBYTES.ONE && val < 32) {
                    throw new Error(
                      `Invalid two-byte encoding of simple value ${val}`
                    );
                  }
                  const hasParent = parent != null;
                  val = Simple.decode(
                    val,
                    hasParent,
                    hasParent && parent[COUNT] < 0
                  );
                } else {
                  val = utils.parseCBORfloat(val);
                }
            }
            this.emit("value", val, parent_major, parent_length, ai);
            let again = false;
            while (parent != null) {
              if (val === SYMS.BREAK) {
                parent[COUNT] = 1;
              } else if (Array.isArray(parent)) {
                parent.push(val);
              } else {
                const pm = parent[MAJOR];
                if (pm != null && pm !== mt) {
                  this.running = false;
                  throw new Error("Invalid major type in indefinite encoding");
                }
                parent.write(val);
              }
              if (--parent[COUNT] !== 0) {
                again = true;
                break;
              }
              --depth;
              delete parent[COUNT];
              if (Array.isArray(parent)) {
                switch (parent[MAJOR]) {
                  case MT.ARRAY:
                    val = parent;
                    break;
                  case MT.MAP: {
                    let allstrings = true;
                    if (parent.length % 2 !== 0) {
                      throw new Error(`Invalid map length: ${parent.length}`);
                    }
                    for (let i5 = 0, len = parent.length; i5 < len; i5 += 2) {
                      if (typeof parent[i5] !== "string" || parent[i5] === "__proto__") {
                        allstrings = false;
                        break;
                      }
                    }
                    if (allstrings) {
                      val = {};
                      for (let i5 = 0, len = parent.length; i5 < len; i5 += 2) {
                        if (this.preventDuplicateKeys && Object.prototype.hasOwnProperty.call(val, parent[i5])) {
                          throw new Error("Duplicate keys in a map");
                        }
                        val[parent[i5]] = parent[i5 + 1];
                      }
                    } else {
                      val = /* @__PURE__ */ new Map();
                      for (let i5 = 0, len = parent.length; i5 < len; i5 += 2) {
                        if (this.preventDuplicateKeys && val.has(parent[i5])) {
                          throw new Error("Duplicate keys in a map");
                        }
                        val.set(parent[i5], parent[i5 + 1]);
                      }
                    }
                    break;
                  }
                  case MT.TAG: {
                    const t5 = new Tagged(parent[0], parent[1]);
                    val = t5.convert(this.tags);
                    break;
                  }
                }
              } else if (parent instanceof NoFilter) {
                switch (parent[MAJOR]) {
                  case MT.BYTE_STRING:
                    val = parent.slice();
                    if (this.preferWeb) {
                      val = new Uint8Array(
                        /** @type {Buffer} */
                        val.buffer,
                        /** @type {Buffer} */
                        val.byteOffset,
                        /** @type {Buffer} */
                        val.length
                      );
                    }
                    break;
                  case MT.UTF8_STRING:
                    val = parent.toString("utf-8");
                    break;
                }
              }
              this.emit("stop", parent[MAJOR]);
              const old = parent;
              parent = parent[SYMS.PARENT];
              delete old[SYMS.PARENT];
              delete old[MAJOR];
            }
            if (!again) {
              if (this.extendedResults) {
                const bytes = this.valueBytes.slice();
                const ret = {
                  value: _Decoder.nullcheck(val),
                  bytes,
                  length: bytes.length
                };
                this.valueBytes = new NoFilter();
                return ret;
              }
              return val;
            }
          }
        }
      };
      Decoder.NOT_FOUND = NOT_FOUND;
      module.exports = Decoder;
    }
  });

  // ../../node_modules/cbor/lib/commented.js
  var require_commented = __commonJS({
    "../../node_modules/cbor/lib/commented.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var stream = (init_stream(), __toCommonJS(stream_exports));
      var utils = require_utils2();
      var Decoder = require_decoder();
      var NoFilter = require_lib();
      var { MT, NUMBYTES, SYMS } = require_constants();
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      function plural(c5) {
        if (c5 > 1) {
          return "s";
        }
        return "";
      }
      function normalizeOptions(opts, cb) {
        switch (typeof opts) {
          case "function":
            return { options: {}, cb: (
              /** @type {commentCallback} */
              opts
            ) };
          case "string":
            return { options: { encoding: (
              /** @type {BufferEncoding} */
              opts
            ) }, cb };
          case "number":
            return { options: { max_depth: opts }, cb };
          case "object":
            return { options: opts || {}, cb };
          default:
            throw new TypeError("Unknown option type");
        }
      }
      var Commented = class _Commented extends stream.Transform {
        /**
         * Create a CBOR commenter.
         *
         * @param {CommentOptions} [options={}] Stream options.
         */
        constructor(options = {}) {
          const {
            depth = 1,
            max_depth = 10,
            no_summary = false,
            // Decoder options
            tags = {},
            preferWeb,
            encoding,
            // Stream.Transform options
            ...superOpts
          } = options;
          super({
            ...superOpts,
            readableObjectMode: false,
            writableObjectMode: false
          });
          this.depth = depth;
          this.max_depth = max_depth;
          this.all = new NoFilter();
          if (!tags[24]) {
            tags[24] = this._tag_24.bind(this);
          }
          this.parser = new Decoder({
            tags,
            max_depth,
            preferWeb,
            encoding
          });
          this.parser.on("value", this._on_value.bind(this));
          this.parser.on("start", this._on_start.bind(this));
          this.parser.on("start-string", this._on_start_string.bind(this));
          this.parser.on("stop", this._on_stop.bind(this));
          this.parser.on("more-bytes", this._on_more.bind(this));
          this.parser.on("error", this._on_error.bind(this));
          if (!no_summary) {
            this.parser.on("data", this._on_data.bind(this));
          }
          this.parser.bs.on("read", this._on_read.bind(this));
        }
        /**
         * @param {Buffer} v Descend into embedded CBOR.
         * @private
         */
        _tag_24(v5) {
          const c5 = new _Commented({ depth: this.depth + 1, no_summary: true });
          c5.on("data", (b4) => this.push(b4));
          c5.on("error", (er) => this.emit("error", er));
          c5.end(v5);
        }
        _transform(fresh, encoding, cb) {
          this.parser.write(fresh, encoding, cb);
        }
        _flush(cb) {
          return this.parser._flush(cb);
        }
        /**
         * Comment on an input Buffer or string, creating a string passed to the
         * callback.  If callback not specified, a promise is returned.
         *
         * @static
         * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray
         *   |DataView|stream.Readable} input Something to parse.
         * @param {CommentOptions|commentCallback|string|number} [options={}]
         *   Encoding, max_depth, or callback.
         * @param {commentCallback} [cb] If specified, called on completion.
         * @returns {Promise} If cb not specified.
         * @throws {Error} Input required.
         */
        static comment(input, options = {}, cb = null) {
          if (input == null) {
            throw new Error("input required");
          }
          ({ options, cb } = normalizeOptions(options, cb));
          const bs = new NoFilter();
          const { encoding = "hex", ...opts } = options;
          const d4 = new _Commented(opts);
          let p5 = null;
          if (typeof cb === "function") {
            d4.on("end", () => {
              cb(null, bs.toString("utf8"));
            });
            d4.on("error", cb);
          } else {
            p5 = new Promise((resolve2, reject) => {
              d4.on("end", () => {
                resolve2(bs.toString("utf8"));
              });
              d4.on("error", reject);
            });
          }
          d4.pipe(bs);
          utils.guessEncoding(input, encoding).pipe(d4);
          return p5;
        }
        /**
         * @ignore
         */
        _on_error(er) {
          this.push("ERROR: ");
          this.push(er.toString());
          this.push("\n");
        }
        /**
         * @ignore
         */
        _on_read(buf) {
          this.all.write(buf);
          const hex = buf.toString("hex");
          this.push(new Array(this.depth + 1).join("  "));
          this.push(hex);
          let ind = (this.max_depth - this.depth) * 2 - hex.length;
          if (ind < 1) {
            ind = 1;
          }
          this.push(new Array(ind + 1).join(" "));
          this.push("-- ");
        }
        /**
         * @ignore
         */
        _on_more(mt, len, parent_mt, pos) {
          let desc = "";
          this.depth++;
          switch (mt) {
            case MT.POS_INT:
              desc = "Positive number,";
              break;
            case MT.NEG_INT:
              desc = "Negative number,";
              break;
            case MT.ARRAY:
              desc = "Array, length";
              break;
            case MT.MAP:
              desc = "Map, count";
              break;
            case MT.BYTE_STRING:
              desc = "Bytes, length";
              break;
            case MT.UTF8_STRING:
              desc = "String, length";
              break;
            case MT.SIMPLE_FLOAT:
              if (len === 1) {
                desc = "Simple value,";
              } else {
                desc = "Float,";
              }
              break;
          }
          this.push(`${desc} next ${len} byte${plural(len)}
`);
        }
        /**
         * @ignore
         */
        _on_start_string(mt, len, parent_mt, pos) {
          let desc = "";
          this.depth++;
          switch (mt) {
            case MT.BYTE_STRING:
              desc = `Bytes, length: ${len}`;
              break;
            case MT.UTF8_STRING:
              desc = `String, length: ${len.toString()}`;
              break;
          }
          this.push(`${desc}
`);
        }
        /**
         * @ignore
         */
        _on_start(mt, tag, parent_mt, pos) {
          this.depth++;
          switch (parent_mt) {
            case MT.ARRAY:
              this.push(`[${pos}], `);
              break;
            case MT.MAP:
              if (pos % 2) {
                this.push(`{Val:${Math.floor(pos / 2)}}, `);
              } else {
                this.push(`{Key:${Math.floor(pos / 2)}}, `);
              }
              break;
          }
          switch (mt) {
            case MT.TAG:
              this.push(`Tag #${tag}`);
              if (tag === 24) {
                this.push(" Encoded CBOR data item");
              }
              break;
            case MT.ARRAY:
              if (tag === SYMS.STREAM) {
                this.push("Array (streaming)");
              } else {
                this.push(`Array, ${tag} item${plural(tag)}`);
              }
              break;
            case MT.MAP:
              if (tag === SYMS.STREAM) {
                this.push("Map (streaming)");
              } else {
                this.push(`Map, ${tag} pair${plural(tag)}`);
              }
              break;
            case MT.BYTE_STRING:
              this.push("Bytes (streaming)");
              break;
            case MT.UTF8_STRING:
              this.push("String (streaming)");
              break;
          }
          this.push("\n");
        }
        /**
         * @ignore
         */
        _on_stop(mt) {
          this.depth--;
        }
        /**
         * @private
         */
        _on_value(val, parent_mt, pos, ai) {
          if (val !== SYMS.BREAK) {
            switch (parent_mt) {
              case MT.ARRAY:
                this.push(`[${pos}], `);
                break;
              case MT.MAP:
                if (pos % 2) {
                  this.push(`{Val:${Math.floor(pos / 2)}}, `);
                } else {
                  this.push(`{Key:${Math.floor(pos / 2)}}, `);
                }
                break;
            }
          }
          const str = utils.cborValueToString(val, -Infinity);
          if (typeof val === "string" || Buffer3.isBuffer(val)) {
            if (val.length > 0) {
              this.push(str);
              this.push("\n");
            }
            this.depth--;
          } else {
            this.push(str);
            this.push("\n");
          }
          switch (ai) {
            case NUMBYTES.ONE:
            case NUMBYTES.TWO:
            case NUMBYTES.FOUR:
            case NUMBYTES.EIGHT:
              this.depth--;
          }
        }
        /**
         * @ignore
         */
        _on_data() {
          this.push("0x");
          this.push(this.all.read().toString("hex"));
          this.push("\n");
        }
      };
      module.exports = Commented;
    }
  });

  // ../../node_modules/cbor/lib/diagnose.js
  var require_diagnose = __commonJS({
    "../../node_modules/cbor/lib/diagnose.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var stream = (init_stream(), __toCommonJS(stream_exports));
      var Decoder = require_decoder();
      var utils = require_utils2();
      var NoFilter = require_lib();
      var { MT, SYMS } = require_constants();
      function normalizeOptions(opts, cb) {
        switch (typeof opts) {
          case "function":
            return { options: {}, cb: (
              /** @type {diagnoseCallback} */
              opts
            ) };
          case "string":
            return { options: { encoding: (
              /** @type {BufferEncoding} */
              opts
            ) }, cb };
          case "object":
            return { options: opts || {}, cb };
          default:
            throw new TypeError("Unknown option type");
        }
      }
      var Diagnose = class _Diagnose extends stream.Transform {
        /**
         * Creates an instance of Diagnose.
         *
         * @param {DiagnoseOptions} [options={}] Options for creation.
         */
        constructor(options = {}) {
          const {
            separator = "\n",
            stream_errors = false,
            // Decoder options
            tags,
            max_depth,
            preferWeb,
            encoding,
            // Stream.Transform options
            ...superOpts
          } = options;
          super({
            ...superOpts,
            readableObjectMode: false,
            writableObjectMode: false
          });
          this.float_bytes = -1;
          this.separator = separator;
          this.stream_errors = stream_errors;
          this.parser = new Decoder({
            tags,
            max_depth,
            preferWeb,
            encoding
          });
          this.parser.on("more-bytes", this._on_more.bind(this));
          this.parser.on("value", this._on_value.bind(this));
          this.parser.on("start", this._on_start.bind(this));
          this.parser.on("stop", this._on_stop.bind(this));
          this.parser.on("data", this._on_data.bind(this));
          this.parser.on("error", this._on_error.bind(this));
        }
        _transform(fresh, encoding, cb) {
          return this.parser.write(fresh, encoding, cb);
        }
        _flush(cb) {
          return this.parser._flush((er) => {
            if (this.stream_errors) {
              if (er) {
                this._on_error(er);
              }
              return cb();
            }
            return cb(er);
          });
        }
        /**
         * Convenience function to return a string in diagnostic format.
         *
         * @param {BufferLike} input The CBOR bytes to format.
         * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]
         *   Options, the callback, or the input encoding.
         * @param {diagnoseCallback} [cb] Callback.
         * @throws {TypeError} Input not provided.
         * @returns {Promise} If callback not specified.
         */
        static diagnose(input, options = {}, cb = null) {
          if (input == null) {
            throw new TypeError("input required");
          }
          ({ options, cb } = normalizeOptions(options, cb));
          const { encoding = "hex", ...opts } = options;
          const bs = new NoFilter();
          const d4 = new _Diagnose(opts);
          let p5 = null;
          if (typeof cb === "function") {
            d4.on("end", () => cb(null, bs.toString("utf8")));
            d4.on("error", cb);
          } else {
            p5 = new Promise((resolve2, reject) => {
              d4.on("end", () => resolve2(bs.toString("utf8")));
              d4.on("error", reject);
            });
          }
          d4.pipe(bs);
          utils.guessEncoding(input, encoding).pipe(d4);
          return p5;
        }
        /**
         * @ignore
         */
        _on_error(er) {
          if (this.stream_errors) {
            this.push(er.toString());
          } else {
            this.emit("error", er);
          }
        }
        /** @private */
        _on_more(mt, len, parent_mt, pos) {
          if (mt === MT.SIMPLE_FLOAT) {
            this.float_bytes = {
              2: 1,
              4: 2,
              8: 3
            }[len];
          }
        }
        /** @private */
        _fore(parent_mt, pos) {
          switch (parent_mt) {
            case MT.BYTE_STRING:
            case MT.UTF8_STRING:
            case MT.ARRAY:
              if (pos > 0) {
                this.push(", ");
              }
              break;
            case MT.MAP:
              if (pos > 0) {
                if (pos % 2) {
                  this.push(": ");
                } else {
                  this.push(", ");
                }
              }
          }
        }
        /** @private */
        _on_value(val, parent_mt, pos) {
          if (val === SYMS.BREAK) {
            return;
          }
          this._fore(parent_mt, pos);
          const fb = this.float_bytes;
          this.float_bytes = -1;
          this.push(utils.cborValueToString(val, fb));
        }
        /** @private */
        _on_start(mt, tag, parent_mt, pos) {
          this._fore(parent_mt, pos);
          switch (mt) {
            case MT.TAG:
              this.push(`${tag}(`);
              break;
            case MT.ARRAY:
              this.push("[");
              break;
            case MT.MAP:
              this.push("{");
              break;
            case MT.BYTE_STRING:
            case MT.UTF8_STRING:
              this.push("(");
              break;
          }
          if (tag === SYMS.STREAM) {
            this.push("_ ");
          }
        }
        /** @private */
        _on_stop(mt) {
          switch (mt) {
            case MT.TAG:
              this.push(")");
              break;
            case MT.ARRAY:
              this.push("]");
              break;
            case MT.MAP:
              this.push("}");
              break;
            case MT.BYTE_STRING:
            case MT.UTF8_STRING:
              this.push(")");
              break;
          }
        }
        /** @private */
        _on_data() {
          this.push(this.separator);
        }
      };
      module.exports = Diagnose;
    }
  });

  // ../../node_modules/cbor/lib/encoder.js
  var require_encoder = __commonJS({
    "../../node_modules/cbor/lib/encoder.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var stream = (init_stream(), __toCommonJS(stream_exports));
      var NoFilter = require_lib();
      var utils = require_utils2();
      var constants2 = require_constants();
      var {
        MT,
        NUMBYTES,
        SHIFT32,
        SIMPLE,
        SYMS,
        TAG,
        BI
      } = constants2;
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var HALF = MT.SIMPLE_FLOAT << 5 | NUMBYTES.TWO;
      var FLOAT = MT.SIMPLE_FLOAT << 5 | NUMBYTES.FOUR;
      var DOUBLE = MT.SIMPLE_FLOAT << 5 | NUMBYTES.EIGHT;
      var TRUE = MT.SIMPLE_FLOAT << 5 | SIMPLE.TRUE;
      var FALSE = MT.SIMPLE_FLOAT << 5 | SIMPLE.FALSE;
      var UNDEFINED = MT.SIMPLE_FLOAT << 5 | SIMPLE.UNDEFINED;
      var NULL = MT.SIMPLE_FLOAT << 5 | SIMPLE.NULL;
      var BREAK = Buffer3.from([255]);
      var BUF_NAN = Buffer3.from("f97e00", "hex");
      var BUF_INF_NEG = Buffer3.from("f9fc00", "hex");
      var BUF_INF_POS = Buffer3.from("f97c00", "hex");
      var BUF_NEG_ZERO = Buffer3.from("f98000", "hex");
      var SEMANTIC_TYPES = {};
      var current_SEMANTIC_TYPES = {};
      function parseDateType(str) {
        if (!str) {
          return "number";
        }
        switch (str.toLowerCase()) {
          case "number":
            return "number";
          case "float":
            return "float";
          case "int":
          case "integer":
            return "int";
          case "string":
            return "string";
        }
        throw new TypeError(`dateType invalid, got "${str}"`);
      }
      var Encoder = class _Encoder extends stream.Transform {
        /**
         * Creates an instance of Encoder.
         *
         * @param {EncodingOptions} [options={}] Options for the encoder.
         */
        constructor(options = {}) {
          const {
            canonical = false,
            encodeUndefined,
            disallowUndefinedKeys = false,
            dateType = "number",
            collapseBigIntegers = false,
            detectLoops = false,
            omitUndefinedProperties = false,
            genTypes = [],
            ...superOpts
          } = options;
          super({
            ...superOpts,
            readableObjectMode: false,
            writableObjectMode: true
          });
          this.canonical = canonical;
          this.encodeUndefined = encodeUndefined;
          this.disallowUndefinedKeys = disallowUndefinedKeys;
          this.dateType = parseDateType(dateType);
          this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers;
          this.detectLoops = void 0;
          if (typeof detectLoops === "boolean") {
            if (detectLoops) {
              this.detectLoops = /* @__PURE__ */ new WeakSet();
            }
          } else if (detectLoops instanceof WeakSet) {
            this.detectLoops = detectLoops;
          } else {
            throw new TypeError("detectLoops must be boolean or WeakSet");
          }
          this.omitUndefinedProperties = omitUndefinedProperties;
          this.semanticTypes = { ..._Encoder.SEMANTIC_TYPES };
          if (Array.isArray(genTypes)) {
            for (let i5 = 0, len = genTypes.length; i5 < len; i5 += 2) {
              this.addSemanticType(genTypes[i5], genTypes[i5 + 1]);
            }
          } else {
            for (const [k3, v5] of Object.entries(genTypes)) {
              this.addSemanticType(k3, v5);
            }
          }
        }
        _transform(fresh, encoding, cb) {
          const ret = this.pushAny(fresh);
          return cb(ret === false ? new Error("Push Error") : void 0);
        }
        // eslint-disable-next-line class-methods-use-this
        _flush(cb) {
          return cb();
        }
        /**
         * @param {number} val Number(0-255) to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushUInt8(val) {
          const b4 = Buffer3.allocUnsafe(1);
          b4.writeUInt8(val, 0);
          return this.push(b4);
        }
        /**
         * @param {number} val Number(0-65535) to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushUInt16BE(val) {
          const b4 = Buffer3.allocUnsafe(2);
          b4.writeUInt16BE(val, 0);
          return this.push(b4);
        }
        /**
         * @param {number} val Number(0..2**32-1) to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushUInt32BE(val) {
          const b4 = Buffer3.allocUnsafe(4);
          b4.writeUInt32BE(val, 0);
          return this.push(b4);
        }
        /**
         * @param {number} val Number to encode as 4-byte float.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushFloatBE(val) {
          const b4 = Buffer3.allocUnsafe(4);
          b4.writeFloatBE(val, 0);
          return this.push(b4);
        }
        /**
         * @param {number} val Number to encode as 8-byte double.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushDoubleBE(val) {
          const b4 = Buffer3.allocUnsafe(8);
          b4.writeDoubleBE(val, 0);
          return this.push(b4);
        }
        /**
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushNaN() {
          return this.push(BUF_NAN);
        }
        /**
         * @param {number} obj Positive or negative infinity.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushInfinity(obj) {
          const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
          return this.push(half);
        }
        /**
         * Choose the best float representation for a number and encode it.
         *
         * @param {number} obj A number that is known to be not-integer, but not
         *    how many bytes of precision it needs.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushFloat(obj) {
          if (this.canonical) {
            const b22 = Buffer3.allocUnsafe(2);
            if (utils.writeHalf(b22, obj)) {
              return this._pushUInt8(HALF) && this.push(b22);
            }
          }
          if (Math.fround(obj) === obj) {
            return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);
          }
          return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
        }
        /**
         * Choose the best integer representation for a postive number and encode
         * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I
         * don't remember why).
         *
         * @param {number} obj A positive number that is known to be an integer,
         *    but not how many bytes of precision it needs.
         * @param {number} mt The Major Type number to combine with the integer.
         *    Not yet shifted.
         * @param {number} [orig] The number before it was transformed to positive.
         *    If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,
         *    then we'll encode this as a float rather than making the number
         *    negative again and losing precision.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushInt(obj, mt, orig) {
          const m4 = mt << 5;
          if (obj < 24) {
            return this._pushUInt8(m4 | obj);
          }
          if (obj <= 255) {
            return this._pushUInt8(m4 | NUMBYTES.ONE) && this._pushUInt8(obj);
          }
          if (obj <= 65535) {
            return this._pushUInt8(m4 | NUMBYTES.TWO) && this._pushUInt16BE(obj);
          }
          if (obj <= 4294967295) {
            return this._pushUInt8(m4 | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
          }
          let max = Number.MAX_SAFE_INTEGER;
          if (mt === MT.NEG_INT) {
            max--;
          }
          if (obj <= max) {
            return this._pushUInt8(m4 | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
          }
          if (mt === MT.NEG_INT) {
            return this._pushFloat(orig);
          }
          return this._pushFloat(obj);
        }
        /**
         * Choose the best integer representation for a number and encode it.
         *
         * @param {number} obj A number that is known to be an integer,
         *    but not how many bytes of precision it needs.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushIntNum(obj) {
          if (Object.is(obj, -0)) {
            return this.push(BUF_NEG_ZERO);
          }
          if (obj < 0) {
            return this._pushInt(-obj - 1, MT.NEG_INT, obj);
          }
          return this._pushInt(obj, MT.POS_INT);
        }
        /**
         * @param {number} obj Plain JS number to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushNumber(obj) {
          if (isNaN(obj)) {
            return this._pushNaN();
          }
          if (!isFinite(obj)) {
            return this._pushInfinity(obj);
          }
          if (Math.round(obj) === obj) {
            return this._pushIntNum(obj);
          }
          return this._pushFloat(obj);
        }
        /**
         * @param {string} obj String to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushString(obj) {
          const len = Buffer3.byteLength(obj, "utf8");
          return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, "utf8");
        }
        /**
         * @param {boolean} obj Bool to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushBoolean(obj) {
          return this._pushUInt8(obj ? TRUE : FALSE);
        }
        /**
         * @param {undefined} obj Ignored.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushUndefined(obj) {
          switch (typeof this.encodeUndefined) {
            case "undefined":
              return this._pushUInt8(UNDEFINED);
            case "function":
              return this.pushAny(this.encodeUndefined(obj));
            case "object": {
              const buf = utils.bufferishToBuffer(this.encodeUndefined);
              if (buf) {
                return this.push(buf);
              }
            }
          }
          return this.pushAny(this.encodeUndefined);
        }
        /**
         * @param {null} obj Ignored.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushNull(obj) {
          return this._pushUInt8(NULL);
        }
        /**
         * @param {number} tag Tag number to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushTag(tag) {
          return this._pushInt(tag, MT.TAG);
        }
        /**
         * @param {bigint} obj BigInt to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        _pushJSBigint(obj) {
          let m4 = MT.POS_INT;
          let tag = TAG.POS_BIGINT;
          if (obj < 0) {
            obj = -obj + BI.MINUS_ONE;
            m4 = MT.NEG_INT;
            tag = TAG.NEG_BIGINT;
          }
          if (this.collapseBigIntegers && obj <= BI.MAXINT64) {
            if (obj <= 4294967295) {
              return this._pushInt(Number(obj), m4);
            }
            return this._pushUInt8(m4 << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(Number(obj / BI.SHIFT32)) && this._pushUInt32BE(Number(obj % BI.SHIFT32));
          }
          let str = obj.toString(16);
          if (str.length % 2) {
            str = `0${str}`;
          }
          const buf = Buffer3.from(str, "hex");
          return this._pushTag(tag) && _Encoder._pushBuffer(this, buf);
        }
        /**
         * @param {object} obj Object to encode.
         * @returns {boolean} True on success.
         * @throws {Error} Loop detected.
         * @ignore
         */
        _pushObject(obj, opts) {
          if (!obj) {
            return this._pushNull(obj);
          }
          opts = {
            indefinite: false,
            skipTypes: false,
            ...opts
          };
          if (!opts.indefinite) {
            if (this.detectLoops) {
              if (this.detectLoops.has(obj)) {
                throw new Error(`Loop detected while CBOR encoding.
Call removeLoopDetectors before resuming.`);
              } else {
                this.detectLoops.add(obj);
              }
            }
          }
          if (!opts.skipTypes) {
            const f5 = obj.encodeCBOR;
            if (typeof f5 === "function") {
              return f5.call(obj, this);
            }
            const converter = this.semanticTypes[obj.constructor.name];
            if (converter) {
              return converter.call(obj, this, obj);
            }
          }
          const keys = Object.keys(obj).filter((k3) => {
            const tv = typeof obj[k3];
            return tv !== "function" && (!this.omitUndefinedProperties || tv !== "undefined");
          });
          const cbor_keys = {};
          if (this.canonical) {
            keys.sort((a5, b4) => {
              const a_cbor = cbor_keys[a5] || (cbor_keys[a5] = _Encoder.encode(a5));
              const b_cbor = cbor_keys[b4] || (cbor_keys[b4] = _Encoder.encode(b4));
              return a_cbor.compare(b_cbor);
            });
          }
          if (opts.indefinite) {
            if (!this._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {
              return false;
            }
          } else if (!this._pushInt(keys.length, MT.MAP)) {
            return false;
          }
          let ck = null;
          for (let j3 = 0, len2 = keys.length; j3 < len2; j3++) {
            const k3 = keys[j3];
            if (this.canonical && (ck = cbor_keys[k3])) {
              if (!this.push(ck)) {
                return false;
              }
            } else if (!this._pushString(k3)) {
              return false;
            }
            if (!this.pushAny(obj[k3])) {
              return false;
            }
          }
          if (opts.indefinite) {
            if (!this.push(BREAK)) {
              return false;
            }
          } else if (this.detectLoops) {
            this.detectLoops.delete(obj);
          }
          return true;
        }
        /**
         * @param {any[]} objs Array of supported things.
         * @returns {Buffer} Concatenation of encodings for the supported things.
         * @ignore
         */
        _encodeAll(objs) {
          const bs = new NoFilter({ highWaterMark: this.readableHighWaterMark });
          this.pipe(bs);
          for (const o5 of objs) {
            this.pushAny(o5);
          }
          this.end();
          return bs.read();
        }
        /**
         * Add an encoding function to the list of supported semantic types.  This
         * is useful for objects for which you can't add an encodeCBOR method.
         *
         * @param {string|Function} type The type to encode.
         * @param {EncodeFunction} fun The encoder to use.
         * @returns {EncodeFunction?} The previous encoder or undefined if there
         *   wasn't one.
         * @throws {TypeError} Invalid function.
         */
        addSemanticType(type2, fun) {
          const typeName = typeof type2 === "string" ? type2 : type2.name;
          const old = this.semanticTypes[typeName];
          if (fun) {
            if (typeof fun !== "function") {
              throw new TypeError("fun must be of type function");
            }
            this.semanticTypes[typeName] = fun;
          } else if (old) {
            delete this.semanticTypes[typeName];
          }
          return old;
        }
        /**
         * Push any supported type onto the encoded stream.
         *
         * @param {any} obj The thing to encode.
         * @returns {boolean} True on success.
         * @throws {TypeError} Unknown type for obj.
         */
        pushAny(obj) {
          switch (typeof obj) {
            case "number":
              return this._pushNumber(obj);
            case "bigint":
              return this._pushJSBigint(obj);
            case "string":
              return this._pushString(obj);
            case "boolean":
              return this._pushBoolean(obj);
            case "undefined":
              return this._pushUndefined(obj);
            case "object":
              return this._pushObject(obj);
            case "symbol":
              switch (obj) {
                case SYMS.NULL:
                  return this._pushNull(null);
                case SYMS.UNDEFINED:
                  return this._pushUndefined(void 0);
                // TODO: Add pluggable support for other symbols
                default:
                  throw new TypeError(`Unknown symbol: ${obj.toString()}`);
              }
            default:
              throw new TypeError(
                `Unknown type: ${typeof obj}, ${typeof obj.toString === "function" ? obj.toString() : ""}`
              );
          }
        }
        /**
         * Encode an array and all of its elements.
         *
         * @param {Encoder} gen Encoder to use.
         * @param {any[]} obj Array to encode.
         * @param {object} [opts] Options.
         * @param {boolean} [opts.indefinite=false] Use indefinite encoding?
         * @returns {boolean} True on success.
         */
        static pushArray(gen, obj, opts) {
          opts = {
            indefinite: false,
            ...opts
          };
          const len = obj.length;
          if (opts.indefinite) {
            if (!gen._pushUInt8(MT.ARRAY << 5 | NUMBYTES.INDEFINITE)) {
              return false;
            }
          } else if (!gen._pushInt(len, MT.ARRAY)) {
            return false;
          }
          for (let j3 = 0; j3 < len; j3++) {
            if (!gen.pushAny(obj[j3])) {
              return false;
            }
          }
          if (opts.indefinite) {
            if (!gen.push(BREAK)) {
              return false;
            }
          }
          return true;
        }
        /**
         * Remove the loop detector WeakSet for this Encoder.
         *
         * @returns {boolean} True when the Encoder was reset, else false.
         */
        removeLoopDetectors() {
          if (!this.detectLoops) {
            return false;
          }
          this.detectLoops = /* @__PURE__ */ new WeakSet();
          return true;
        }
        /**
         * @param {Encoder} gen Encoder.
         * @param {Date} obj Date to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        static _pushDate(gen, obj) {
          switch (gen.dateType) {
            case "string":
              return gen._pushTag(TAG.DATE_STRING) && gen._pushString(obj.toISOString());
            case "int":
              return gen._pushTag(TAG.DATE_EPOCH) && gen._pushIntNum(Math.round(obj.getTime() / 1e3));
            case "float":
              return gen._pushTag(TAG.DATE_EPOCH) && gen._pushFloat(obj.getTime() / 1e3);
            case "number":
            default:
              return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj.getTime() / 1e3);
          }
        }
        /**
         * @param {Encoder} gen Encoder.
         * @param {Buffer} obj Buffer to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        static _pushBuffer(gen, obj) {
          return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
        }
        /**
         * @param {Encoder} gen Encoder.
         * @param {NoFilter} obj Buffer to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        static _pushNoFilter(gen, obj) {
          return _Encoder._pushBuffer(
            gen,
            /** @type {Buffer} */
            obj.slice()
          );
        }
        /**
         * @param {Encoder} gen Encoder.
         * @param {RegExp} obj RegExp to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        static _pushRegexp(gen, obj) {
          return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
        }
        /**
         * @param {Encoder} gen Encoder.
         * @param {Set} obj Set to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        static _pushSet(gen, obj) {
          if (!gen._pushTag(TAG.SET)) {
            return false;
          }
          if (!gen._pushInt(obj.size, MT.ARRAY)) {
            return false;
          }
          for (const x3 of obj) {
            if (!gen.pushAny(x3)) {
              return false;
            }
          }
          return true;
        }
        /**
         * @param {Encoder} gen Encoder.
         * @param {URL} obj URL to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        static _pushURL(gen, obj) {
          return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());
        }
        /**
         * @param {Encoder} gen Encoder.
         * @param {object} obj Boxed String, Number, or Boolean object to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        static _pushBoxed(gen, obj) {
          return gen.pushAny(obj.valueOf());
        }
        /**
         * @param {Encoder} gen Encoder.
         * @param {Map} obj Map to encode.
         * @returns {boolean} True on success.
         * @throws {Error} Map key that is undefined.
         * @ignore
         */
        static _pushMap(gen, obj, opts) {
          opts = {
            indefinite: false,
            ...opts
          };
          let entries = [...obj.entries()];
          if (gen.omitUndefinedProperties) {
            entries = entries.filter(([k3, v5]) => v5 !== void 0);
          }
          if (opts.indefinite) {
            if (!gen._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {
              return false;
            }
          } else if (!gen._pushInt(entries.length, MT.MAP)) {
            return false;
          }
          if (gen.canonical) {
            const enc = new _Encoder({
              genTypes: gen.semanticTypes,
              canonical: gen.canonical,
              detectLoops: Boolean(gen.detectLoops),
              // Give enc its own loop detector
              dateType: gen.dateType,
              disallowUndefinedKeys: gen.disallowUndefinedKeys,
              collapseBigIntegers: gen.collapseBigIntegers
            });
            const bs = new NoFilter({ highWaterMark: gen.readableHighWaterMark });
            enc.pipe(bs);
            entries.sort(([a5], [b4]) => {
              enc.pushAny(a5);
              const a_cbor = bs.read();
              enc.pushAny(b4);
              const b_cbor = bs.read();
              return a_cbor.compare(b_cbor);
            });
            for (const [k3, v5] of entries) {
              if (gen.disallowUndefinedKeys && typeof k3 === "undefined") {
                throw new Error("Invalid Map key: undefined");
              }
              if (!(gen.pushAny(k3) && gen.pushAny(v5))) {
                return false;
              }
            }
          } else {
            for (const [k3, v5] of entries) {
              if (gen.disallowUndefinedKeys && typeof k3 === "undefined") {
                throw new Error("Invalid Map key: undefined");
              }
              if (!(gen.pushAny(k3) && gen.pushAny(v5))) {
                return false;
              }
            }
          }
          if (opts.indefinite) {
            if (!gen.push(BREAK)) {
              return false;
            }
          }
          return true;
        }
        /**
         * @param {Encoder} gen Encoder.
         * @param {NodeJS.TypedArray} obj Array to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        static _pushTypedArray(gen, obj) {
          let typ = 64;
          let sz = obj.BYTES_PER_ELEMENT;
          const { name: name2 } = obj.constructor;
          if (name2.startsWith("Float")) {
            typ |= 16;
            sz /= 2;
          } else if (!name2.includes("U")) {
            typ |= 8;
          }
          if (name2.includes("Clamped") || sz !== 1 && !utils.isBigEndian()) {
            typ |= 4;
          }
          typ |= {
            1: 0,
            2: 1,
            4: 2,
            8: 3
          }[sz];
          if (!gen._pushTag(typ)) {
            return false;
          }
          return _Encoder._pushBuffer(
            gen,
            Buffer3.from(obj.buffer, obj.byteOffset, obj.byteLength)
          );
        }
        /**
         * @param {Encoder} gen Encoder.
         * @param { ArrayBuffer } obj Array to encode.
         * @returns {boolean} True on success.
         * @ignore
         */
        static _pushArrayBuffer(gen, obj) {
          return _Encoder._pushBuffer(gen, Buffer3.from(obj));
        }
        /**
         * Encode the given object with indefinite length.  There are apparently
         * some (IMO) broken implementations of poorly-specified protocols that
         * REQUIRE indefinite-encoding.  See the example for how to add this as an
         * `encodeCBOR` function to an object or class to get indefinite encoding.
         *
         * @param {Encoder} gen The encoder to use.
         * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If
         *   null, use "this" instead.
         * @param {EncodingOptions} [options={}] Options for encoding.
         * @returns {boolean} True on success.
         * @throws {Error} No object to encode or invalid indefinite encoding.
         * @example <caption>Force indefinite encoding:</caption>
         * const o = {
         *   a: true,
         *   encodeCBOR: cbor.Encoder.encodeIndefinite,
         * }
         * const m = []
         * m.encodeCBOR = cbor.Encoder.encodeIndefinite
         * cbor.encodeOne([o, m])
         */
        static encodeIndefinite(gen, obj, options = {}) {
          if (obj == null) {
            if (this == null) {
              throw new Error("No object to encode");
            }
            obj = this;
          }
          const { chunkSize = 4096 } = options;
          let ret = true;
          const objType = typeof obj;
          let buf = null;
          if (objType === "string") {
            ret = ret && gen._pushUInt8(MT.UTF8_STRING << 5 | NUMBYTES.INDEFINITE);
            let offset = 0;
            while (offset < obj.length) {
              const endIndex = offset + chunkSize;
              ret = ret && gen._pushString(obj.slice(offset, endIndex));
              offset = endIndex;
            }
            ret = ret && gen.push(BREAK);
          } else if (buf = utils.bufferishToBuffer(obj)) {
            ret = ret && gen._pushUInt8(MT.BYTE_STRING << 5 | NUMBYTES.INDEFINITE);
            let offset = 0;
            while (offset < buf.length) {
              const endIndex = offset + chunkSize;
              ret = ret && _Encoder._pushBuffer(gen, buf.slice(offset, endIndex));
              offset = endIndex;
            }
            ret = ret && gen.push(BREAK);
          } else if (Array.isArray(obj)) {
            ret = ret && _Encoder.pushArray(gen, obj, {
              indefinite: true
            });
          } else if (obj instanceof Map) {
            ret = ret && _Encoder._pushMap(gen, obj, {
              indefinite: true
            });
          } else {
            if (objType !== "object") {
              throw new Error("Invalid indefinite encoding");
            }
            ret = ret && gen._pushObject(obj, {
              indefinite: true,
              skipTypes: true
            });
          }
          return ret;
        }
        /**
         * Encode one or more JavaScript objects, and return a Buffer containing the
         * CBOR bytes.
         *
         * @param {...any} objs The objects to encode.
         * @returns {Buffer} The encoded objects.
         */
        static encode(...objs) {
          return new _Encoder()._encodeAll(objs);
        }
        /**
         * Encode one or more JavaScript objects canonically (slower!), and return
         * a Buffer containing the CBOR bytes.
         *
         * @param {...any} objs The objects to encode.
         * @returns {Buffer} The encoded objects.
         */
        static encodeCanonical(...objs) {
          return new _Encoder({
            canonical: true
          })._encodeAll(objs);
        }
        /**
         * Encode one JavaScript object using the given options.
         *
         * @static
         * @param {any} obj The object to encode.
         * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.
         * @returns {Buffer} The encoded objects.
         */
        static encodeOne(obj, options) {
          return new _Encoder(options)._encodeAll([obj]);
        }
        /**
         * Encode one JavaScript object using the given options in a way that
         * is more resilient to objects being larger than the highWaterMark
         * number of bytes.  As with the other static encode functions, this
         * will still use a large amount of memory.  Use a stream-based approach
         * directly if you need to process large and complicated inputs.
         *
         * @param {any} obj The object to encode.
         * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.
         * @returns {Promise<Buffer>} A promise for the encoded buffer.
         */
        static encodeAsync(obj, options) {
          return new Promise((resolve2, reject) => {
            const bufs = [];
            const enc = new _Encoder(options);
            enc.on("data", (buf) => bufs.push(buf));
            enc.on("error", reject);
            enc.on("finish", () => resolve2(Buffer3.concat(bufs)));
            enc.pushAny(obj);
            enc.end();
          });
        }
        /**
         * The currently supported set of semantic types.  May be modified by plugins.
         *
         * @type {SemanticMap}
         */
        static get SEMANTIC_TYPES() {
          return current_SEMANTIC_TYPES;
        }
        static set SEMANTIC_TYPES(val) {
          current_SEMANTIC_TYPES = val;
        }
        /**
         * Reset the supported semantic types to the original set, before any
         * plugins modified the list.
         */
        static reset() {
          _Encoder.SEMANTIC_TYPES = { ...SEMANTIC_TYPES };
        }
      };
      Object.assign(SEMANTIC_TYPES, {
        Array: Encoder.pushArray,
        Date: Encoder._pushDate,
        Buffer: Encoder._pushBuffer,
        [Buffer3.name]: Encoder._pushBuffer,
        // Might be mangled
        Map: Encoder._pushMap,
        NoFilter: Encoder._pushNoFilter,
        [NoFilter.name]: Encoder._pushNoFilter,
        // Might be mangled
        RegExp: Encoder._pushRegexp,
        Set: Encoder._pushSet,
        ArrayBuffer: Encoder._pushArrayBuffer,
        Uint8ClampedArray: Encoder._pushTypedArray,
        Uint8Array: Encoder._pushTypedArray,
        Uint16Array: Encoder._pushTypedArray,
        Uint32Array: Encoder._pushTypedArray,
        Int8Array: Encoder._pushTypedArray,
        Int16Array: Encoder._pushTypedArray,
        Int32Array: Encoder._pushTypedArray,
        Float32Array: Encoder._pushTypedArray,
        Float64Array: Encoder._pushTypedArray,
        URL: Encoder._pushURL,
        Boolean: Encoder._pushBoxed,
        Number: Encoder._pushBoxed,
        String: Encoder._pushBoxed
      });
      if (typeof BigUint64Array !== "undefined") {
        SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray;
      }
      if (typeof BigInt64Array !== "undefined") {
        SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray;
      }
      Encoder.reset();
      module.exports = Encoder;
    }
  });

  // ../../node_modules/cbor/lib/map.js
  var require_map = __commonJS({
    "../../node_modules/cbor/lib/map.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var encoder = require_encoder();
      var decoder = require_decoder();
      var { MT } = require_constants();
      var CborMap = class _CborMap extends Map {
        /**
         * Creates an instance of CborMap.
         *
         * @param {Iterable<any>} [iterable] An Array or other iterable
         *   object whose elements are key-value pairs (arrays with two elements, e.g.
         *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added
         *   to the new CborMap; null values are treated as undefined.
         */
        constructor(iterable) {
          super(iterable);
        }
        /**
         * @ignore
         */
        static _encode(key) {
          return encoder.encodeCanonical(key).toString("base64");
        }
        /**
         * @ignore
         */
        static _decode(key) {
          return decoder.decodeFirstSync(key, "base64");
        }
        /**
         * Retrieve a specified element.
         *
         * @param {any} key The key identifying the element to retrieve.
         *   Can be any type, which will be serialized into CBOR and compared by
         *   value.
         * @returns {any} The element if it exists, or <code>undefined</code>.
         */
        get(key) {
          return super.get(_CborMap._encode(key));
        }
        /**
         * Adds or updates an element with a specified key and value.
         *
         * @param {any} key The key identifying the element to store.
         *   Can be any type, which will be serialized into CBOR and compared by
         *   value.
         * @param {any} val The element to store.
         * @returns {this} This object.
         */
        set(key, val) {
          return super.set(_CborMap._encode(key), val);
        }
        /**
         * Removes the specified element.
         *
         * @param {any} key The key identifying the element to delete. Can be any
         *   type, which will be serialized into CBOR and compared by value.
         * @returns {boolean} True if an element in the Map object existed and has
         *   been removed, or false if the element does not exist.
         */
        delete(key) {
          return super.delete(_CborMap._encode(key));
        }
        /**
         * Does an element with the specified key exist?
         *
         * @param {any} key The key identifying the element to check.
         *   Can be any type, which will be serialized into CBOR and compared by
         *   value.
         * @returns {boolean} True if an element with the specified key exists in
         *   the Map object; otherwise false.
         */
        has(key) {
          return super.has(_CborMap._encode(key));
        }
        /**
         * Returns a new Iterator object that contains the keys for each element
         * in the Map object in insertion order.  The keys are decoded into their
         * original format.
         *
         * @yields {any} The keys of the map.
         */
        *keys() {
          for (const k3 of super.keys()) {
            yield _CborMap._decode(k3);
          }
        }
        /* eslint-disable jsdoc/require-returns-check */
        /**
         * Returns a new Iterator object that contains the [key, value] pairs for
         * each element in the Map object in insertion order.
         *
         * @yields {any[]} Key value pairs.
         * @returns {IterableIterator<any, any>} Key value pairs.
         */
        *entries() {
          for (const kv of super.entries()) {
            yield [_CborMap._decode(kv[0]), kv[1]];
          }
        }
        /* eslint-enable jsdoc/require-returns-check */
        /**
         * Returns a new Iterator object that contains the [key, value] pairs for
         * each element in the Map object in insertion order.
         *
         * @returns {IterableIterator} Key value pairs.
         */
        [Symbol.iterator]() {
          return this.entries();
        }
        /**
         * Executes a provided function once per each key/value pair in the Map
         * object, in insertion order.
         *
         * @param {function(any, any, Map): undefined} fun Function to execute for
         *  each element, which takes a value, a key, and the Map being traversed.
         * @param {any} thisArg Value to use as this when executing callback.
         * @throws {TypeError} Invalid function.
         */
        forEach(fun, thisArg) {
          if (typeof fun !== "function") {
            throw new TypeError("Must be function");
          }
          for (const kv of super.entries()) {
            fun.call(this, kv[1], _CborMap._decode(kv[0]), this);
          }
        }
        /**
         * Push the simple value onto the CBOR stream.
         *
         * @param {object} gen The generator to push onto.
         * @returns {boolean} True on success.
         */
        encodeCBOR(gen) {
          if (!gen._pushInt(this.size, MT.MAP)) {
            return false;
          }
          if (gen.canonical) {
            const entries = Array.from(super.entries()).map((kv) => [Buffer3.from(kv[0], "base64"), kv[1]]);
            entries.sort((a5, b4) => a5[0].compare(b4[0]));
            for (const kv of entries) {
              if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {
                return false;
              }
            }
          } else {
            for (const kv of super.entries()) {
              if (!(gen.push(Buffer3.from(kv[0], "base64")) && gen.pushAny(kv[1]))) {
                return false;
              }
            }
          }
          return true;
        }
      };
      module.exports = CborMap;
    }
  });

  // ../../node_modules/cbor/lib/cbor.js
  var require_cbor = __commonJS({
    "../../node_modules/cbor/lib/cbor.js"(exports21) {
      "use strict";
      init_buffer2();
      exports21.Commented = require_commented();
      exports21.Diagnose = require_diagnose();
      exports21.Decoder = require_decoder();
      exports21.Encoder = require_encoder();
      exports21.Simple = require_simple();
      exports21.Tagged = require_tagged();
      exports21.Map = require_map();
      exports21.comment = exports21.Commented.comment;
      exports21.decodeAll = exports21.Decoder.decodeAll;
      exports21.decodeFirst = exports21.Decoder.decodeFirst;
      exports21.decodeAllSync = exports21.Decoder.decodeAllSync;
      exports21.decodeFirstSync = exports21.Decoder.decodeFirstSync;
      exports21.diagnose = exports21.Diagnose.diagnose;
      exports21.encode = exports21.Encoder.encode;
      exports21.encodeCanonical = exports21.Encoder.encodeCanonical;
      exports21.encodeOne = exports21.Encoder.encodeOne;
      exports21.encodeAsync = exports21.Encoder.encodeAsync;
      exports21.decode = exports21.Decoder.decodeFirstSync;
      exports21.leveldb = {
        decode: exports21.Decoder.decodeFirstSync,
        encode: exports21.Encoder.encode,
        buffer: true,
        name: "cbor"
      };
      exports21.reset = function reset() {
        exports21.Encoder.reset();
        exports21.Tagged.reset();
      };
    }
  });

  // ../core/dist/codecs/cbor-codec.js
  var require_cbor_codec = __commonJS({
    "../core/dist/codecs/cbor-codec.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var logger_1 = require_logger();
      var cbor_1 = require_cbor();
      var { debug } = (0, logger_1.createLoggers)("core", "cbor-codec");
      var CborCodec = class {
        constructor(subMediaType) {
          this.subMediaType = subMediaType ?? "application/cbor";
        }
        getMediaType() {
          return this.subMediaType;
        }
        bytesToValue(bytes, schema, parameters) {
          debug(`CborCodec parsing '${bytes.toString()}'`);
          try {
            return (0, cbor_1.decode)(bytes);
          } catch (err) {
            if (bytes.byteLength === 0) {
              return null;
            }
            throw err;
          }
        }
        valueToBytes(value, schema, parameters) {
          debug("CborCodec serializing", value);
          if (value === void 0) {
            return Buffer2.alloc(0);
          }
          return (0, cbor_1.encode)(value);
        }
      };
      exports21.default = CborCodec;
    }
  });

  // ../core/dist/codecs/json-codec.js
  var require_json_codec = __commonJS({
    "../core/dist/codecs/json-codec.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var content_serdes_1 = require_content_serdes();
      var logger_1 = require_logger();
      var { debug } = (0, logger_1.createLoggers)("core", "json-codec");
      var JsonCodec = class {
        constructor(subMediaType) {
          this.subMediaType = subMediaType ?? content_serdes_1.ContentSerdes.DEFAULT;
        }
        getMediaType() {
          return this.subMediaType;
        }
        bytesToValue(bytes, schema, parameters) {
          debug(`JsonCodec parsing '${bytes.toString()}'`);
          let parsed;
          try {
            parsed = JSON.parse(bytes.toString());
          } catch (err) {
            if (err instanceof SyntaxError) {
              if (bytes.byteLength === 0) {
                parsed = void 0;
              } else {
                parsed = bytes.toString();
              }
            } else {
              throw err;
            }
          }
          return parsed;
        }
        valueToBytes(value, schema, parameters) {
          debug("JsonCodec serializing", value);
          let body = "";
          if (value !== void 0) {
            body = JSON.stringify(value);
          }
          return Buffer2.from(body);
        }
      };
      exports21.default = JsonCodec;
    }
  });

  // ../core/dist/codecs/text-codec.js
  var require_text_codec = __commonJS({
    "../core/dist/codecs/text-codec.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var logger_1 = require_logger();
      var { debug } = (0, logger_1.createLoggers)("core", "text-codec");
      var TextCodec = class {
        constructor(subMediaType) {
          this.subMediaType = subMediaType ?? "text/plain";
        }
        getMediaType() {
          return this.subMediaType;
        }
        bytesToValue(bytes, schema, parameters) {
          debug(`TextCodec parsing '${bytes.toString()}'`);
          const parsed = bytes.toString(parameters?.charset);
          return parsed;
        }
        valueToBytes(value, schema, parameters) {
          debug(`TextCodec serializing '${value}'`);
          let body = "";
          if (value !== void 0) {
            if (typeof value === "string") {
              body = value;
            } else {
              body = JSON.stringify(value);
            }
          }
          let be2;
          if (parameters && parameters.charset) {
            switch (parameters.charset) {
              case "ascii":
                be2 = "ascii";
                break;
              case "utf8":
                be2 = "utf8";
                break;
              case "utf-8":
                be2 = "utf-8";
                break;
              case "utf16le":
                be2 = "utf16le";
                break;
              case "ucs2":
                be2 = "ucs2";
                break;
              case "ucs-2":
                be2 = "ucs-2";
                break;
              case "base64":
                be2 = "base64";
                break;
              case "latin1":
                be2 = "latin1";
                break;
              case "binary":
                be2 = "binary";
                break;
              case "hex":
                be2 = "hex";
                break;
            }
          }
          const buff = Buffer2.alloc(body.length);
          buff.write(body, be2);
          return buff;
        }
      };
      exports21.default = TextCodec;
    }
  });

  // ../core/dist/codecs/base64-codec.js
  var require_base64_codec = __commonJS({
    "../core/dist/codecs/base64-codec.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var Base64Codec = class {
        constructor(subMediaType) {
          this.subMediaType = subMediaType;
        }
        getMediaType() {
          return this.subMediaType;
        }
        bytesToValue(bytes, schema, parameters) {
          const parsed = bytes.toString("ascii");
          return parsed;
        }
        valueToBytes(value, schema, parameters) {
          let body = "";
          if (value !== void 0) {
            body = JSON.stringify(value);
          }
          return Buffer2.from(body, "base64");
        }
      };
      exports21.default = Base64Codec;
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/_util/messages.cjs
  var require_messages = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/_util/messages.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      var THIS_IS_NOT_AN_OBJECT = exports21.THIS_IS_NOT_AN_OBJECT = "This is not an object";
      var THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = exports21.THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = "This is not a Float16Array object";
      var THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY = exports21.THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY = "This constructor is not a subclass of Float16Array";
      var THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT = exports21.THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT = "The constructor property value is not an object";
      var SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT = exports21.SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT = "Species constructor didn't return TypedArray object";
      var DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH = exports21.DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH = "Derived constructor created TypedArray object which was too small length";
      var ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER = exports21.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER = "Attempting to access detached ArrayBuffer";
      var CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT = exports21.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT = "Cannot convert undefined or null to object";
      var CANNOT_MIX_BIGINT_AND_OTHER_TYPES = exports21.CANNOT_MIX_BIGINT_AND_OTHER_TYPES = "Cannot mix BigInt and other types, use explicit conversions";
      var ITERATOR_PROPERTY_IS_NOT_CALLABLE = exports21.ITERATOR_PROPERTY_IS_NOT_CALLABLE = "@@iterator property is not callable";
      var REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE = exports21.REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE = "Reduce of empty array with no initial value";
      var THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED = exports21.THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED = "The comparison function must be either a function or undefined";
      var OFFSET_IS_OUT_OF_BOUNDS = exports21.OFFSET_IS_OUT_OF_BOUNDS = "Offset is out of bounds";
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/_util/primordials.cjs
  var require_primordials = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/_util/primordials.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      var _messages = require_messages();
      function uncurryThis(target) {
        return (thisArg, ...args) => {
          return ReflectApply(target, thisArg, args);
        };
      }
      function uncurryThisGetter(target, key) {
        return uncurryThis(ReflectGetOwnPropertyDescriptor(target, key).get);
      }
      var {
        apply: ReflectApply,
        construct: ReflectConstruct,
        defineProperty: ReflectDefineProperty,
        get: ReflectGet,
        getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,
        getPrototypeOf: ReflectGetPrototypeOf,
        has: ReflectHas,
        ownKeys: ReflectOwnKeys,
        set: ReflectSet,
        setPrototypeOf: ReflectSetPrototypeOf
      } = Reflect;
      exports21.ReflectSetPrototypeOf = ReflectSetPrototypeOf;
      exports21.ReflectSet = ReflectSet;
      exports21.ReflectOwnKeys = ReflectOwnKeys;
      exports21.ReflectHas = ReflectHas;
      exports21.ReflectGetPrototypeOf = ReflectGetPrototypeOf;
      exports21.ReflectGetOwnPropertyDescriptor = ReflectGetOwnPropertyDescriptor;
      exports21.ReflectGet = ReflectGet;
      exports21.ReflectDefineProperty = ReflectDefineProperty;
      exports21.ReflectConstruct = ReflectConstruct;
      exports21.ReflectApply = ReflectApply;
      var NativeProxy = exports21.NativeProxy = Proxy;
      var {
        EPSILON,
        MAX_SAFE_INTEGER,
        isFinite: NumberIsFinite,
        isNaN: NumberIsNaN
      } = Number;
      exports21.NumberIsNaN = NumberIsNaN;
      exports21.NumberIsFinite = NumberIsFinite;
      exports21.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
      exports21.EPSILON = EPSILON;
      var {
        iterator: SymbolIterator,
        species: SymbolSpecies,
        toStringTag: SymbolToStringTag,
        for: SymbolFor
      } = Symbol;
      exports21.SymbolFor = SymbolFor;
      exports21.SymbolToStringTag = SymbolToStringTag;
      exports21.SymbolSpecies = SymbolSpecies;
      exports21.SymbolIterator = SymbolIterator;
      var NativeObject = exports21.NativeObject = Object;
      var {
        create: ObjectCreate,
        defineProperty: ObjectDefineProperty,
        freeze: ObjectFreeze,
        is: ObjectIs
      } = NativeObject;
      exports21.ObjectIs = ObjectIs;
      exports21.ObjectFreeze = ObjectFreeze;
      exports21.ObjectDefineProperty = ObjectDefineProperty;
      exports21.ObjectCreate = ObjectCreate;
      var ObjectPrototype = NativeObject.prototype;
      var ObjectPrototype__lookupGetter__ = exports21.ObjectPrototype__lookupGetter__ = ObjectPrototype.__lookupGetter__ ? uncurryThis(ObjectPrototype.__lookupGetter__) : (object, key) => {
        if (object == null) {
          throw NativeTypeError(_messages.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);
        }
        let target = NativeObject(object);
        do {
          const descriptor = ReflectGetOwnPropertyDescriptor(target, key);
          if (descriptor !== void 0) {
            if (ObjectHasOwn(descriptor, "get")) {
              return descriptor.get;
            }
            return;
          }
        } while ((target = ReflectGetPrototypeOf(target)) !== null);
      };
      var ObjectHasOwn = exports21.ObjectHasOwn = NativeObject.hasOwn || uncurryThis(ObjectPrototype.hasOwnProperty);
      var NativeArray = Array;
      var ArrayIsArray = exports21.ArrayIsArray = NativeArray.isArray;
      var ArrayPrototype = NativeArray.prototype;
      var ArrayPrototypeJoin = exports21.ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);
      var ArrayPrototypePush = exports21.ArrayPrototypePush = uncurryThis(ArrayPrototype.push);
      var ArrayPrototypeToLocaleString = exports21.ArrayPrototypeToLocaleString = uncurryThis(ArrayPrototype.toLocaleString);
      var NativeArrayPrototypeSymbolIterator = exports21.NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];
      var ArrayPrototypeSymbolIterator = exports21.ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);
      var {
        abs: MathAbs,
        trunc: MathTrunc
      } = Math;
      exports21.MathTrunc = MathTrunc;
      exports21.MathAbs = MathAbs;
      var NativeArrayBuffer = exports21.NativeArrayBuffer = ArrayBuffer;
      var ArrayBufferIsView = exports21.ArrayBufferIsView = NativeArrayBuffer.isView;
      var ArrayBufferPrototype = NativeArrayBuffer.prototype;
      var ArrayBufferPrototypeSlice = exports21.ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);
      var ArrayBufferPrototypeGetByteLength = exports21.ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, "byteLength");
      var NativeSharedArrayBuffer = exports21.NativeSharedArrayBuffer = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : null;
      var SharedArrayBufferPrototypeGetByteLength = exports21.SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer && uncurryThisGetter(NativeSharedArrayBuffer.prototype, "byteLength");
      var TypedArray = exports21.TypedArray = ReflectGetPrototypeOf(Uint8Array);
      var TypedArrayFrom = TypedArray.from;
      var TypedArrayPrototype = exports21.TypedArrayPrototype = TypedArray.prototype;
      var NativeTypedArrayPrototypeSymbolIterator = exports21.NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];
      var TypedArrayPrototypeKeys = exports21.TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);
      var TypedArrayPrototypeValues = exports21.TypedArrayPrototypeValues = uncurryThis(TypedArrayPrototype.values);
      var TypedArrayPrototypeEntries = exports21.TypedArrayPrototypeEntries = uncurryThis(TypedArrayPrototype.entries);
      var TypedArrayPrototypeSet = exports21.TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);
      var TypedArrayPrototypeReverse = exports21.TypedArrayPrototypeReverse = uncurryThis(TypedArrayPrototype.reverse);
      var TypedArrayPrototypeFill = exports21.TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);
      var TypedArrayPrototypeCopyWithin = exports21.TypedArrayPrototypeCopyWithin = uncurryThis(TypedArrayPrototype.copyWithin);
      var TypedArrayPrototypeSort = exports21.TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);
      var TypedArrayPrototypeSlice = exports21.TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);
      var TypedArrayPrototypeSubarray = exports21.TypedArrayPrototypeSubarray = uncurryThis(TypedArrayPrototype.subarray);
      var TypedArrayPrototypeGetBuffer = exports21.TypedArrayPrototypeGetBuffer = uncurryThisGetter(TypedArrayPrototype, "buffer");
      var TypedArrayPrototypeGetByteOffset = exports21.TypedArrayPrototypeGetByteOffset = uncurryThisGetter(TypedArrayPrototype, "byteOffset");
      var TypedArrayPrototypeGetLength = exports21.TypedArrayPrototypeGetLength = uncurryThisGetter(TypedArrayPrototype, "length");
      var TypedArrayPrototypeGetSymbolToStringTag = exports21.TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(TypedArrayPrototype, SymbolToStringTag);
      var NativeUint8Array = exports21.NativeUint8Array = Uint8Array;
      var NativeUint16Array = exports21.NativeUint16Array = Uint16Array;
      var Uint16ArrayFrom = (...args) => {
        return ReflectApply(TypedArrayFrom, NativeUint16Array, args);
      };
      exports21.Uint16ArrayFrom = Uint16ArrayFrom;
      var NativeUint32Array = exports21.NativeUint32Array = Uint32Array;
      var NativeFloat32Array = exports21.NativeFloat32Array = Float32Array;
      var ArrayIteratorPrototype = exports21.ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());
      var ArrayIteratorPrototypeNext = exports21.ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);
      var GeneratorPrototypeNext = exports21.GeneratorPrototypeNext = uncurryThis(function* () {
      }().next);
      var IteratorPrototype = exports21.IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);
      var DataViewPrototype = DataView.prototype;
      var DataViewPrototypeGetUint16 = exports21.DataViewPrototypeGetUint16 = uncurryThis(DataViewPrototype.getUint16);
      var DataViewPrototypeSetUint16 = exports21.DataViewPrototypeSetUint16 = uncurryThis(DataViewPrototype.setUint16);
      var NativeTypeError = exports21.NativeTypeError = TypeError;
      var NativeRangeError = exports21.NativeRangeError = RangeError;
      var NativeWeakSet = exports21.NativeWeakSet = WeakSet;
      var WeakSetPrototype = NativeWeakSet.prototype;
      var WeakSetPrototypeAdd = exports21.WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);
      var WeakSetPrototypeHas = exports21.WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);
      var NativeWeakMap = exports21.NativeWeakMap = WeakMap;
      var WeakMapPrototype = NativeWeakMap.prototype;
      var WeakMapPrototypeGet = exports21.WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);
      var WeakMapPrototypeHas = exports21.WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);
      var WeakMapPrototypeSet = exports21.WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/_util/arrayIterator.cjs
  var require_arrayIterator = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/_util/arrayIterator.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.safeIfNeeded = safeIfNeeded;
      exports21.wrap = wrap;
      var _primordials = require_primordials();
      var arrayIterators = new _primordials.NativeWeakMap();
      var SafeIteratorPrototype = (0, _primordials.ObjectCreate)(null, {
        next: {
          value: function next() {
            const arrayIterator = (0, _primordials.WeakMapPrototypeGet)(arrayIterators, this);
            return (0, _primordials.ArrayIteratorPrototypeNext)(arrayIterator);
          }
        },
        [_primordials.SymbolIterator]: {
          value: function values() {
            return this;
          }
        }
      });
      function safeIfNeeded(array) {
        if (array[_primordials.SymbolIterator] === _primordials.NativeArrayPrototypeSymbolIterator && _primordials.ArrayIteratorPrototype.next === _primordials.ArrayIteratorPrototypeNext) {
          return array;
        }
        const safe = (0, _primordials.ObjectCreate)(SafeIteratorPrototype);
        (0, _primordials.WeakMapPrototypeSet)(arrayIterators, safe, (0, _primordials.ArrayPrototypeSymbolIterator)(array));
        return safe;
      }
      var generators = new _primordials.NativeWeakMap();
      var DummyArrayIteratorPrototype = (0, _primordials.ObjectCreate)(_primordials.IteratorPrototype, {
        next: {
          value: function next() {
            const generator = (0, _primordials.WeakMapPrototypeGet)(generators, this);
            return (0, _primordials.GeneratorPrototypeNext)(generator);
          },
          writable: true,
          configurable: true
        }
      });
      for (const key of (0, _primordials.ReflectOwnKeys)(_primordials.ArrayIteratorPrototype)) {
        if (key === "next") {
          continue;
        }
        (0, _primordials.ObjectDefineProperty)(DummyArrayIteratorPrototype, key, (0, _primordials.ReflectGetOwnPropertyDescriptor)(_primordials.ArrayIteratorPrototype, key));
      }
      function wrap(generator) {
        const dummy = (0, _primordials.ObjectCreate)(DummyArrayIteratorPrototype);
        (0, _primordials.WeakMapPrototypeSet)(generators, dummy, generator);
        return dummy;
      }
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/_util/is.cjs
  var require_is = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/_util/is.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.isAnyArrayBuffer = isAnyArrayBuffer;
      exports21.isCanonicalIntegerIndexString = isCanonicalIntegerIndexString;
      exports21.isNativeBigIntTypedArray = isNativeBigIntTypedArray;
      exports21.isNativeTypedArray = isNativeTypedArray;
      exports21.isObject = isObject2;
      exports21.isObjectLike = isObjectLike;
      exports21.isOrdinaryArray = isOrdinaryArray;
      exports21.isOrdinaryNativeTypedArray = isOrdinaryNativeTypedArray;
      exports21.isSharedArrayBuffer = isSharedArrayBuffer;
      var _primordials = require_primordials();
      function isObject2(value) {
        return value !== null && typeof value === "object" || typeof value === "function";
      }
      function isObjectLike(value) {
        return value !== null && typeof value === "object";
      }
      function isNativeTypedArray(value) {
        return (0, _primordials.TypedArrayPrototypeGetSymbolToStringTag)(value) !== void 0;
      }
      function isNativeBigIntTypedArray(value) {
        const typedArrayName = (0, _primordials.TypedArrayPrototypeGetSymbolToStringTag)(value);
        return typedArrayName === "BigInt64Array" || typedArrayName === "BigUint64Array";
      }
      function isArrayBuffer(value) {
        try {
          if ((0, _primordials.ArrayIsArray)(value)) {
            return false;
          }
          (0, _primordials.ArrayBufferPrototypeGetByteLength)(value);
          return true;
        } catch (e5) {
          return false;
        }
      }
      function isSharedArrayBuffer(value) {
        if (_primordials.NativeSharedArrayBuffer === null) {
          return false;
        }
        try {
          (0, _primordials.SharedArrayBufferPrototypeGetByteLength)(value);
          return true;
        } catch (e5) {
          return false;
        }
      }
      function isAnyArrayBuffer(value) {
        return isArrayBuffer(value) || isSharedArrayBuffer(value);
      }
      function isOrdinaryArray(value) {
        if (!(0, _primordials.ArrayIsArray)(value)) {
          return false;
        }
        return value[_primordials.SymbolIterator] === _primordials.NativeArrayPrototypeSymbolIterator && _primordials.ArrayIteratorPrototype.next === _primordials.ArrayIteratorPrototypeNext;
      }
      function isOrdinaryNativeTypedArray(value) {
        if (!isNativeTypedArray(value)) {
          return false;
        }
        return value[_primordials.SymbolIterator] === _primordials.NativeTypedArrayPrototypeSymbolIterator && _primordials.ArrayIteratorPrototype.next === _primordials.ArrayIteratorPrototypeNext;
      }
      function isCanonicalIntegerIndexString(value) {
        if (typeof value !== "string") {
          return false;
        }
        const number = +value;
        if (value !== number + "") {
          return false;
        }
        if (!(0, _primordials.NumberIsFinite)(number)) {
          return false;
        }
        return number === (0, _primordials.MathTrunc)(number);
      }
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/_util/brand.cjs
  var require_brand = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/_util/brand.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.hasFloat16ArrayBrand = hasFloat16ArrayBrand;
      var _is = require_is();
      var _messages = require_messages();
      var _primordials = require_primordials();
      var brand = exports21.brand = (0, _primordials.SymbolFor)("__Float16Array__");
      function hasFloat16ArrayBrand(target) {
        if (!(0, _is.isObjectLike)(target)) {
          return false;
        }
        const prototype = (0, _primordials.ReflectGetPrototypeOf)(target);
        if (!(0, _is.isObjectLike)(prototype)) {
          return false;
        }
        const constructor = prototype.constructor;
        if (constructor === void 0) {
          return false;
        }
        if (!(0, _is.isObject)(constructor)) {
          throw (0, _primordials.NativeTypeError)(_messages.THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);
        }
        return (0, _primordials.ReflectHas)(constructor, brand);
      }
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/_util/converter.cjs
  var require_converter = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/_util/converter.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.convertToNumber = convertToNumber;
      exports21.roundToFloat16 = roundToFloat16;
      exports21.roundToFloat16Bits = roundToFloat16Bits;
      var _primordials = require_primordials();
      var INVERSE_OF_EPSILON = 1 / _primordials.EPSILON;
      function roundTiesToEven(num) {
        return num + INVERSE_OF_EPSILON - INVERSE_OF_EPSILON;
      }
      var FLOAT16_MIN_VALUE = 6103515625e-14;
      var FLOAT16_MAX_VALUE = 65504;
      var FLOAT16_EPSILON = 9765625e-10;
      var FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;
      var FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;
      function roundToFloat16(num) {
        const number = +num;
        if (!(0, _primordials.NumberIsFinite)(number) || number === 0) {
          return number;
        }
        const sign = number > 0 ? 1 : -1;
        const absolute = (0, _primordials.MathAbs)(number);
        if (absolute < FLOAT16_MIN_VALUE) {
          return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;
        }
        const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;
        const result = temp - (temp - absolute);
        if (result > FLOAT16_MAX_VALUE || (0, _primordials.NumberIsNaN)(result)) {
          return sign * Infinity;
        }
        return sign * result;
      }
      var buffer2 = new _primordials.NativeArrayBuffer(4);
      var floatView = new _primordials.NativeFloat32Array(buffer2);
      var uint32View = new _primordials.NativeUint32Array(buffer2);
      var baseTable = new _primordials.NativeUint16Array(512);
      var shiftTable = new _primordials.NativeUint8Array(512);
      for (let i5 = 0; i5 < 256; ++i5) {
        const e5 = i5 - 127;
        if (e5 < -24) {
          baseTable[i5] = 0;
          baseTable[i5 | 256] = 32768;
          shiftTable[i5] = 24;
          shiftTable[i5 | 256] = 24;
        } else if (e5 < -14) {
          baseTable[i5] = 1024 >> -e5 - 14;
          baseTable[i5 | 256] = 1024 >> -e5 - 14 | 32768;
          shiftTable[i5] = -e5 - 1;
          shiftTable[i5 | 256] = -e5 - 1;
        } else if (e5 <= 15) {
          baseTable[i5] = e5 + 15 << 10;
          baseTable[i5 | 256] = e5 + 15 << 10 | 32768;
          shiftTable[i5] = 13;
          shiftTable[i5 | 256] = 13;
        } else if (e5 < 128) {
          baseTable[i5] = 31744;
          baseTable[i5 | 256] = 64512;
          shiftTable[i5] = 24;
          shiftTable[i5 | 256] = 24;
        } else {
          baseTable[i5] = 31744;
          baseTable[i5 | 256] = 64512;
          shiftTable[i5] = 13;
          shiftTable[i5 | 256] = 13;
        }
      }
      function roundToFloat16Bits(num) {
        floatView[0] = roundToFloat16(num);
        const f5 = uint32View[0];
        const e5 = f5 >> 23 & 511;
        return baseTable[e5] + ((f5 & 8388607) >> shiftTable[e5]);
      }
      var mantissaTable = new _primordials.NativeUint32Array(2048);
      for (let i5 = 1; i5 < 1024; ++i5) {
        let m4 = i5 << 13;
        let e5 = 0;
        while ((m4 & 8388608) === 0) {
          m4 <<= 1;
          e5 -= 8388608;
        }
        m4 &= ~8388608;
        e5 += 947912704;
        mantissaTable[i5] = m4 | e5;
      }
      for (let i5 = 1024; i5 < 2048; ++i5) {
        mantissaTable[i5] = 939524096 + (i5 - 1024 << 13);
      }
      var exponentTable = new _primordials.NativeUint32Array(64);
      for (let i5 = 1; i5 < 31; ++i5) {
        exponentTable[i5] = i5 << 23;
      }
      exponentTable[31] = 1199570944;
      exponentTable[32] = 2147483648;
      for (let i5 = 33; i5 < 63; ++i5) {
        exponentTable[i5] = 2147483648 + (i5 - 32 << 23);
      }
      exponentTable[63] = 3347054592;
      var offsetTable = new _primordials.NativeUint16Array(64);
      for (let i5 = 1; i5 < 64; ++i5) {
        if (i5 !== 32) {
          offsetTable[i5] = 1024;
        }
      }
      function convertToNumber(float16bits) {
        const i5 = float16bits >> 10;
        uint32View[0] = mantissaTable[offsetTable[i5] + (float16bits & 1023)] + exponentTable[i5];
        return floatView[0];
      }
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/_util/spec.cjs
  var require_spec = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/_util/spec.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.IsDetachedBuffer = IsDetachedBuffer;
      exports21.SpeciesConstructor = SpeciesConstructor;
      exports21.ToIntegerOrInfinity = ToIntegerOrInfinity;
      exports21.ToLength = ToLength;
      exports21.defaultCompare = defaultCompare;
      var _is = require_is();
      var _messages = require_messages();
      var _primordials = require_primordials();
      function ToIntegerOrInfinity(target) {
        const number = +target;
        if ((0, _primordials.NumberIsNaN)(number) || number === 0) {
          return 0;
        }
        return (0, _primordials.MathTrunc)(number);
      }
      function ToLength(target) {
        const length = ToIntegerOrInfinity(target);
        if (length < 0) {
          return 0;
        }
        return length < _primordials.MAX_SAFE_INTEGER ? length : _primordials.MAX_SAFE_INTEGER;
      }
      function SpeciesConstructor(target, defaultConstructor) {
        if (!(0, _is.isObject)(target)) {
          throw (0, _primordials.NativeTypeError)(_messages.THIS_IS_NOT_AN_OBJECT);
        }
        const constructor = target.constructor;
        if (constructor === void 0) {
          return defaultConstructor;
        }
        if (!(0, _is.isObject)(constructor)) {
          throw (0, _primordials.NativeTypeError)(_messages.THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);
        }
        const species = constructor[_primordials.SymbolSpecies];
        if (species == null) {
          return defaultConstructor;
        }
        return species;
      }
      function IsDetachedBuffer(buffer2) {
        if ((0, _is.isSharedArrayBuffer)(buffer2)) {
          return false;
        }
        try {
          (0, _primordials.ArrayBufferPrototypeSlice)(buffer2, 0, 0);
          return false;
        } catch (e5) {
        }
        return true;
      }
      function defaultCompare(x3, y5) {
        const isXNaN = (0, _primordials.NumberIsNaN)(x3);
        const isYNaN = (0, _primordials.NumberIsNaN)(y5);
        if (isXNaN && isYNaN) {
          return 0;
        }
        if (isXNaN) {
          return 1;
        }
        if (isYNaN) {
          return -1;
        }
        if (x3 < y5) {
          return -1;
        }
        if (x3 > y5) {
          return 1;
        }
        if (x3 === 0 && y5 === 0) {
          const isXPlusZero = (0, _primordials.ObjectIs)(x3, 0);
          const isYPlusZero = (0, _primordials.ObjectIs)(y5, 0);
          if (!isXPlusZero && isYPlusZero) {
            return -1;
          }
          if (isXPlusZero && !isYPlusZero) {
            return 1;
          }
        }
        return 0;
      }
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/Float16Array.cjs
  var require_Float16Array = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/Float16Array.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.isFloat16Array = isFloat16Array;
      var _arrayIterator = require_arrayIterator();
      var _brand = require_brand();
      var _converter = require_converter();
      var _is = require_is();
      var _messages = require_messages();
      var _primordials = require_primordials();
      var _spec = require_spec();
      var BYTES_PER_ELEMENT = 2;
      var float16bitsArrays = new _primordials.NativeWeakMap();
      function isFloat16Array(target) {
        return (0, _primordials.WeakMapPrototypeHas)(float16bitsArrays, target) || !(0, _primordials.ArrayBufferIsView)(target) && (0, _brand.hasFloat16ArrayBrand)(target);
      }
      function assertFloat16Array(target) {
        if (!isFloat16Array(target)) {
          throw (0, _primordials.NativeTypeError)(_messages.THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT);
        }
      }
      function assertSpeciesTypedArray(target, count) {
        const isTargetFloat16Array = isFloat16Array(target);
        const isTargetTypedArray = (0, _is.isNativeTypedArray)(target);
        if (!isTargetFloat16Array && !isTargetTypedArray) {
          throw (0, _primordials.NativeTypeError)(_messages.SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT);
        }
        if (typeof count === "number") {
          let length;
          if (isTargetFloat16Array) {
            const float16bitsArray = getFloat16BitsArray(target);
            length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          } else {
            length = (0, _primordials.TypedArrayPrototypeGetLength)(target);
          }
          if (length < count) {
            throw (0, _primordials.NativeTypeError)(_messages.DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH);
          }
        }
        if ((0, _is.isNativeBigIntTypedArray)(target)) {
          throw (0, _primordials.NativeTypeError)(_messages.CANNOT_MIX_BIGINT_AND_OTHER_TYPES);
        }
      }
      function getFloat16BitsArray(float16) {
        const float16bitsArray = (0, _primordials.WeakMapPrototypeGet)(float16bitsArrays, float16);
        if (float16bitsArray !== void 0) {
          const buffer3 = (0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray);
          if ((0, _spec.IsDetachedBuffer)(buffer3)) {
            throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
          }
          return float16bitsArray;
        }
        const buffer2 = float16.buffer;
        if ((0, _spec.IsDetachedBuffer)(buffer2)) {
          throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
        }
        const cloned = (0, _primordials.ReflectConstruct)(Float16Array, [buffer2, float16.byteOffset, float16.length], float16.constructor);
        return (0, _primordials.WeakMapPrototypeGet)(float16bitsArrays, cloned);
      }
      function copyToArray(float16bitsArray) {
        const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
        const array = [];
        for (let i5 = 0; i5 < length; ++i5) {
          array[i5] = (0, _converter.convertToNumber)(float16bitsArray[i5]);
        }
        return array;
      }
      var TypedArrayPrototypeGetters = new _primordials.NativeWeakSet();
      for (const key of (0, _primordials.ReflectOwnKeys)(_primordials.TypedArrayPrototype)) {
        if (key === _primordials.SymbolToStringTag) {
          continue;
        }
        const descriptor = (0, _primordials.ReflectGetOwnPropertyDescriptor)(_primordials.TypedArrayPrototype, key);
        if ((0, _primordials.ObjectHasOwn)(descriptor, "get") && typeof descriptor.get === "function") {
          (0, _primordials.WeakSetPrototypeAdd)(TypedArrayPrototypeGetters, descriptor.get);
        }
      }
      var handler = (0, _primordials.ObjectFreeze)({
        get(target, key, receiver) {
          if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key)) {
            return (0, _converter.convertToNumber)((0, _primordials.ReflectGet)(target, key));
          }
          if ((0, _primordials.WeakSetPrototypeHas)(TypedArrayPrototypeGetters, (0, _primordials.ObjectPrototype__lookupGetter__)(target, key))) {
            return (0, _primordials.ReflectGet)(target, key);
          }
          return (0, _primordials.ReflectGet)(target, key, receiver);
        },
        set(target, key, value, receiver) {
          if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key)) {
            return (0, _primordials.ReflectSet)(target, key, (0, _converter.roundToFloat16Bits)(value));
          }
          return (0, _primordials.ReflectSet)(target, key, value, receiver);
        },
        getOwnPropertyDescriptor(target, key) {
          if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key)) {
            const descriptor = (0, _primordials.ReflectGetOwnPropertyDescriptor)(target, key);
            descriptor.value = (0, _converter.convertToNumber)(descriptor.value);
            return descriptor;
          }
          return (0, _primordials.ReflectGetOwnPropertyDescriptor)(target, key);
        },
        defineProperty(target, key, descriptor) {
          if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key) && (0, _primordials.ObjectHasOwn)(descriptor, "value")) {
            descriptor.value = (0, _converter.roundToFloat16Bits)(descriptor.value);
            return (0, _primordials.ReflectDefineProperty)(target, key, descriptor);
          }
          return (0, _primordials.ReflectDefineProperty)(target, key, descriptor);
        }
      });
      var Float16Array = class _Float16Array {
        constructor(input, _byteOffset, _length) {
          let float16bitsArray;
          if (isFloat16Array(input)) {
            float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, [getFloat16BitsArray(input)], new.target);
          } else if ((0, _is.isObject)(input) && !(0, _is.isAnyArrayBuffer)(input)) {
            let list;
            let length;
            if ((0, _is.isNativeTypedArray)(input)) {
              list = input;
              length = (0, _primordials.TypedArrayPrototypeGetLength)(input);
              const buffer2 = (0, _primordials.TypedArrayPrototypeGetBuffer)(input);
              if ((0, _spec.IsDetachedBuffer)(buffer2)) {
                throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
              }
              if ((0, _is.isNativeBigIntTypedArray)(input)) {
                throw (0, _primordials.NativeTypeError)(_messages.CANNOT_MIX_BIGINT_AND_OTHER_TYPES);
              }
              const data = new _primordials.NativeArrayBuffer(length * BYTES_PER_ELEMENT);
              float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, [data], new.target);
            } else {
              const iterator = input[_primordials.SymbolIterator];
              if (iterator != null && typeof iterator !== "function") {
                throw (0, _primordials.NativeTypeError)(_messages.ITERATOR_PROPERTY_IS_NOT_CALLABLE);
              }
              if (iterator != null) {
                if ((0, _is.isOrdinaryArray)(input)) {
                  list = input;
                  length = input.length;
                } else {
                  list = [...input];
                  length = list.length;
                }
              } else {
                list = input;
                length = (0, _spec.ToLength)(list.length);
              }
              float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, [length], new.target);
            }
            for (let i5 = 0; i5 < length; ++i5) {
              float16bitsArray[i5] = (0, _converter.roundToFloat16Bits)(list[i5]);
            }
          } else {
            float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, arguments, new.target);
          }
          const proxy = new _primordials.NativeProxy(float16bitsArray, handler);
          (0, _primordials.WeakMapPrototypeSet)(float16bitsArrays, proxy, float16bitsArray);
          return proxy;
        }
        static from(src, ...opts) {
          const Constructor = this;
          if (!(0, _primordials.ReflectHas)(Constructor, _brand.brand)) {
            throw (0, _primordials.NativeTypeError)(_messages.THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY);
          }
          if (Constructor === _Float16Array) {
            if (isFloat16Array(src) && opts.length === 0) {
              const float16bitsArray = getFloat16BitsArray(src);
              const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));
              return new _Float16Array((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.TypedArrayPrototypeSlice)(uint16)));
            }
            if (opts.length === 0) {
              return new _Float16Array((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.Uint16ArrayFrom)(src, _converter.roundToFloat16Bits)));
            }
            const mapFunc = opts[0];
            const thisArg = opts[1];
            return new _Float16Array((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.Uint16ArrayFrom)(src, function(val, ...args) {
              return (0, _converter.roundToFloat16Bits)((0, _primordials.ReflectApply)(mapFunc, this, [val, ...(0, _arrayIterator.safeIfNeeded)(args)]));
            }, thisArg)));
          }
          let list;
          let length;
          const iterator = src[_primordials.SymbolIterator];
          if (iterator != null && typeof iterator !== "function") {
            throw (0, _primordials.NativeTypeError)(_messages.ITERATOR_PROPERTY_IS_NOT_CALLABLE);
          }
          if (iterator != null) {
            if ((0, _is.isOrdinaryArray)(src)) {
              list = src;
              length = src.length;
            } else if ((0, _is.isOrdinaryNativeTypedArray)(src)) {
              list = src;
              length = (0, _primordials.TypedArrayPrototypeGetLength)(src);
            } else {
              list = [...src];
              length = list.length;
            }
          } else {
            if (src == null) {
              throw (0, _primordials.NativeTypeError)(_messages.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);
            }
            list = (0, _primordials.NativeObject)(src);
            length = (0, _spec.ToLength)(list.length);
          }
          const array = new Constructor(length);
          if (opts.length === 0) {
            for (let i5 = 0; i5 < length; ++i5) {
              array[i5] = list[i5];
            }
          } else {
            const mapFunc = opts[0];
            const thisArg = opts[1];
            for (let i5 = 0; i5 < length; ++i5) {
              array[i5] = (0, _primordials.ReflectApply)(mapFunc, thisArg, [list[i5], i5]);
            }
          }
          return array;
        }
        static of(...items) {
          const Constructor = this;
          if (!(0, _primordials.ReflectHas)(Constructor, _brand.brand)) {
            throw (0, _primordials.NativeTypeError)(_messages.THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY);
          }
          const length = items.length;
          if (Constructor === _Float16Array) {
            const proxy = new _Float16Array(length);
            const float16bitsArray = getFloat16BitsArray(proxy);
            for (let i5 = 0; i5 < length; ++i5) {
              float16bitsArray[i5] = (0, _converter.roundToFloat16Bits)(items[i5]);
            }
            return proxy;
          }
          const array = new Constructor(length);
          for (let i5 = 0; i5 < length; ++i5) {
            array[i5] = items[i5];
          }
          return array;
        }
        keys() {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          return (0, _primordials.TypedArrayPrototypeKeys)(float16bitsArray);
        }
        values() {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          return (0, _arrayIterator.wrap)(function* () {
            for (const val of (0, _primordials.TypedArrayPrototypeValues)(float16bitsArray)) {
              yield (0, _converter.convertToNumber)(val);
            }
          }());
        }
        entries() {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          return (0, _arrayIterator.wrap)(function* () {
            for (const [i5, val] of (0, _primordials.TypedArrayPrototypeEntries)(float16bitsArray)) {
              yield [i5, (0, _converter.convertToNumber)(val)];
            }
          }());
        }
        at(index) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const relativeIndex = (0, _spec.ToIntegerOrInfinity)(index);
          const k3 = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
          if (k3 < 0 || k3 >= length) {
            return;
          }
          return (0, _converter.convertToNumber)(float16bitsArray[k3]);
        }
        with(index, value) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const relativeIndex = (0, _spec.ToIntegerOrInfinity)(index);
          const k3 = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
          const number = +value;
          if (k3 < 0 || k3 >= length) {
            throw (0, _primordials.NativeRangeError)(_messages.OFFSET_IS_OUT_OF_BOUNDS);
          }
          const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));
          const cloned = new _Float16Array((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.TypedArrayPrototypeSlice)(uint16)));
          const array = getFloat16BitsArray(cloned);
          array[k3] = (0, _converter.roundToFloat16Bits)(number);
          return cloned;
        }
        map(callback, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const thisArg = opts[0];
          const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, _Float16Array);
          if (Constructor === _Float16Array) {
            const proxy = new _Float16Array(length);
            const array2 = getFloat16BitsArray(proxy);
            for (let i5 = 0; i5 < length; ++i5) {
              const val = (0, _converter.convertToNumber)(float16bitsArray[i5]);
              array2[i5] = (0, _converter.roundToFloat16Bits)((0, _primordials.ReflectApply)(callback, thisArg, [val, i5, this]));
            }
            return proxy;
          }
          const array = new Constructor(length);
          assertSpeciesTypedArray(array, length);
          for (let i5 = 0; i5 < length; ++i5) {
            const val = (0, _converter.convertToNumber)(float16bitsArray[i5]);
            array[i5] = (0, _primordials.ReflectApply)(callback, thisArg, [val, i5, this]);
          }
          return array;
        }
        filter(callback, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const thisArg = opts[0];
          const kept = [];
          for (let i5 = 0; i5 < length; ++i5) {
            const val = (0, _converter.convertToNumber)(float16bitsArray[i5]);
            if ((0, _primordials.ReflectApply)(callback, thisArg, [val, i5, this])) {
              (0, _primordials.ArrayPrototypePush)(kept, val);
            }
          }
          const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, _Float16Array);
          const array = new Constructor(kept);
          assertSpeciesTypedArray(array);
          return array;
        }
        reduce(callback, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          if (length === 0 && opts.length === 0) {
            throw (0, _primordials.NativeTypeError)(_messages.REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);
          }
          let accumulator, start;
          if (opts.length === 0) {
            accumulator = (0, _converter.convertToNumber)(float16bitsArray[0]);
            start = 1;
          } else {
            accumulator = opts[0];
            start = 0;
          }
          for (let i5 = start; i5 < length; ++i5) {
            accumulator = callback(accumulator, (0, _converter.convertToNumber)(float16bitsArray[i5]), i5, this);
          }
          return accumulator;
        }
        reduceRight(callback, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          if (length === 0 && opts.length === 0) {
            throw (0, _primordials.NativeTypeError)(_messages.REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);
          }
          let accumulator, start;
          if (opts.length === 0) {
            accumulator = (0, _converter.convertToNumber)(float16bitsArray[length - 1]);
            start = length - 2;
          } else {
            accumulator = opts[0];
            start = length - 1;
          }
          for (let i5 = start; i5 >= 0; --i5) {
            accumulator = callback(accumulator, (0, _converter.convertToNumber)(float16bitsArray[i5]), i5, this);
          }
          return accumulator;
        }
        forEach(callback, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const thisArg = opts[0];
          for (let i5 = 0; i5 < length; ++i5) {
            (0, _primordials.ReflectApply)(callback, thisArg, [(0, _converter.convertToNumber)(float16bitsArray[i5]), i5, this]);
          }
        }
        find(callback, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const thisArg = opts[0];
          for (let i5 = 0; i5 < length; ++i5) {
            const value = (0, _converter.convertToNumber)(float16bitsArray[i5]);
            if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i5, this])) {
              return value;
            }
          }
        }
        findIndex(callback, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const thisArg = opts[0];
          for (let i5 = 0; i5 < length; ++i5) {
            const value = (0, _converter.convertToNumber)(float16bitsArray[i5]);
            if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i5, this])) {
              return i5;
            }
          }
          return -1;
        }
        findLast(callback, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const thisArg = opts[0];
          for (let i5 = length - 1; i5 >= 0; --i5) {
            const value = (0, _converter.convertToNumber)(float16bitsArray[i5]);
            if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i5, this])) {
              return value;
            }
          }
        }
        findLastIndex(callback, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const thisArg = opts[0];
          for (let i5 = length - 1; i5 >= 0; --i5) {
            const value = (0, _converter.convertToNumber)(float16bitsArray[i5]);
            if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i5, this])) {
              return i5;
            }
          }
          return -1;
        }
        every(callback, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const thisArg = opts[0];
          for (let i5 = 0; i5 < length; ++i5) {
            if (!(0, _primordials.ReflectApply)(callback, thisArg, [(0, _converter.convertToNumber)(float16bitsArray[i5]), i5, this])) {
              return false;
            }
          }
          return true;
        }
        some(callback, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const thisArg = opts[0];
          for (let i5 = 0; i5 < length; ++i5) {
            if ((0, _primordials.ReflectApply)(callback, thisArg, [(0, _converter.convertToNumber)(float16bitsArray[i5]), i5, this])) {
              return true;
            }
          }
          return false;
        }
        set(input, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const targetOffset = (0, _spec.ToIntegerOrInfinity)(opts[0]);
          if (targetOffset < 0) {
            throw (0, _primordials.NativeRangeError)(_messages.OFFSET_IS_OUT_OF_BOUNDS);
          }
          if (input == null) {
            throw (0, _primordials.NativeTypeError)(_messages.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);
          }
          if ((0, _is.isNativeBigIntTypedArray)(input)) {
            throw (0, _primordials.NativeTypeError)(_messages.CANNOT_MIX_BIGINT_AND_OTHER_TYPES);
          }
          if (isFloat16Array(input)) {
            return (0, _primordials.TypedArrayPrototypeSet)(getFloat16BitsArray(this), getFloat16BitsArray(input), targetOffset);
          }
          if ((0, _is.isNativeTypedArray)(input)) {
            const buffer2 = (0, _primordials.TypedArrayPrototypeGetBuffer)(input);
            if ((0, _spec.IsDetachedBuffer)(buffer2)) {
              throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
            }
          }
          const targetLength = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const src = (0, _primordials.NativeObject)(input);
          const srcLength = (0, _spec.ToLength)(src.length);
          if (targetOffset === Infinity || srcLength + targetOffset > targetLength) {
            throw (0, _primordials.NativeRangeError)(_messages.OFFSET_IS_OUT_OF_BOUNDS);
          }
          for (let i5 = 0; i5 < srcLength; ++i5) {
            float16bitsArray[i5 + targetOffset] = (0, _converter.roundToFloat16Bits)(src[i5]);
          }
        }
        reverse() {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          (0, _primordials.TypedArrayPrototypeReverse)(float16bitsArray);
          return this;
        }
        toReversed() {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));
          const cloned = new _Float16Array((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.TypedArrayPrototypeSlice)(uint16)));
          const clonedFloat16bitsArray = getFloat16BitsArray(cloned);
          (0, _primordials.TypedArrayPrototypeReverse)(clonedFloat16bitsArray);
          return cloned;
        }
        fill(value, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          (0, _primordials.TypedArrayPrototypeFill)(float16bitsArray, (0, _converter.roundToFloat16Bits)(value), ...(0, _arrayIterator.safeIfNeeded)(opts));
          return this;
        }
        copyWithin(target, start, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          (0, _primordials.TypedArrayPrototypeCopyWithin)(float16bitsArray, target, start, ...(0, _arrayIterator.safeIfNeeded)(opts));
          return this;
        }
        sort(compareFn) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const sortCompare = compareFn !== void 0 ? compareFn : _spec.defaultCompare;
          (0, _primordials.TypedArrayPrototypeSort)(float16bitsArray, (x3, y5) => {
            return sortCompare((0, _converter.convertToNumber)(x3), (0, _converter.convertToNumber)(y5));
          });
          return this;
        }
        toSorted(compareFn) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          if (compareFn !== void 0 && typeof compareFn !== "function") {
            throw new _primordials.NativeTypeError(_messages.THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED);
          }
          const sortCompare = compareFn !== void 0 ? compareFn : _spec.defaultCompare;
          const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));
          const cloned = new _Float16Array((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.TypedArrayPrototypeSlice)(uint16)));
          const clonedFloat16bitsArray = getFloat16BitsArray(cloned);
          (0, _primordials.TypedArrayPrototypeSort)(clonedFloat16bitsArray, (x3, y5) => {
            return sortCompare((0, _converter.convertToNumber)(x3), (0, _converter.convertToNumber)(y5));
          });
          return cloned;
        }
        slice(start, end) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, _Float16Array);
          if (Constructor === _Float16Array) {
            const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));
            return new _Float16Array((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.TypedArrayPrototypeSlice)(uint16, start, end)));
          }
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          const relativeStart = (0, _spec.ToIntegerOrInfinity)(start);
          const relativeEnd = end === void 0 ? length : (0, _spec.ToIntegerOrInfinity)(end);
          let k3;
          if (relativeStart === -Infinity) {
            k3 = 0;
          } else if (relativeStart < 0) {
            k3 = length + relativeStart > 0 ? length + relativeStart : 0;
          } else {
            k3 = length < relativeStart ? length : relativeStart;
          }
          let final;
          if (relativeEnd === -Infinity) {
            final = 0;
          } else if (relativeEnd < 0) {
            final = length + relativeEnd > 0 ? length + relativeEnd : 0;
          } else {
            final = length < relativeEnd ? length : relativeEnd;
          }
          const count = final - k3 > 0 ? final - k3 : 0;
          const array = new Constructor(count);
          assertSpeciesTypedArray(array, count);
          if (count === 0) {
            return array;
          }
          const buffer2 = (0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray);
          if ((0, _spec.IsDetachedBuffer)(buffer2)) {
            throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
          }
          let n5 = 0;
          while (k3 < final) {
            array[n5] = (0, _converter.convertToNumber)(float16bitsArray[k3]);
            ++k3;
            ++n5;
          }
          return array;
        }
        subarray(begin, end) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, _Float16Array);
          const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));
          const uint16Subarray = (0, _primordials.TypedArrayPrototypeSubarray)(uint16, begin, end);
          const array = new Constructor((0, _primordials.TypedArrayPrototypeGetBuffer)(uint16Subarray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(uint16Subarray), (0, _primordials.TypedArrayPrototypeGetLength)(uint16Subarray));
          assertSpeciesTypedArray(array);
          return array;
        }
        indexOf(element, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          let from = (0, _spec.ToIntegerOrInfinity)(opts[0]);
          if (from === Infinity) {
            return -1;
          }
          if (from < 0) {
            from += length;
            if (from < 0) {
              from = 0;
            }
          }
          for (let i5 = from; i5 < length; ++i5) {
            if ((0, _primordials.ObjectHasOwn)(float16bitsArray, i5) && (0, _converter.convertToNumber)(float16bitsArray[i5]) === element) {
              return i5;
            }
          }
          return -1;
        }
        lastIndexOf(element, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          let from = opts.length >= 1 ? (0, _spec.ToIntegerOrInfinity)(opts[0]) : length - 1;
          if (from === -Infinity) {
            return -1;
          }
          if (from >= 0) {
            from = from < length - 1 ? from : length - 1;
          } else {
            from += length;
          }
          for (let i5 = from; i5 >= 0; --i5) {
            if ((0, _primordials.ObjectHasOwn)(float16bitsArray, i5) && (0, _converter.convertToNumber)(float16bitsArray[i5]) === element) {
              return i5;
            }
          }
          return -1;
        }
        includes(element, ...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
          let from = (0, _spec.ToIntegerOrInfinity)(opts[0]);
          if (from === Infinity) {
            return false;
          }
          if (from < 0) {
            from += length;
            if (from < 0) {
              from = 0;
            }
          }
          const isNaN2 = (0, _primordials.NumberIsNaN)(element);
          for (let i5 = from; i5 < length; ++i5) {
            const value = (0, _converter.convertToNumber)(float16bitsArray[i5]);
            if (isNaN2 && (0, _primordials.NumberIsNaN)(value)) {
              return true;
            }
            if (value === element) {
              return true;
            }
          }
          return false;
        }
        join(separator) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const array = copyToArray(float16bitsArray);
          return (0, _primordials.ArrayPrototypeJoin)(array, separator);
        }
        toLocaleString(...opts) {
          assertFloat16Array(this);
          const float16bitsArray = getFloat16BitsArray(this);
          const array = copyToArray(float16bitsArray);
          return (0, _primordials.ArrayPrototypeToLocaleString)(array, ...(0, _arrayIterator.safeIfNeeded)(opts));
        }
        get [_primordials.SymbolToStringTag]() {
          if (isFloat16Array(this)) {
            return "Float16Array";
          }
        }
      };
      exports21.Float16Array = Float16Array;
      (0, _primordials.ObjectDefineProperty)(Float16Array, "BYTES_PER_ELEMENT", {
        value: BYTES_PER_ELEMENT
      });
      (0, _primordials.ObjectDefineProperty)(Float16Array, _brand.brand, {});
      (0, _primordials.ReflectSetPrototypeOf)(Float16Array, _primordials.TypedArray);
      var Float16ArrayPrototype = Float16Array.prototype;
      (0, _primordials.ObjectDefineProperty)(Float16ArrayPrototype, "BYTES_PER_ELEMENT", {
        value: BYTES_PER_ELEMENT
      });
      (0, _primordials.ObjectDefineProperty)(Float16ArrayPrototype, _primordials.SymbolIterator, {
        value: Float16ArrayPrototype.values,
        writable: true,
        configurable: true
      });
      (0, _primordials.ReflectSetPrototypeOf)(Float16ArrayPrototype, _primordials.TypedArrayPrototype);
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/isTypedArray.cjs
  var require_isTypedArray = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/isTypedArray.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.isTypedArray = isTypedArray;
      var _Float16Array = require_Float16Array();
      var _is = require_is();
      function isTypedArray(target) {
        return (0, _is.isNativeTypedArray)(target) || (0, _Float16Array.isFloat16Array)(target);
      }
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/DataView.cjs
  var require_DataView = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/DataView.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.getFloat16 = getFloat16;
      exports21.setFloat16 = setFloat16;
      var _arrayIterator = require_arrayIterator();
      var _converter = require_converter();
      var _primordials = require_primordials();
      function getFloat16(dataView, byteOffset, ...opts) {
        return (0, _converter.convertToNumber)((0, _primordials.DataViewPrototypeGetUint16)(dataView, byteOffset, ...(0, _arrayIterator.safeIfNeeded)(opts)));
      }
      function setFloat16(dataView, byteOffset, value, ...opts) {
        return (0, _primordials.DataViewPrototypeSetUint16)(dataView, byteOffset, (0, _converter.roundToFloat16Bits)(value), ...(0, _arrayIterator.safeIfNeeded)(opts));
      }
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/f16round.cjs
  var require_f16round = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/f16round.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.f16round = f16round;
      var _converter = require_converter();
      function f16round(x3) {
        return (0, _converter.roundToFloat16)(x3);
      }
    }
  });

  // ../../node_modules/@petamoriken/float16/lib/index.cjs
  var require_lib2 = __commonJS({
    "../../node_modules/@petamoriken/float16/lib/index.cjs"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      var _Float16Array = require_Float16Array();
      exports21.Float16Array = _Float16Array.Float16Array;
      exports21.isFloat16Array = _Float16Array.isFloat16Array;
      var _isTypedArray = require_isTypedArray();
      exports21.isTypedArray = _isTypedArray.isTypedArray;
      var _DataView = require_DataView();
      exports21.getFloat16 = _DataView.getFloat16;
      exports21.setFloat16 = _DataView.setFloat16;
      var _f16round = require_f16round();
      exports21.f16round = _f16round.f16round;
      exports21.hfround = _f16round.f16round;
    }
  });

  // ../core/dist/protocol-interfaces.js
  var require_protocol_interfaces = __commonJS({
    "../core/dist/protocol-interfaces.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.Endianness = void 0;
      var Endianness;
      (function(Endianness2) {
        Endianness2["BIG_ENDIAN"] = "BIG_ENDIAN";
        Endianness2["LITTLE_ENDIAN"] = "LITTLE_ENDIAN";
        Endianness2["BIG_ENDIAN_BYTE_SWAP"] = "BIG_ENDIAN_BYTE_SWAP";
        Endianness2["LITTLE_ENDIAN_BYTE_SWAP"] = "LITTLE_ENDIAN_BYTE_SWAP";
      })(Endianness || (exports21.Endianness = Endianness = {}));
    }
  });

  // ../core/dist/codecs/octetstream-codec.js
  var require_octetstream_codec = __commonJS({
    "../core/dist/codecs/octetstream-codec.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var float16_1 = require_lib2();
      var logger_1 = require_logger();
      var protocol_interfaces_1 = require_protocol_interfaces();
      var { debug, warn } = (0, logger_1.createLoggers)("core", "octetstream-codec");
      var OctetstreamCodec = class {
        getMediaType() {
          return "application/octet-stream";
        }
        bytesToValue(bytes, schema, parameters = {}) {
          debug("OctetstreamCodec parsing", bytes);
          debug("Parameters", parameters);
          const length = parameters.length != null ? parseInt(parameters.length) : (warn("Missing 'length' parameter necessary for write. I'll do my best"), void 0);
          if (length !== void 0) {
            if (isNaN(length) || length < 0) {
              throw new Error("'length' parameter must be a non-negative number");
            }
            if (length !== bytes.length) {
              throw new Error(`Lengths do not match, required: ${length} provided: ${bytes.length}`);
            }
          }
          let signed = true;
          if (parameters.signed !== void 0) {
            if (parameters.signed !== "true" && parameters.signed !== "false") {
              throw new Error("'signed' parameter must be 'true' or 'false'");
            }
            signed = parameters.signed === "true";
          }
          let bitLength = schema?.["ex:bitLength"] !== void 0 ? parseInt(schema["ex:bitLength"]) : bytes.length * 8;
          if (isNaN(bitLength) || bitLength < 0) {
            throw new Error("'ex:bitLength' must be a non-negative number");
          }
          const offset = schema?.["ex:bitOffset"] !== void 0 ? parseInt(schema["ex:bitOffset"]) : 0;
          if (isNaN(offset) || offset < 0) {
            throw new Error("'ex:bitOffset' must be a non-negative number");
          }
          const bigEndian = !(parameters.byteSeq?.includes(protocol_interfaces_1.Endianness.LITTLE_ENDIAN) === true);
          let dataType = schema?.type;
          if (!dataType) {
            throw new Error("Missing 'type' property in schema");
          }
          if (/(short|(u)?int(8|16|32)?$|float(16|32|64)?|byte)/.test(dataType.toLowerCase())) {
            const typeSem = /(u)?(short|int|float|byte)(8|16|32|64)?/.exec(dataType.toLowerCase());
            if (typeSem) {
              if (typeSem[1] === "u") {
                if (parameters?.signed === "true") {
                  throw new Error("Type is unsigned but 'signed' is true");
                }
                signed = false;
              }
              dataType = typeSem[2];
              if (parseInt(typeSem[3]) !== bitLength) {
                throw new Error(`Type is '${(typeSem[1] ?? "") + typeSem[2] + typeSem[3]}' but 'ex:bitLength' is ` + bitLength);
              }
            }
          }
          if (bitLength > bytes.length * 8 - offset) {
            throw new Error(`'ex:bitLength' is ${bitLength}, but buffer length at offset ${offset} is ${bytes.length * 8 - offset}`);
          }
          if (parameters?.byteSeq?.includes("BYTE_SWAP") === true && bytes.length > 1) {
            bytes.swap16();
          }
          if (offset !== void 0 && bitLength < bytes.length * 8) {
            bytes = this.readBits(bytes, offset, bitLength);
            bitLength = bytes.length * 8;
          }
          switch (dataType) {
            case "boolean":
              return !bytes.every((val) => val === 0);
            case "byte":
            case "short":
            case "int":
            case "integer":
              return this.integerToValue(bytes, { dataLength: bitLength, bigEndian, signed });
            case "float":
            case "double":
            case "number":
              return this.numberToValue(bytes, { dataLength: bitLength, bigEndian });
            case "string":
              return bytes.toString(parameters.charset);
            case "object":
              if (schema === void 0 || schema.properties === void 0) {
                throw new Error("Missing schema for object");
              }
              return this.objectToValue(bytes, schema, parameters);
            case "null":
              return null;
            case "array":
            default:
              throw new Error("Unable to handle dataType " + dataType);
          }
        }
        integerToValue(bytes, options) {
          const { dataLength, bigEndian, signed } = options;
          switch (dataLength) {
            case 8:
              return signed ? bytes.readInt8(0) : bytes.readUInt8(0);
            case 16:
              return bigEndian ? signed ? bytes.readInt16BE(0) : bytes.readUInt16BE(0) : signed ? bytes.readInt16LE(0) : bytes.readUInt16LE(0);
            case 32:
              return bigEndian ? signed ? bytes.readInt32BE(0) : bytes.readUInt32BE(0) : signed ? bytes.readInt32LE(0) : bytes.readUInt32LE(0);
            default: {
              const result = bigEndian ? signed ? bytes.readIntBE(0, dataLength / 8) : bytes.readUIntBE(0, dataLength / 8) : signed ? bytes.readIntLE(0, dataLength / 8) : bytes.readUIntLE(0, dataLength / 8);
              if (!Number.isSafeInteger(result)) {
                warn("Result is not a safe integer");
              }
              return result;
            }
          }
        }
        numberToValue(bytes, options) {
          const { dataLength, bigEndian } = options;
          switch (dataLength) {
            case 16:
              return (0, float16_1.getFloat16)(new DataView(bytes.buffer), bytes.byteOffset, !bigEndian);
            case 32:
              return bigEndian ? bytes.readFloatBE(0) : bytes.readFloatLE(0);
            case 64:
              return bigEndian ? bytes.readDoubleBE(0) : bytes.readDoubleLE(0);
            default:
              throw new Error("Wrong buffer length for type 'number', must be 16, 32, or 64 is " + dataLength);
          }
        }
        objectToValue(bytes, schema, parameters = {}) {
          if (schema?.type !== "object") {
            throw new Error("Schema must be of type 'object'");
          }
          const result = {};
          const sortedProperties = Object.getOwnPropertyNames(schema.properties);
          for (const propertyName of sortedProperties) {
            const propertySchema = schema.properties[propertyName];
            const length = bytes.length.toString();
            result[propertyName] = this.bytesToValue(bytes, propertySchema, { ...parameters, length });
          }
          return result;
        }
        valueToBytes(value, schema, parameters = {}) {
          debug(`OctetstreamCodec serializing '${value}'`);
          const bigEndian = !(parameters.byteSeq?.includes(protocol_interfaces_1.Endianness.LITTLE_ENDIAN) === true);
          let signed = true;
          if (parameters.signed !== void 0) {
            if (parameters.signed !== "true" && parameters.signed !== "false") {
              throw new Error("'signed' parameter must be 'true' or 'false'");
            }
            signed = parameters.signed === "true";
          }
          let length = parameters.length != null ? parseInt(parameters.length) : (warn("Missing 'length' parameter necessary for write. I'll do my best"), void 0);
          if (length !== void 0 && (isNaN(length) || length < 0)) {
            throw new Error("'length' parameter must be a non-negative number");
          }
          let bitLength = schema?.["ex:bitLength"] !== void 0 ? parseInt(schema["ex:bitLength"]) : void 0;
          if (bitLength !== void 0 && (isNaN(bitLength) || bitLength < 0)) {
            throw new Error("'ex:bitLength' must be a non-negative number");
          }
          const offset = schema?.["ex:bitOffset"] !== void 0 ? parseInt(schema["ex:bitOffset"]) : 0;
          if (isNaN(offset) || offset < 0) {
            throw new Error("'ex:bitOffset' must be a non-negative number");
          }
          let dataType = schema?.type ?? void 0;
          if (value === void 0) {
            throw new Error("Undefined value");
          }
          if (dataType === void 0) {
            throw new Error("Missing 'type' property in schema");
          }
          if (/(short|(u)?int(8|16|32)?$|float(16|32|64)?|byte)/.test(dataType.toLowerCase())) {
            const typeSem = /(u)?(short|int|float|byte)(8|16|32|64)?/.exec(dataType.toLowerCase());
            if (typeSem) {
              if (typeSem[1] === "u") {
                if (parameters?.signed === "true") {
                  throw new Error("Type is unsigned but 'signed' is true");
                }
                signed = false;
              }
              dataType = typeSem[2];
              if (bitLength !== void 0) {
                if (parseInt(typeSem[3]) !== bitLength) {
                  throw new Error(`Type is '${(typeSem[1] ?? "") + typeSem[2] + typeSem[3]}' but 'ex:bitLength' is ` + bitLength);
                }
              } else {
                bitLength = +typeSem[3];
              }
            }
          }
          if (length === void 0) {
            if (bitLength !== void 0) {
              length = Math.ceil((offset + bitLength) / 8);
            }
            warn("Missing 'length' parameter necessary for write. I'll do my best");
          } else {
            if (bitLength === void 0) {
              bitLength = length * 8;
            } else {
              if (length * 8 < bitLength + offset) {
                throw new Error("Length is too short for 'ex:bitLength' and 'ex:bitOffset'");
              }
            }
          }
          switch (dataType) {
            case "boolean":
              if (value === true) {
                const buf = Buffer2.alloc(length ?? 1, 0);
                for (let i5 = offset; i5 < offset + (bitLength ?? buf.length * 8); ++i5) {
                  buf[Math.floor(i5 / 8)] |= 1 << 7 - i5 % 8;
                }
                return buf;
              } else {
                return Buffer2.alloc(length ?? 1, 0);
              }
            case "byte":
            case "short":
            case "int":
            case "integer":
              return this.valueToInteger(value, {
                bitLength,
                byteLength: length,
                bigEndian,
                offset,
                signed,
                byteSeq: parameters.byteSeq ?? ""
              });
            case "float":
            case "number":
              return this.valueToNumber(value, {
                bitLength,
                byteLength: length,
                bigEndian,
                offset,
                byteSeq: parameters.byteSeq ?? ""
              });
            case "string": {
              return this.valueToString(value, {
                bitLength,
                byteLength: length,
                offset,
                charset: parameters.charset ?? "utf8"
              });
            }
            case "object":
              if (schema === void 0 || schema.properties === void 0) {
                throw new Error("Missing schema for object");
              }
              return value === null ? Buffer2.alloc(0) : this.valueToObject(value, schema, parameters);
            case "array":
            case "undefined":
              throw new Error("Unable to handle dataType " + dataType);
            case "null":
              return Buffer2.alloc(0);
            default:
              throw new Error("Unable to handle dataType " + dataType);
          }
        }
        valueToInteger(value, options) {
          const length = options.bitLength ?? 32;
          const offset = options.offset ?? 0;
          const byteLength = options.byteLength ?? Math.ceil((offset + length) / 8);
          const { bigEndian, signed, byteSeq } = options;
          if (typeof value !== "number") {
            throw new Error("Value is not a number");
          }
          if (!Number.isSafeInteger(value)) {
            warn("Value is not a safe integer", value);
          }
          const limit = Math.pow(2, signed ? length - 1 : length) - 1;
          if (signed) {
            if (value < -limit - 1 || value > limit) {
              throw new Error("Integer overflow when representing " + value + " as a signed integer using " + length + " bit(s)");
            }
          } else {
            if (value < 0 || value > limit) {
              throw new Error("Integer overflow when representing " + value + " as an unsigned integer using " + length + " bit(s)");
            }
          }
          const buf = Buffer2.alloc(byteLength);
          if (offset !== 0) {
            this.writeBits(buf, value, offset, length, bigEndian);
            return buf;
          }
          if (byteSeq?.includes("BYTE_SwAP") && byteLength > 1) {
            buf.swap16();
          }
          switch (byteLength) {
            case 1:
              signed ? buf.writeInt8(value, 0) : buf.writeUInt8(value, 0);
              break;
            case 2:
              bigEndian ? signed ? buf.writeInt16BE(value, 0) : buf.writeUInt16BE(value, 0) : signed ? buf.writeInt16LE(value, 0) : buf.writeUInt16LE(value, 0);
              break;
            case 4:
              bigEndian ? signed ? buf.writeInt32BE(value, 0) : buf.writeUInt32BE(value, 0) : signed ? buf.writeInt32LE(value, 0) : buf.writeUInt32LE(value, 0);
              break;
            default:
              if (signed && value < 0) {
                value += 1 << 8 * length;
              }
              for (let i5 = 0; i5 < byteLength; ++i5) {
                const byte = value % 256;
                value /= 256;
                buf.writeInt8(byte, bigEndian ? byteLength - i5 - 1 : i5);
              }
          }
          return buf;
        }
        valueToNumber(value, options) {
          if (typeof value !== "number") {
            throw new Error("Value is not a number");
          }
          const length = options.bitLength ?? (options.byteLength !== void 0 ? options.byteLength * 8 : 32);
          const offset = options.offset ?? 0;
          const { bigEndian, byteSeq } = options;
          const byteLength = options.byteLength ?? Math.ceil((offset + length) / 8);
          const byteOffset = Math.floor(offset / 8);
          const buf = Buffer2.alloc(byteLength);
          if (offset % 8 !== 0) {
            throw new Error("Offset must be a multiple of 8");
          }
          if (byteSeq && byteLength > 1) {
            buf.swap16();
          }
          switch (length) {
            case 16:
              (0, float16_1.setFloat16)(new DataView(buf.buffer), byteOffset, value, !bigEndian);
              break;
            case 32:
              bigEndian ? buf.writeFloatBE(value, byteOffset) : buf.writeFloatLE(value, 0);
              break;
            case 64:
              bigEndian ? buf.writeDoubleBE(value, byteOffset) : buf.writeDoubleLE(value, 0);
              break;
            default:
              throw new Error("Wrong buffer length for type 'number', must be 16, 32, or 64 is " + length);
          }
          return buf;
        }
        valueToString(value, options) {
          if (typeof value !== "string") {
            throw new Error("Value is not a string");
          }
          const offset = options.offset ?? 0;
          const { charset } = options;
          const str = String(value);
          if (!Buffer2.isEncoding(charset)) {
            throw new Error("Invalid charset " + charset);
          }
          const buf = Buffer2.from(str, charset);
          const bitLength = options.bitLength ?? buf.length * 8;
          if (buf.length > bitLength) {
            throw new Error(`String is ${buf.length * 8} bits long, but 'ex:bitLength' is ${bitLength}`);
          }
          const byteLength = options.byteLength ?? Math.ceil((offset + bitLength) / 8);
          if (offset % 8 === 0) {
            return Buffer2.concat([Buffer2.alloc(byteLength - bitLength / 8), buf]);
          } else {
            const buffer2 = Buffer2.alloc(byteLength);
            this.copyBits(buf, 0, buffer2, offset, bitLength);
            return buffer2;
          }
        }
        valueToObject(value, schema, parameters = {}, result) {
          if (typeof value !== "object" || value === null) {
            throw new Error("Value is not an object");
          }
          if (parameters.length === void 0) {
            throw new Error("Missing 'length' parameter necessary for write");
          }
          const length = parseInt(parameters.length);
          const offset = schema["ex:bitOffset"] !== void 0 ? parseInt(schema["ex:bitOffset"]) : 0;
          if (isNaN(offset) || offset < 0) {
            throw new Error("'ex:bitOffset' must be a non-negative number");
          }
          if (offset > length * 8) {
            throw new Error(`'ex:bitOffset' ${offset} exceeds 'length' ${length}`);
          }
          result = result ?? Buffer2.alloc(length);
          for (const [propertyName, propertySchema] of Object.entries(schema.properties)) {
            if (Object.hasOwnProperty.call(value, propertyName) === false) {
              throw new Error(`Missing property '${propertyName}'`);
            }
            const propertyValue = value[propertyName];
            const propertyOffset = parseInt(propertySchema["ex:bitOffset"]);
            const propertyLength = parseInt(propertySchema["ex:bitLength"]);
            let buf;
            if (propertySchema.type === "object") {
              buf = this.valueToObject(propertyValue, propertySchema, parameters, result);
            } else {
              buf = this.valueToBytes(propertyValue, propertySchema, parameters);
            }
            this.copyBits(buf, propertyOffset, result, offset + propertyOffset, propertyLength);
          }
          return result;
        }
        readBits(buffer2, bitOffset, bitLength) {
          if (bitOffset < 0) {
            throw new Error("bitOffset must be >= 0");
          }
          if (bitLength < 0) {
            throw new Error("bitLength must be >= 0");
          }
          if (bitOffset + bitLength > buffer2.length * 8) {
            throw new Error("bitOffset + bitLength must be <= buffer.length * 8");
          }
          const resultBuffer = Buffer2.alloc(Math.ceil(bitLength / 8));
          let byteOffset = Math.floor(bitOffset / 8);
          let bitOffsetInByte = bitOffset % 8;
          let targetByte = buffer2[byteOffset];
          let result = 0;
          let resultOffset = 0;
          for (let i5 = 0; i5 < bitLength; i5++) {
            const bit = targetByte >> 7 - bitOffsetInByte & 1;
            result = result << 1 | bit;
            bitOffsetInByte++;
            if (bitOffsetInByte > 7) {
              byteOffset++;
              bitOffsetInByte = 0;
              targetByte = buffer2[byteOffset];
            }
            if (i5 + 1 === bitLength % 8 || (i5 + 1) % 8 === bitLength % 8 || i5 === bitLength - 1) {
              resultBuffer[resultOffset] = result;
              result = 0;
              resultOffset++;
            }
          }
          return resultBuffer;
        }
        writeBits(buffer2, value, offsetBits, length, bigEndian) {
          let byteIndex = Math.floor(offsetBits / 8);
          let bitIndex = offsetBits % 8;
          for (let i5 = 0; i5 < length; i5++) {
            const bitValue = bigEndian ? value >> length - 1 - i5 & 1 : value >> i5 & 1;
            buffer2[byteIndex] |= bitValue << (bigEndian ? 7 - bitIndex : bitIndex);
            bitIndex++;
            if (bitIndex === 8) {
              bitIndex = 0;
              byteIndex++;
            }
          }
        }
        copyBits(source, sourceBitOffset, target, targetBitOffset, bitLength) {
          if (sourceBitOffset % 8 === 0 && targetBitOffset % 8 === 0 && bitLength % 8 === 0) {
            source.copy(target, targetBitOffset / 8, sourceBitOffset / 8, sourceBitOffset + bitLength / 8);
          } else {
            const bits = this.readBits(source, sourceBitOffset, bitLength);
            if (bits.length <= 6) {
              this.writeBits(target, bits.readUIntBE(0, bits.length), targetBitOffset, bitLength, true);
            } else {
              for (let i5 = 0; i5 < bits.length; i5++) {
                const byte = bits.readUInt8(i5);
                this.writeBits(target, byte, targetBitOffset + i5 * 8, 8, true);
              }
            }
          }
        }
      };
      exports21.default = OctetstreamCodec;
    }
  });

  // ../core/dist/content-serdes.js
  var require_content_serdes = __commonJS({
    "../core/dist/content-serdes.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.ContentSerdes = void 0;
      var content_1 = require_content();
      var cbor_codec_1 = __importDefault(require_cbor_codec());
      var json_codec_1 = __importDefault(require_json_codec());
      var text_codec_1 = __importDefault(require_text_codec());
      var base64_codec_1 = __importDefault(require_base64_codec());
      var octetstream_codec_1 = __importDefault(require_octetstream_codec());
      var stream_1 = (init_stream(), __toCommonJS(stream_exports));
      var core_1 = require_core3();
      var web_streams_polyfill_1 = require_ponyfill();
      var logger_1 = require_logger();
      var { debug, warn } = (0, logger_1.createLoggers)("core", "content-serdes");
      var ContentSerdes = class _ContentSerdes {
        constructor() {
          this.codecs = /* @__PURE__ */ new Map();
          this.offered = /* @__PURE__ */ new Set();
        }
        static get() {
          if (this.instance == null) {
            this.instance = new _ContentSerdes();
            this.instance.addCodec(new json_codec_1.default(), true);
            this.instance.addCodec(new json_codec_1.default("application/senml+json"));
            this.instance.addCodec(new json_codec_1.default("application/td+json"));
            this.instance.addCodec(new json_codec_1.default("application/ld+json"));
            this.instance.addCodec(new cbor_codec_1.default(), true);
            this.instance.addCodec(new text_codec_1.default());
            this.instance.addCodec(new text_codec_1.default("text/html"));
            this.instance.addCodec(new text_codec_1.default("text/css"));
            this.instance.addCodec(new text_codec_1.default("application/xml"));
            this.instance.addCodec(new text_codec_1.default("application/xhtml+xml"));
            this.instance.addCodec(new text_codec_1.default("image/svg+xml"));
            this.instance.addCodec(new base64_codec_1.default("image/png"));
            this.instance.addCodec(new base64_codec_1.default("image/gif"));
            this.instance.addCodec(new base64_codec_1.default("image/jpeg"));
            this.instance.addCodec(new octetstream_codec_1.default());
          }
          return this.instance;
        }
        static getMediaType(contentType) {
          const parts = contentType.split(";");
          return parts[0].trim();
        }
        static getMediaTypeParameters(contentType) {
          const parts = contentType.split(";").slice(1);
          const params = {};
          parts.forEach((p5) => {
            const eq = p5.indexOf("=");
            if (eq >= 0) {
              params[p5.substr(0, eq).trim()] = p5.substr(eq + 1).trim();
            } else {
              params[p5.trim()] = void 0;
            }
          });
          return params;
        }
        addCodec(codec, offered = false) {
          _ContentSerdes.get().codecs.set(codec.getMediaType(), codec);
          if (offered)
            _ContentSerdes.get().offered.add(codec.getMediaType());
        }
        getSupportedMediaTypes() {
          return Array.from(_ContentSerdes.get().codecs.keys());
        }
        getOfferedMediaTypes() {
          return Array.from(_ContentSerdes.get().offered);
        }
        isSupported(contentType) {
          const mt = _ContentSerdes.getMediaType(contentType);
          return this.codecs.has(mt);
        }
        contentToValue(content, schema) {
          if (content.type === void 0) {
            if (content.body.byteLength > 0) {
              content.type = _ContentSerdes.DEFAULT;
            } else {
              return void 0;
            }
          }
          const mt = _ContentSerdes.getMediaType(content.type);
          const par = _ContentSerdes.getMediaTypeParameters(content.type);
          if (this.codecs.has(mt)) {
            debug(`ContentSerdes deserializing from ${content.type}`);
            const codec = this.codecs.get(mt);
            const res = codec.bytesToValue(content.body, schema, par);
            return res;
          } else {
            warn(`ContentSerdes passthrough due to unsupported media type '${mt}'`);
            return content.body.toString();
          }
        }
        valueToContent(value, schema, contentType = _ContentSerdes.DEFAULT) {
          if (value === void 0)
            warn("ContentSerdes valueToContent got no value");
          if (value instanceof web_streams_polyfill_1.ReadableStream) {
            return new content_1.Content(contentType, core_1.ProtocolHelpers.toNodeStream(value));
          }
          let bytes;
          const mt = _ContentSerdes.getMediaType(contentType);
          const par = _ContentSerdes.getMediaTypeParameters(contentType);
          const codec = this.codecs.get(mt);
          if (codec) {
            debug(`ContentSerdes serializing to ${contentType}`);
            bytes = codec.valueToBytes(value, schema, par);
          } else {
            warn(`ContentSerdes passthrough due to unsupported serialization format '${contentType}'`);
            bytes = Buffer2.from(value === null ? "" : value.toString());
          }
          return new content_1.Content(contentType, stream_1.Readable.from([bytes]));
        }
      };
      exports21.ContentSerdes = ContentSerdes;
      ContentSerdes.DEFAULT = "application/json";
      ContentSerdes.TD = "application/td+json";
      ContentSerdes.JSON_LD = "application/ld+json";
      exports21.default = ContentSerdes.get();
    }
  });

  // ../core/node_modules/ajv-formats/dist/formats.js
  var require_formats2 = __commonJS({
    "../core/node_modules/ajv-formats/dist/formats.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.formatNames = exports21.fastFormats = exports21.fullFormats = void 0;
      function fmtDef(validate, compare) {
        return { validate, compare };
      }
      exports21.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: fmtDef(date, compareDate),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: fmtDef(time, compareTime),
        "date-time": fmtDef(date_time, compareDateTime),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte,
        // signed 32 bit integer
        int32: { type: "number", validate: validateInt32 },
        // signed 64 bit integer
        int64: { type: "number", validate: validateInt64 },
        // C-type float
        float: { type: "number", validate: validateNumber },
        // C-type double
        double: { type: "number", validate: validateNumber },
        // hint to the UI to hide input strings
        password: true,
        // unchecked string payload
        binary: true
      };
      exports21.fastFormats = {
        ...exports21.fullFormats,
        date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
        time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
        "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      };
      exports21.formatNames = Object.keys(exports21.fullFormats);
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
      var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function date(str) {
        const matches = DATE.exec(str);
        if (!matches)
          return false;
        const year = +matches[1];
        const month = +matches[2];
        const day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
      }
      function compareDate(d1, d22) {
        if (!(d1 && d22))
          return void 0;
        if (d1 > d22)
          return 1;
        if (d1 < d22)
          return -1;
        return 0;
      }
      var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
      function time(str, withTimeZone) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hour = +matches[1];
        const minute = +matches[2];
        const second = +matches[3];
        const timeZone = matches[5];
        return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
      }
      function compareTime(t1, t22) {
        if (!(t1 && t22))
          return void 0;
        const a1 = TIME.exec(t1);
        const a22 = TIME.exec(t22);
        if (!(a1 && a22))
          return void 0;
        t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
        t22 = a22[1] + a22[2] + a22[3] + (a22[4] || "");
        if (t1 > t22)
          return 1;
        if (t1 < t22)
          return -1;
        return 0;
      }
      var DATE_TIME_SEPARATOR = /t|\s/i;
      function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
      }
      function compareDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
        const [d22, t22] = dt2.split(DATE_TIME_SEPARATOR);
        const res = compareDate(d1, d22);
        if (res === void 0)
          return void 0;
        return res || compareTime(t1, t22);
      }
      var NOT_URI_FRAGMENT = /\/|:/;
      var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function uri(str) {
        return NOT_URI_FRAGMENT.test(str) && URI.test(str);
      }
      var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
      function byte(str) {
        BYTE.lastIndex = 0;
        return BYTE.test(str);
      }
      var MIN_INT32 = -(2 ** 31);
      var MAX_INT32 = 2 ** 31 - 1;
      function validateInt32(value) {
        return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
      }
      function validateInt64(value) {
        return Number.isInteger(value);
      }
      function validateNumber() {
        return true;
      }
      var Z_ANCHOR = /[^\\]\\Z/;
      function regex(str) {
        if (Z_ANCHOR.test(str))
          return false;
        try {
          new RegExp(str);
          return true;
        } catch (e5) {
          return false;
        }
      }
    }
  });

  // ../core/node_modules/ajv-formats/dist/limit.js
  var require_limit2 = __commonJS({
    "../core/node_modules/ajv-formats/dist/limit.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.formatLimitDefinition = void 0;
      var ajv_1 = require_ajv();
      var codegen_1 = require_codegen();
      var ops = codegen_1.operators;
      var KWDs = {
        formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
        formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
        formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
      };
      var error = {
        message: ({ keyword, schemaCode }) => codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
        params: ({ keyword, schemaCode }) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
      };
      exports21.formatLimitDefinition = {
        keyword: Object.keys(KWDs),
        type: "string",
        schemaType: "string",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, keyword, it } = cxt;
          const { opts, self: self2 } = it;
          if (!opts.validateFormats)
            return;
          const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
          if (fCxt.$data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fmt = gen.const("fmt", codegen_1._`${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != "object"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
          }
          function validateFormat() {
            const format3 = fCxt.schema;
            const fmtDef = self2.formats[format3];
            if (!fmtDef || fmtDef === true)
              return;
            if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
              throw new Error(`"${keyword}": format "${format3}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
              key: format3,
              ref: fmtDef,
              code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format3)}` : void 0
            });
            cxt.fail$data(compareCode(fmt));
          }
          function compareCode(fmt) {
            return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
          }
        },
        dependencies: ["format"]
      };
      var formatLimitPlugin = (ajv) => {
        ajv.addKeyword(exports21.formatLimitDefinition);
        return ajv;
      };
      exports21.default = formatLimitPlugin;
    }
  });

  // ../core/node_modules/ajv-formats/dist/index.js
  var require_dist2 = __commonJS({
    "../core/node_modules/ajv-formats/dist/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var formats_1 = require_formats2();
      var limit_1 = require_limit2();
      var codegen_1 = require_codegen();
      var fullName = new codegen_1.Name("fullFormats");
      var fastName = new codegen_1.Name("fastFormats");
      var formatsPlugin = (ajv, opts = { keywords: true }) => {
        if (Array.isArray(opts)) {
          addFormats(ajv, opts, formats_1.fullFormats, fullName);
          return ajv;
        }
        const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
        const list = opts.formats || formats_1.formatNames;
        addFormats(ajv, list, formats, exportName);
        if (opts.keywords)
          limit_1.default(ajv);
        return ajv;
      };
      formatsPlugin.get = (name2, mode = "full") => {
        const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
        const f5 = formats[name2];
        if (!f5)
          throw new Error(`Unknown format "${name2}"`);
        return f5;
      };
      function addFormats(ajv, list, fs, exportName) {
        var _a;
        var _b;
        (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`;
        for (const f5 of list)
          ajv.addFormat(f5, fs[f5]);
      }
      module.exports = exports21 = formatsPlugin;
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.default = formatsPlugin;
    }
  });

  // ../../node_modules/wot-thing-description-types/schema/td-json-schema-validation.json
  var require_td_json_schema_validation = __commonJS({
    "../../node_modules/wot-thing-description-types/schema/td-json-schema-validation.json"(exports21, module) {
      module.exports = {
        title: "Thing Description",
        version: "1.1-09-November-2023",
        description: "JSON Schema for validating TD instances against the TD information model. TD instances can be with or without terms that have default values",
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "https://raw.githubusercontent.com/w3c/wot-thing-description/main/validation/td-json-schema-validation.json",
        definitions: {
          anyUri: {
            type: "string"
          },
          description: {
            type: "string"
          },
          descriptions: {
            type: "object",
            additionalProperties: {
              type: "string"
            }
          },
          title: {
            type: "string"
          },
          titles: {
            type: "object",
            additionalProperties: {
              type: "string"
            }
          },
          security: {
            oneOf: [
              {
                type: "array",
                items: {
                  type: "string"
                },
                minItems: 1
              },
              {
                type: "string"
              }
            ]
          },
          scopes: {
            oneOf: [
              {
                type: "array",
                items: {
                  type: "string"
                }
              },
              {
                type: "string"
              }
            ]
          },
          subprotocol: {
            type: "string",
            examples: [
              "longpoll",
              "websub",
              "sse"
            ]
          },
          "thing-context-td-uri-v1": {
            type: "string",
            const: "https://www.w3.org/2019/wot/td/v1"
          },
          "thing-context-td-uri-v1.1": {
            type: "string",
            const: "https://www.w3.org/2022/wot/td/v1.1"
          },
          "thing-context-td-uri-temp": {
            type: "string",
            const: "http://www.w3.org/ns/td"
          },
          "thing-context": {
            anyOf: [
              {
                $comment: "New context URI with other vocabularies after it but not the old one",
                type: "array",
                items: [
                  {
                    $ref: "#/definitions/thing-context-td-uri-v1.1"
                  }
                ],
                additionalItems: {
                  anyOf: [
                    {
                      $ref: "#/definitions/anyUri"
                    },
                    {
                      type: "object"
                    }
                  ],
                  not: {
                    $ref: "#/definitions/thing-context-td-uri-v1"
                  }
                }
              },
              {
                $comment: "Only the new context URI",
                $ref: "#/definitions/thing-context-td-uri-v1.1"
              },
              {
                $comment: "Old context URI, followed by the new one and possibly other vocabularies. minItems and contains are required since prefixItems does not say all items should be provided",
                type: "array",
                prefixItems: [
                  {
                    $ref: "#/definitions/thing-context-td-uri-v1"
                  },
                  {
                    $ref: "#/definitions/thing-context-td-uri-v1.1"
                  }
                ],
                minItems: 2,
                contains: {
                  $ref: "#/definitions/thing-context-td-uri-v1.1"
                },
                additionalItems: {
                  anyOf: [
                    {
                      $ref: "#/definitions/anyUri"
                    },
                    {
                      type: "object"
                    }
                  ]
                }
              },
              {
                $comment: "Old context URI, followed by possibly other vocabularies. minItems and contains are required since prefixItems does not say all items should be provided",
                type: "array",
                prefixItems: [{
                  $ref: "#/definitions/thing-context-td-uri-v1"
                }],
                minItems: 1,
                contains: {
                  $ref: "#/definitions/thing-context-td-uri-v1"
                },
                additionalItems: {
                  anyOf: [
                    {
                      $ref: "#/definitions/anyUri"
                    },
                    {
                      type: "object"
                    }
                  ]
                }
              },
              {
                $comment: "Only the old context URI",
                $ref: "#/definitions/thing-context-td-uri-v1"
              }
            ]
          },
          bcp47_string: {
            type: "string",
            pattern: "^(((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(x(-[A-Za-z0-9]{1,8})+))?)|(x(-[A-Za-z0-9]{1,8})+)|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$"
          },
          type_declaration: {
            oneOf: [
              {
                type: "string",
                not: {
                  const: "tm:ThingModel"
                }
              },
              {
                type: "array",
                items: {
                  type: "string",
                  not: {
                    const: "tm:ThingModel"
                  }
                }
              }
            ]
          },
          "dataSchema-type": {
            type: "string",
            enum: [
              "boolean",
              "integer",
              "number",
              "string",
              "object",
              "array",
              "null"
            ]
          },
          dataSchema: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              title: {
                $ref: "#/definitions/title"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              titles: {
                $ref: "#/definitions/titles"
              },
              writeOnly: {
                type: "boolean"
              },
              readOnly: {
                type: "boolean"
              },
              oneOf: {
                type: "array",
                items: {
                  $ref: "#/definitions/dataSchema"
                }
              },
              unit: {
                type: "string"
              },
              enum: {
                type: "array",
                minItems: 1,
                uniqueItems: true
              },
              format: {
                type: "string"
              },
              const: {},
              default: {},
              contentEncoding: {
                type: "string"
              },
              contentMediaType: {
                type: "string"
              },
              type: {
                $ref: "#/definitions/dataSchema-type"
              },
              items: {
                oneOf: [
                  {
                    $ref: "#/definitions/dataSchema"
                  },
                  {
                    type: "array",
                    items: {
                      $ref: "#/definitions/dataSchema"
                    }
                  }
                ]
              },
              maxItems: {
                type: "integer",
                minimum: 0
              },
              minItems: {
                type: "integer",
                minimum: 0
              },
              minimum: {
                type: "number"
              },
              maximum: {
                type: "number"
              },
              exclusiveMinimum: {
                type: "number"
              },
              exclusiveMaximum: {
                type: "number"
              },
              minLength: {
                type: "integer",
                minimum: 0
              },
              maxLength: {
                type: "integer",
                minimum: 0
              },
              multipleOf: {
                $ref: "#/definitions/multipleOfDefinition"
              },
              properties: {
                additionalProperties: {
                  $ref: "#/definitions/dataSchema"
                }
              },
              required: {
                type: "array",
                items: {
                  type: "string"
                }
              }
            }
          },
          additionalResponsesDefinition: {
            type: "array",
            items: {
              type: "object",
              properties: {
                contentType: {
                  type: "string"
                },
                schema: {
                  type: "string"
                },
                success: {
                  type: "boolean"
                }
              }
            }
          },
          multipleOfDefinition: {
            type: [
              "integer",
              "number"
            ],
            exclusiveMinimum: 0
          },
          expectedResponse: {
            type: "object",
            properties: {
              contentType: {
                type: "string"
              }
            },
            required: [
              "contentType"
            ]
          },
          form_element_base: {
            type: "object",
            properties: {
              op: {
                oneOf: [
                  {
                    type: "string"
                  },
                  {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  }
                ]
              },
              href: {
                $ref: "#/definitions/anyUri"
              },
              contentType: {
                type: "string"
              },
              contentCoding: {
                type: "string"
              },
              subprotocol: {
                $ref: "#/definitions/subprotocol"
              },
              security: {
                $ref: "#/definitions/security"
              },
              scopes: {
                $ref: "#/definitions/scopes"
              },
              response: {
                $ref: "#/definitions/expectedResponse"
              },
              additionalResponses: {
                $ref: "#/definitions/additionalResponsesDefinition"
              }
            },
            required: [
              "href"
            ],
            additionalProperties: true
          },
          form_element_property: {
            allOf: [{ $ref: "#/definitions/form_element_base" }],
            type: "object",
            properties: {
              op: {
                oneOf: [
                  {
                    type: "string",
                    enum: [
                      "readproperty",
                      "writeproperty",
                      "observeproperty",
                      "unobserveproperty"
                    ]
                  },
                  {
                    type: "array",
                    items: {
                      type: "string",
                      enum: [
                        "readproperty",
                        "writeproperty",
                        "observeproperty",
                        "unobserveproperty"
                      ]
                    },
                    minItems: 1
                  }
                ]
              }
            },
            additionalProperties: true
          },
          form_element_action: {
            allOf: [{ $ref: "#/definitions/form_element_base" }],
            type: "object",
            properties: {
              op: {
                oneOf: [
                  {
                    type: "string",
                    enum: [
                      "invokeaction",
                      "queryaction",
                      "cancelaction"
                    ]
                  },
                  {
                    type: "array",
                    items: {
                      type: "string",
                      enum: [
                        "invokeaction",
                        "queryaction",
                        "cancelaction"
                      ]
                    },
                    minItems: 1
                  }
                ]
              }
            },
            additionalProperties: true
          },
          form_element_event: {
            allOf: [{ $ref: "#/definitions/form_element_base" }],
            type: "object",
            properties: {
              op: {
                oneOf: [
                  {
                    type: "string",
                    enum: [
                      "subscribeevent",
                      "unsubscribeevent"
                    ]
                  },
                  {
                    type: "array",
                    items: {
                      type: "string",
                      enum: [
                        "subscribeevent",
                        "unsubscribeevent"
                      ]
                    },
                    minItems: 1
                  }
                ]
              }
            },
            additionalProperties: true
          },
          form_element_root: {
            allOf: [{ $ref: "#/definitions/form_element_base" }],
            type: "object",
            properties: {
              op: {
                oneOf: [
                  {
                    type: "string",
                    enum: [
                      "readallproperties",
                      "writeallproperties",
                      "readmultipleproperties",
                      "writemultipleproperties",
                      "observeallproperties",
                      "unobserveallproperties",
                      "queryallactions",
                      "subscribeallevents",
                      "unsubscribeallevents"
                    ]
                  },
                  {
                    type: "array",
                    items: {
                      type: "string",
                      enum: [
                        "readallproperties",
                        "writeallproperties",
                        "readmultipleproperties",
                        "writemultipleproperties",
                        "observeallproperties",
                        "unobserveallproperties",
                        "queryallactions",
                        "subscribeallevents",
                        "unsubscribeallevents"
                      ]
                    },
                    minItems: 1
                  }
                ]
              }
            },
            additionalProperties: true,
            required: ["op"]
          },
          form: {
            $comment: "This is NOT for validation purposes but for automatic generation of TS types. For more info, please see: https://github.com/w3c/wot-thing-description/pull/1319#issuecomment-994950057",
            oneOf: [
              { $ref: "#/definitions/form_element_property" },
              { $ref: "#/definitions/form_element_action" },
              { $ref: "#/definitions/form_element_event" },
              { $ref: "#/definitions/form_element_root" }
            ]
          },
          property_element: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              title: {
                $ref: "#/definitions/title"
              },
              titles: {
                $ref: "#/definitions/titles"
              },
              forms: {
                type: "array",
                minItems: 1,
                items: {
                  $ref: "#/definitions/form_element_property"
                }
              },
              uriVariables: {
                type: "object",
                additionalProperties: {
                  $ref: "#/definitions/dataSchema"
                }
              },
              observable: {
                type: "boolean"
              },
              writeOnly: {
                type: "boolean"
              },
              readOnly: {
                type: "boolean"
              },
              oneOf: {
                type: "array",
                items: {
                  $ref: "#/definitions/dataSchema"
                }
              },
              unit: {
                type: "string"
              },
              enum: {
                type: "array",
                minItems: 1,
                uniqueItems: true
              },
              format: {
                type: "string"
              },
              const: {},
              default: {},
              type: {
                $ref: "#/definitions/dataSchema-type"
              },
              items: {
                oneOf: [
                  {
                    $ref: "#/definitions/dataSchema"
                  },
                  {
                    type: "array",
                    items: {
                      $ref: "#/definitions/dataSchema"
                    }
                  }
                ]
              },
              maxItems: {
                type: "integer",
                minimum: 0
              },
              minItems: {
                type: "integer",
                minimum: 0
              },
              minimum: {
                type: "number"
              },
              maximum: {
                type: "number"
              },
              exclusiveMinimum: {
                type: "number"
              },
              exclusiveMaximum: {
                type: "number"
              },
              minLength: {
                type: "integer",
                minimum: 0
              },
              maxLength: {
                type: "integer",
                minimum: 0
              },
              multipleOf: {
                $ref: "#/definitions/multipleOfDefinition"
              },
              properties: {
                additionalProperties: {
                  $ref: "#/definitions/dataSchema"
                }
              },
              required: {
                type: "array",
                items: {
                  type: "string"
                }
              }
            },
            required: [
              "forms"
            ],
            additionalProperties: true
          },
          action_element: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              title: {
                $ref: "#/definitions/title"
              },
              titles: {
                $ref: "#/definitions/titles"
              },
              forms: {
                type: "array",
                minItems: 1,
                items: {
                  $ref: "#/definitions/form_element_action"
                }
              },
              uriVariables: {
                type: "object",
                additionalProperties: {
                  $ref: "#/definitions/dataSchema"
                }
              },
              input: {
                $ref: "#/definitions/dataSchema"
              },
              output: {
                $ref: "#/definitions/dataSchema"
              },
              safe: {
                type: "boolean"
              },
              idempotent: {
                type: "boolean"
              },
              synchronous: {
                type: "boolean"
              }
            },
            required: [
              "forms"
            ],
            additionalProperties: true
          },
          event_element: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              title: {
                $ref: "#/definitions/title"
              },
              titles: {
                $ref: "#/definitions/titles"
              },
              forms: {
                type: "array",
                minItems: 1,
                items: {
                  $ref: "#/definitions/form_element_event"
                }
              },
              uriVariables: {
                type: "object",
                additionalProperties: {
                  $ref: "#/definitions/dataSchema"
                }
              },
              subscription: {
                $ref: "#/definitions/dataSchema"
              },
              data: {
                $ref: "#/definitions/dataSchema"
              },
              dataResponse: {
                $ref: "#/definitions/dataSchema"
              },
              cancellation: {
                $ref: "#/definitions/dataSchema"
              }
            },
            required: [
              "forms"
            ],
            additionalProperties: true
          },
          base_link_element: {
            type: "object",
            properties: {
              href: {
                $ref: "#/definitions/anyUri"
              },
              type: {
                type: "string"
              },
              rel: {
                type: "string"
              },
              anchor: {
                $ref: "#/definitions/anyUri"
              },
              hreflang: {
                anyOf: [
                  { $ref: "#/definitions/bcp47_string" },
                  {
                    type: "array",
                    items: {
                      $ref: "#/definitions/bcp47_string"
                    }
                  }
                ]
              }
            },
            required: [
              "href"
            ],
            additionalProperties: true
          },
          link_element: {
            allOf: [
              {
                $ref: "#/definitions/base_link_element"
              },
              {
                not: {
                  description: "A basic link element should not contain sizes",
                  type: "object",
                  properties: {
                    sizes: {}
                  },
                  required: [
                    "sizes"
                  ]
                }
              },
              {
                not: {
                  description: "A basic link element should not contain icon or tm:extends",
                  properties: {
                    rel: {
                      enum: [
                        "icon",
                        "tm:extends"
                      ]
                    }
                  },
                  required: [
                    "rel"
                  ]
                }
              }
            ]
          },
          icon_link_element: {
            allOf: [
              {
                $ref: "#/definitions/base_link_element"
              },
              {
                properties: {
                  rel: {
                    const: "icon"
                  },
                  sizes: {
                    type: "string",
                    pattern: "[0-9]*x[0-9]+"
                  }
                },
                required: [
                  "rel"
                ]
              }
            ]
          },
          additionalSecurityScheme: {
            description: "Applies to additional SecuritySchemes not defined in the WoT TD specification.",
            $comment: "Additional SecuritySchemes should always be defined via a context extension, using a prefixed value for the scheme. This prefix (e.g. 'ace', see the example below) must contain at least one character in order to reference a valid JSON-LD context extension.",
            examples: [
              {
                scheme: "ace:ACESecurityScheme",
                "ace:as": "coaps://as.example.com/token",
                "ace:audience": "coaps://rs.example.com",
                "ace:scopes": ["limited", "special"],
                "ace:cnonce": true
              }
            ],
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                pattern: ".+:.*"
              }
            },
            required: [
              "scheme"
            ],
            additionalProperties: true
          },
          noSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                enum: [
                  "nosec"
                ]
              }
            },
            required: [
              "scheme"
            ],
            additionalProperties: true
          },
          autoSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                enum: [
                  "auto"
                ]
              }
            },
            not: {
              required: ["name"]
            },
            required: [
              "scheme"
            ],
            additionalProperties: true
          },
          comboSecurityScheme: {
            oneOf: [
              {
                type: "object",
                properties: {
                  "@type": {
                    $ref: "#/definitions/type_declaration"
                  },
                  description: {
                    $ref: "#/definitions/description"
                  },
                  descriptions: {
                    $ref: "#/definitions/descriptions"
                  },
                  proxy: {
                    $ref: "#/definitions/anyUri"
                  },
                  scheme: {
                    type: "string",
                    enum: [
                      "combo"
                    ]
                  },
                  oneOf: {
                    type: "array",
                    minItems: 2,
                    items: {
                      type: "string"
                    }
                  }
                },
                required: [
                  "scheme",
                  "oneOf"
                ],
                additionalProperties: true
              },
              {
                type: "object",
                properties: {
                  "@type": {
                    $ref: "#/definitions/type_declaration"
                  },
                  description: {
                    $ref: "#/definitions/description"
                  },
                  descriptions: {
                    $ref: "#/definitions/descriptions"
                  },
                  proxy: {
                    $ref: "#/definitions/anyUri"
                  },
                  scheme: {
                    type: "string",
                    enum: [
                      "combo"
                    ]
                  },
                  allOf: {
                    type: "array",
                    minItems: 2,
                    items: {
                      type: "string"
                    }
                  }
                },
                required: [
                  "scheme",
                  "allOf"
                ],
                additionalProperties: true
              }
            ]
          },
          basicSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                enum: [
                  "basic"
                ]
              },
              in: {
                type: "string",
                enum: [
                  "header",
                  "query",
                  "body",
                  "cookie",
                  "auto"
                ]
              },
              name: {
                type: "string"
              }
            },
            required: [
              "scheme"
            ],
            additionalProperties: true
          },
          digestSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                enum: [
                  "digest"
                ]
              },
              qop: {
                type: "string",
                enum: [
                  "auth",
                  "auth-int"
                ]
              },
              in: {
                type: "string",
                enum: [
                  "header",
                  "query",
                  "body",
                  "cookie",
                  "auto"
                ]
              },
              name: {
                type: "string"
              }
            },
            required: [
              "scheme"
            ],
            additionalProperties: true
          },
          apiKeySecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                enum: [
                  "apikey"
                ]
              },
              in: {
                type: "string",
                enum: [
                  "header",
                  "query",
                  "body",
                  "cookie",
                  "uri",
                  "auto"
                ]
              },
              name: {
                type: "string"
              }
            },
            required: [
              "scheme"
            ],
            additionalProperties: true
          },
          bearerSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                enum: [
                  "bearer"
                ]
              },
              authorization: {
                $ref: "#/definitions/anyUri"
              },
              alg: {
                type: "string"
              },
              format: {
                type: "string"
              },
              in: {
                type: "string",
                enum: [
                  "header",
                  "query",
                  "body",
                  "cookie",
                  "auto"
                ]
              },
              name: {
                type: "string"
              }
            },
            required: [
              "scheme"
            ],
            additionalProperties: true
          },
          pskSecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                enum: [
                  "psk"
                ]
              },
              identity: {
                type: "string"
              }
            },
            required: [
              "scheme"
            ],
            additionalProperties: true
          },
          oAuth2SecurityScheme: {
            type: "object",
            properties: {
              "@type": {
                $ref: "#/definitions/type_declaration"
              },
              description: {
                $ref: "#/definitions/description"
              },
              descriptions: {
                $ref: "#/definitions/descriptions"
              },
              proxy: {
                $ref: "#/definitions/anyUri"
              },
              scheme: {
                type: "string",
                enum: [
                  "oauth2"
                ]
              },
              authorization: {
                $ref: "#/definitions/anyUri"
              },
              token: {
                $ref: "#/definitions/anyUri"
              },
              refresh: {
                $ref: "#/definitions/anyUri"
              },
              scopes: {
                oneOf: [
                  {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  {
                    type: "string"
                  }
                ]
              },
              flow: {
                anyOf: [
                  {
                    type: "string"
                  },
                  {
                    type: "string",
                    enum: [
                      "code",
                      "client"
                    ]
                  }
                ]
              }
            },
            required: [
              "scheme"
            ],
            additionalProperties: true
          },
          securityScheme: {
            oneOf: [
              {
                $ref: "#/definitions/noSecurityScheme"
              },
              {
                $ref: "#/definitions/autoSecurityScheme"
              },
              {
                $ref: "#/definitions/comboSecurityScheme"
              },
              {
                $ref: "#/definitions/basicSecurityScheme"
              },
              {
                $ref: "#/definitions/digestSecurityScheme"
              },
              {
                $ref: "#/definitions/apiKeySecurityScheme"
              },
              {
                $ref: "#/definitions/bearerSecurityScheme"
              },
              {
                $ref: "#/definitions/pskSecurityScheme"
              },
              {
                $ref: "#/definitions/oAuth2SecurityScheme"
              },
              {
                $ref: "#/definitions/additionalSecurityScheme"
              }
            ]
          }
        },
        type: "object",
        properties: {
          id: {
            type: "string",
            format: "uri"
          },
          title: {
            $ref: "#/definitions/title"
          },
          titles: {
            $ref: "#/definitions/titles"
          },
          properties: {
            type: "object",
            additionalProperties: {
              $ref: "#/definitions/property_element"
            }
          },
          actions: {
            type: "object",
            additionalProperties: {
              $ref: "#/definitions/action_element"
            }
          },
          events: {
            type: "object",
            additionalProperties: {
              $ref: "#/definitions/event_element"
            }
          },
          description: {
            $ref: "#/definitions/description"
          },
          descriptions: {
            $ref: "#/definitions/descriptions"
          },
          version: {
            type: "object",
            properties: {
              instance: {
                type: "string"
              }
            },
            required: [
              "instance"
            ]
          },
          links: {
            type: "array",
            items: {
              oneOf: [
                {
                  $ref: "#/definitions/link_element"
                },
                {
                  $ref: "#/definitions/icon_link_element"
                }
              ]
            }
          },
          forms: {
            type: "array",
            minItems: 1,
            items: {
              $ref: "#/definitions/form_element_root"
            }
          },
          base: {
            $ref: "#/definitions/anyUri"
          },
          securityDefinitions: {
            type: "object",
            minProperties: 1,
            additionalProperties: {
              $ref: "#/definitions/securityScheme"
            }
          },
          schemaDefinitions: {
            type: "object",
            minProperties: 1,
            additionalProperties: {
              $ref: "#/definitions/dataSchema"
            }
          },
          support: {
            $ref: "#/definitions/anyUri"
          },
          created: {
            type: "string",
            format: "date-time"
          },
          modified: {
            type: "string",
            format: "date-time"
          },
          profile: {
            oneOf: [
              {
                $ref: "#/definitions/anyUri"
              },
              {
                type: "array",
                minItems: 1,
                items: {
                  $ref: "#/definitions/anyUri"
                }
              }
            ]
          },
          security: {
            oneOf: [
              {
                type: "string"
              },
              {
                type: "array",
                minItems: 1,
                items: {
                  type: "string"
                }
              }
            ]
          },
          uriVariables: {
            type: "object",
            additionalProperties: {
              $ref: "#/definitions/dataSchema"
            }
          },
          "@type": {
            $ref: "#/definitions/type_declaration"
          },
          "@context": {
            $ref: "#/definitions/thing-context"
          }
        },
        required: [
          "title",
          "security",
          "securityDefinitions",
          "@context"
        ],
        additionalProperties: true
      };
    }
  });

  // ../core/dist/helpers.js
  var require_helpers = __commonJS({
    "../core/dist/helpers.js"(exports21) {
      "use strict";
      init_buffer2();
      var __createBinding = exports21 && exports21.__createBinding || (Object.create ? function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m4, k3);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k3];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o5[k22] = m4[k3];
      });
      var __setModuleDefault = exports21 && exports21.__setModuleDefault || (Object.create ? function(o5, v5) {
        Object.defineProperty(o5, "default", { enumerable: true, value: v5 });
      } : function(o5, v5) {
        o5["default"] = v5;
      });
      var __importStar = exports21 && exports21.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o5) {
          ownKeys = Object.getOwnPropertyNames || function(o6) {
            var ar = [];
            for (var k3 in o6) if (Object.prototype.hasOwnProperty.call(o6, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o5);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i5 = 0; i5 < k3.length; i5++) if (k3[i5] !== "default") __createBinding(result, mod, k3[i5]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      var os = __importStar((init_os(), __toCommonJS(os_exports)));
      var thing_model_1 = require_thing_model();
      var thing_description_1 = require_thing_description();
      var content_serdes_1 = require_content_serdes();
      var ajv_1 = __importDefault(require_ajv());
      var ajv_formats_1 = __importDefault(require_dist2());
      var td_json_schema_validation_json_1 = __importDefault(require_td_json_schema_validation());
      var logger_1 = require_logger();
      var { debug, error, warn } = (0, logger_1.createLoggers)("core", "helpers");
      var tdSchema = td_json_schema_validation_json_1.default;
      var ajv = new ajv_1.default({ strict: false });
      (0, ajv_formats_1.default)(ajv);
      var Helpers = class _Helpers {
        constructor(srv) {
          this.srv = srv;
        }
        static extractScheme(uri) {
          const parsed = new URL(uri);
          debug(parsed);
          if (parsed.protocol === null) {
            throw new Error(`Protocol in url "${uri}" must be valid`);
          }
          const scheme = parsed.protocol.slice(0, -1);
          debug(`Helpers found scheme '${scheme}'`);
          return scheme;
        }
        static setStaticAddress(address) {
          _Helpers.staticAddress = address;
        }
        static getAddresses() {
          const addresses = [];
          if (_Helpers.staticAddress !== void 0) {
            addresses.push(_Helpers.staticAddress);
            debug(`AddressHelper uses static ${addresses}`);
            return addresses;
          } else {
            const interfaces = os.networkInterfaces();
            for (const iface of Object.values(interfaces)) {
              iface?.forEach((entry) => {
                debug(`AddressHelper found ${entry.address}`);
                if (entry.internal === false) {
                  if (entry.family === "IPv4") {
                    addresses.push(entry.address);
                  } else if (entry.scopeid === 0) {
                    addresses.push(_Helpers.toUriLiteral(entry.address));
                  }
                }
              });
            }
            if (addresses.length === 0) {
              addresses.push("localhost");
            }
            debug(`AddressHelper identified ${addresses}`);
            return addresses;
          }
        }
        static toUriLiteral(address) {
          if (address == null) {
            error(`AddressHelper received invalid address '${address}'`);
            return "{invalid address - undefined}";
          }
          if (address.indexOf(":") !== -1) {
            address = `[${address}]`;
          }
          return address;
        }
        static generateUniqueName(name2) {
          const suffix = name2.match(/.+_([0-9]+)$/);
          if (suffix !== null) {
            return name2.slice(0, -suffix[1].length) + (1 + parseInt(suffix[1]));
          } else {
            return name2 + "_2";
          }
        }
        static toStringArray(input) {
          if (input != null) {
            if (typeof input === "string") {
              return [input];
            } else {
              return input;
            }
          } else {
            return [];
          }
        }
        static structuredClone(value) {
          return JSON.parse(JSON.stringify(value));
        }
        fetch(uri) {
          return new Promise((resolve2, reject) => {
            const client = this.srv.getClientFor(_Helpers.extractScheme(uri));
            debug(`WoTImpl fetching TD from '${uri}' with ${client}`);
            client.readResource(new thing_description_1.Form(uri, content_serdes_1.ContentSerdes.TD)).then(async (content) => {
              if (content.type !== content_serdes_1.ContentSerdes.TD && content.type !== content_serdes_1.ContentSerdes.JSON_LD) {
                warn(`WoTImpl received TD with media type '${content.type}' from ${uri}`);
              }
              const td = (await content.toBuffer()).toString("utf-8");
              try {
                const jo = JSON.parse(td);
                resolve2(jo);
              } catch (err) {
                reject(new Error(`WoTImpl fetched invalid JSON from '${uri}': ${err instanceof Error ? err.message : err}`));
              }
            }).then(async (td) => {
              await client.stop();
              return td;
            }).catch((err) => {
              reject(err);
            });
          });
        }
        static extend(first, second) {
          const result = {};
          for (const [id, value] of Object.entries(first)) {
            result[id] = value;
          }
          for (const [id, value] of Object.entries(second)) {
            if (!Object.prototype.hasOwnProperty.call(result, id)) {
              result[id] = value;
            }
          }
          return result;
        }
        static async parseInteractionOutput(response) {
          try {
            return await response.value();
          } catch (err) {
            error("parseInteractionOutput low-level stream not implemented");
            throw new Error("parseInteractionOutput low-level stream not implemented");
          }
        }
        static createExposeThingInitSchema(tdSchema2) {
          const tdSchemaCopy = _Helpers.structuredClone(tdSchema2);
          if (tdSchemaCopy.required !== void 0) {
            const reservedKeywords = [
              "title",
              "@context",
              "instance",
              "forms",
              "security",
              "href",
              "securityDefinitions"
            ];
            if (Array.isArray(tdSchemaCopy.required)) {
              const reqProps = tdSchemaCopy.required;
              tdSchemaCopy.required = reqProps.filter((n5) => !reservedKeywords.includes(n5));
            } else if (typeof tdSchemaCopy.required === "string") {
              if (reservedKeywords.indexOf(tdSchemaCopy.required) !== -1)
                delete tdSchemaCopy.required;
            }
          }
          if (tdSchemaCopy.definitions != null) {
            for (const [prop, propValue] of Object.entries(tdSchemaCopy.definitions) ?? []) {
              tdSchemaCopy.definitions[prop] = this.createExposeThingInitSchema(propValue);
            }
          }
          return tdSchemaCopy;
        }
        static validateExposedThingInit(data) {
          if (data["@type"] === "tm:ThingModel" || thing_model_1.ThingModelHelpers.isThingModel(data) === true) {
            return {
              valid: false,
              errors: "ThingModel declaration is not supported"
            };
          }
          const isValid = _Helpers.tsSchemaValidator(data);
          let errors;
          if (!isValid) {
            errors = _Helpers.tsSchemaValidator.errors?.map((o5) => o5.message).join("\n");
          }
          return {
            valid: isValid,
            errors
          };
        }
        static parseInteractionOptions(thing, ti, options) {
          if (!this.validateInteractionOptions(thing, ti, options)) {
            throw new Error(`CoreHelpers one or more uriVariables were not found under neither '${ti.title}' Thing Interaction nor '${thing.title}' Thing`);
          }
          const interactionUriVariables = ti.uriVariables ?? {};
          const thingUriVariables = thing.uriVariables ?? {};
          const uriVariables = {};
          if (options?.uriVariables) {
            const entryVariables = Object.entries(options.uriVariables);
            entryVariables.forEach((entry) => {
              if (entry[0] in interactionUriVariables) {
                uriVariables[entry[0]] = entry[1];
              } else if (entry[0] in thingUriVariables) {
                uriVariables[entry[0]] = entry[1];
              }
            });
          } else {
            options = { uriVariables: {} };
          }
          for (const [varKey, varValue] of Object.entries(thingUriVariables)) {
            if (!(varKey in uriVariables) && "default" in varValue) {
              uriVariables[varKey] = varValue.default;
            }
          }
          options.uriVariables = uriVariables;
          return options;
        }
        static validateInteractionOptions(thing, ti, options) {
          const interactionUriVariables = ti.uriVariables ?? {};
          const thingUriVariables = thing.uriVariables ?? {};
          if (options?.uriVariables) {
            const entryVariables = Object.entries(options.uriVariables);
            for (let i5 = 0; i5 < entryVariables.length; i5++) {
              const entryVariable = entryVariables[i5];
              if (!(entryVariable[0] in interactionUriVariables) && !(entryVariable[0] in thingUriVariables)) {
                return false;
              }
            }
          }
          return true;
        }
        static parseUrlParameters(url, globalUriVariables = {}, uriVariables = {}) {
          const params = {};
          if (url == null || uriVariables == null && globalUriVariables == null) {
            return params;
          }
          const queryparams = url.split("?")[1];
          if (queryparams == null) {
            return params;
          }
          const queries = queryparams.indexOf("&") !== -1 ? queryparams.split("&") : [queryparams];
          queries.forEach((indexQuery) => {
            const indexPair = indexQuery.split("=");
            const queryKey = decodeURIComponent(indexPair[0]);
            const queryValue = decodeURIComponent(indexPair.length > 1 ? indexPair[1] : "");
            if (uriVariables != null && uriVariables[queryKey] != null) {
              if (uriVariables[queryKey].type === "integer" || uriVariables[queryKey].type === "number") {
                params[queryKey] = +queryValue;
              } else {
                params[queryKey] = queryValue;
              }
            } else if (globalUriVariables != null && globalUriVariables[queryKey] != null) {
              if (globalUriVariables[queryKey].type === "integer" || globalUriVariables[queryKey].type === "number") {
                params[queryKey] = +queryValue;
              } else {
                params[queryKey] = queryValue;
              }
            }
          });
          return params;
        }
        static updateInteractionNameWithUriVariablePattern(interactionName, affordanceUriVariables = {}, thingUriVariables = {}) {
          const encodedInteractionName = encodeURIComponent(interactionName);
          const uriVariables = [...Object.keys(affordanceUriVariables), ...Object.keys(thingUriVariables)];
          if (uriVariables.length === 0) {
            return encodedInteractionName;
          }
          const pattern = uriVariables.map(encodeURIComponent).join(",");
          return encodedInteractionName + "{?" + pattern + "}";
        }
      };
      Helpers.tsSchemaValidator = ajv.compile(Helpers.createExposeThingInitSchema(tdSchema));
      Helpers.staticAddress = void 0;
      exports21.default = Helpers;
    }
  });

  // ../core/dist/errors.js
  var require_errors2 = __commonJS({
    "../core/dist/errors.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.DataSchemaError = exports21.NotSupportedError = exports21.NotReadableError = void 0;
      var NotReadableError = class _NotReadableError extends Error {
        constructor(message) {
          super(message);
          Object.setPrototypeOf(this, _NotReadableError.prototype);
        }
      };
      exports21.NotReadableError = NotReadableError;
      var NotSupportedError = class _NotSupportedError extends Error {
        constructor(message) {
          super(message);
          Object.setPrototypeOf(this, _NotSupportedError.prototype);
        }
      };
      exports21.NotSupportedError = NotSupportedError;
      var DataSchemaError = class extends Error {
        constructor(message, value) {
          super(message);
          this.value = value;
          Object.setPrototypeOf(this, NotSupportedError.prototype);
        }
      };
      exports21.DataSchemaError = DataSchemaError;
    }
  });

  // ../core/dist/interaction-output.js
  var require_interaction_output = __commonJS({
    "../core/dist/interaction-output.js"(exports21) {
      "use strict";
      init_buffer2();
      var __createBinding = exports21 && exports21.__createBinding || (Object.create ? function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m4, k3);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k3];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o5[k22] = m4[k3];
      });
      var __setModuleDefault = exports21 && exports21.__setModuleDefault || (Object.create ? function(o5, v5) {
        Object.defineProperty(o5, "default", { enumerable: true, value: v5 });
      } : function(o5, v5) {
        o5["default"] = v5;
      });
      var __importStar = exports21 && exports21.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o5) {
          ownKeys = Object.getOwnPropertyNames || function(o6) {
            var ar = [];
            for (var k3 in o6) if (Object.prototype.hasOwnProperty.call(o6, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o5);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i5 = 0; i5 < k3.length; i5++) if (k3[i5] !== "default") __createBinding(result, mod, k3[i5]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      var __classPrivateFieldGet = exports21 && exports21.__classPrivateFieldGet || function(receiver, state, kind, f5) {
        if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
      };
      var __classPrivateFieldSet = exports21 && exports21.__classPrivateFieldSet || function(receiver, state, value, kind, f5) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
      };
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _InteractionOutput_content;
      var _InteractionOutput_value;
      var _InteractionOutput_buffer;
      var _InteractionOutput_stream;
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.InteractionOutput = void 0;
      var util = __importStar((init_util(), __toCommonJS(util_exports)));
      var content_serdes_1 = require_content_serdes();
      var core_1 = require_core3();
      var errors_1 = require_errors2();
      var ajv_1 = __importDefault(require_ajv());
      var ajv_formats_1 = __importDefault(require_dist2());
      var logger_1 = require_logger();
      var { debug, warn } = (0, logger_1.createLoggers)("core", "interaction-output");
      var ajv = new ajv_1.default({ strict: false, addUsedSchema: false });
      (0, ajv_formats_1.default)(ajv);
      var InteractionOutput = class {
        get data() {
          if (__classPrivateFieldGet(this, _InteractionOutput_stream, "f")) {
            return __classPrivateFieldGet(this, _InteractionOutput_stream, "f");
          }
          if (this.dataUsed) {
            throw new Error("Can't read the stream once it has been already used");
          }
          this.dataUsed = true;
          return __classPrivateFieldSet(this, _InteractionOutput_stream, core_1.ProtocolHelpers.toWoTStream(__classPrivateFieldGet(this, _InteractionOutput_content, "f").body), "f");
        }
        constructor(content, form, schema, options = { ignoreValidation: false }) {
          _InteractionOutput_content.set(this, void 0);
          _InteractionOutput_value.set(this, void 0);
          _InteractionOutput_buffer.set(this, void 0);
          _InteractionOutput_stream.set(this, void 0);
          __classPrivateFieldSet(this, _InteractionOutput_content, content, "f");
          this.form = form;
          this.schema = schema;
          this.ignoreValidation = options.ignoreValidation ?? false;
          this.dataUsed = false;
        }
        async arrayBuffer() {
          if (__classPrivateFieldGet(this, _InteractionOutput_buffer, "f")) {
            return __classPrivateFieldGet(this, _InteractionOutput_buffer, "f");
          }
          if (this.dataUsed) {
            throw new Error("Can't read the stream once it has been already used");
          }
          const data = await __classPrivateFieldGet(this, _InteractionOutput_content, "f").toBuffer();
          this.dataUsed = true;
          __classPrivateFieldSet(this, _InteractionOutput_buffer, data, "f");
          return data;
        }
        async value() {
          if (this.schema == null) {
            warn(`No schema defined. Hence undefined is reported for value() function. If you are invoking an action with no output that is on purpose, otherwise consider using arrayBuffer().`);
            return void 0;
          }
          if (__classPrivateFieldGet(this, _InteractionOutput_value, "f") !== void 0) {
            return __classPrivateFieldGet(this, _InteractionOutput_value, "f");
          }
          if (this.dataUsed) {
            throw new errors_1.NotReadableError("Can't read the stream once it has been already used");
          }
          if (this.form == null) {
            throw new errors_1.NotReadableError("No form defined");
          }
          if (this.schema.const == null && this.schema.enum == null && this.schema.oneOf == null && this.schema.type == null) {
            throw new errors_1.NotReadableError("No schema type defined");
          }
          if (!content_serdes_1.ContentSerdes.get().isSupported(__classPrivateFieldGet(this, _InteractionOutput_content, "f").type)) {
            const message = `Content type ${__classPrivateFieldGet(this, _InteractionOutput_content, "f").type} not supported`;
            throw new errors_1.NotSupportedError(message);
          }
          const bytes = await __classPrivateFieldGet(this, _InteractionOutput_content, "f").toBuffer();
          this.dataUsed = true;
          __classPrivateFieldSet(this, _InteractionOutput_buffer, bytes, "f");
          const json = content_serdes_1.ContentSerdes.get().contentToValue({ type: __classPrivateFieldGet(this, _InteractionOutput_content, "f").type, body: bytes }, this.schema);
          const validate = ajv.compile(this.schema);
          if (!this.ignoreValidation && !validate(json)) {
            debug(`schema = ${util.inspect(this.schema, { depth: 10, colors: true })}`);
            debug(`value: ${json}`);
            debug(`Error: ${validate.errors}`);
            throw new errors_1.DataSchemaError("Invalid value according to DataSchema", json);
          }
          __classPrivateFieldSet(this, _InteractionOutput_value, json, "f");
          return json;
        }
      };
      exports21.InteractionOutput = InteractionOutput;
      _InteractionOutput_content = /* @__PURE__ */ new WeakMap(), _InteractionOutput_value = /* @__PURE__ */ new WeakMap(), _InteractionOutput_buffer = /* @__PURE__ */ new WeakMap(), _InteractionOutput_stream = /* @__PURE__ */ new WeakMap();
    }
  });

  // ../core/dist/protocol-listener-registry.js
  var require_protocol_listener_registry = __commonJS({
    "../core/dist/protocol-listener-registry.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      var content_serdes_1 = __importDefault(require_content_serdes());
      var ProtocolListenerRegistry = class _ProtocolListenerRegistry {
        constructor() {
          this.listeners = /* @__PURE__ */ new Map();
        }
        register(affordance, formIndex, listener) {
          if (affordance.forms[formIndex] == null) {
            throw new Error("Can't register the listener for affordance with formIndex. The affordance does not contain the form");
          }
          let formMap = this.listeners.get(affordance);
          if (!formMap) {
            formMap = /* @__PURE__ */ new Map();
            this.listeners.set(affordance, formMap);
          }
          let listeners2 = formMap.get(formIndex);
          if (!listeners2) {
            listeners2 = [];
            formMap.set(formIndex, listeners2);
          }
          listeners2.push(listener);
        }
        unregister(affordance, formIndex, listener) {
          const formMap = this.listeners.get(affordance);
          if (!formMap) {
            throw new Error("Not found");
          }
          const listeners2 = formMap.get(formIndex);
          if (!listeners2) {
            throw new Error("Form not found");
          }
          const index = listeners2.indexOf(listener);
          if (index < 0) {
            throw new Error("Form not found");
          }
          listeners2.splice(index, 1);
        }
        unregisterAll() {
          this.listeners.clear();
        }
        notify(affordance, data, schema, formIndex) {
          const formMap = this.listeners.get(affordance) ?? _ProtocolListenerRegistry.EMPTY_MAP;
          if (formIndex !== void 0) {
            const listeners2 = formMap.get(formIndex);
            if (listeners2) {
              const contentType = affordance.forms[formIndex].contentType;
              const content = content_serdes_1.default.valueToContent(data, schema, contentType);
              listeners2.forEach((listener) => listener(content));
              return;
            }
          }
          for (const [index, value] of formMap) {
            const contentType = affordance.forms[index].contentType;
            const content = content_serdes_1.default.valueToContent(data, schema, contentType);
            value.forEach((listener) => listener(content));
          }
        }
      };
      ProtocolListenerRegistry.EMPTY_MAP = /* @__PURE__ */ new Map();
      exports21.default = ProtocolListenerRegistry;
    }
  });

  // ../core/dist/exposed-thing.js
  var require_exposed_thing = __commonJS({
    "../core/dist/exposed-thing.js"(exports21) {
      "use strict";
      init_buffer2();
      var __createBinding = exports21 && exports21.__createBinding || (Object.create ? function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m4, k3);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k3];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o5[k22] = m4[k3];
      });
      var __setModuleDefault = exports21 && exports21.__setModuleDefault || (Object.create ? function(o5, v5) {
        Object.defineProperty(o5, "default", { enumerable: true, value: v5 });
      } : function(o5, v5) {
        o5["default"] = v5;
      });
      var __importStar = exports21 && exports21.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o5) {
          ownKeys = Object.getOwnPropertyNames || function(o6) {
            var ar = [];
            for (var k3 in o6) if (Object.prototype.hasOwnProperty.call(o6, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o5);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i5 = 0; i5 < k3.length; i5++) if (k3[i5] !== "default") __createBinding(result, mod, k3[i5]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      var __classPrivateFieldSet = exports21 && exports21.__classPrivateFieldSet || function(receiver, state, value, kind, f5) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = exports21 && exports21.__classPrivateFieldGet || function(receiver, state, kind, f5) {
        if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
      };
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _ExposedThing_propertyHandlers;
      var _ExposedThing_actionHandlers;
      var _ExposedThing_eventHandlers;
      var _ExposedThing_propertyListeners;
      var _ExposedThing_eventListeners;
      var _ExposedThing_servient;
      Object.defineProperty(exports21, "__esModule", { value: true });
      var TD = __importStar(require_thing_description());
      var serdes_1 = require_serdes();
      var helpers_1 = __importDefault(require_helpers());
      var interaction_output_1 = require_interaction_output();
      var stream_1 = (init_stream(), __toCommonJS(stream_exports));
      var protocol_helpers_1 = __importDefault(require_protocol_helpers());
      var web_streams_polyfill_1 = require_ponyfill();
      var core_1 = require_core3();
      var content_serdes_1 = __importDefault(require_content_serdes());
      var protocol_listener_registry_1 = __importDefault(require_protocol_listener_registry());
      var logger_1 = require_logger();
      var { debug } = (0, logger_1.createLoggers)("core", "exposed-thing");
      var ExposedThing = class extends TD.Thing {
        constructor(servient, thingModel = {}) {
          super();
          _ExposedThing_propertyHandlers.set(this, /* @__PURE__ */ new Map());
          _ExposedThing_actionHandlers.set(this, /* @__PURE__ */ new Map());
          _ExposedThing_eventHandlers.set(this, /* @__PURE__ */ new Map());
          _ExposedThing_propertyListeners.set(this, new protocol_listener_registry_1.default());
          _ExposedThing_eventListeners.set(this, new protocol_listener_registry_1.default());
          _ExposedThing_servient.set(this, void 0);
          __classPrivateFieldSet(this, _ExposedThing_servient, servient, "f");
          this.id = thingModel.id ?? "";
          this.title = thingModel.title ?? "";
          this.security = "";
          this.securityDefinitions = {};
          this.properties = {};
          this.actions = {};
          this.events = {};
          const deepClonedModel = helpers_1.default.structuredClone(thingModel);
          Object.assign(this, deepClonedModel);
          (0, serdes_1.setContextLanguage)(this, TD.DEFAULT_CONTEXT_LANGUAGE, false);
        }
        getThingDescription() {
          return JSON.parse((0, serdes_1.serializeTD)(this));
        }
        emitEvent(name2, data) {
          if (this.events[name2] != null) {
            const eventAffordance = this.events[name2];
            __classPrivateFieldGet(this, _ExposedThing_eventListeners, "f").notify(eventAffordance, data, eventAffordance.data);
          } else {
            throw new Error("NotFoundError for event '" + name2 + "'");
          }
        }
        async emitPropertyChange(name2) {
          if (this.properties[name2] != null) {
            const property = this.properties[name2];
            const readHandler = __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").get(name2)?.readHandler;
            if (!readHandler) {
              throw new Error("Can't read property readHandler is not defined. Did you forget to register a readHandler?");
            }
            const data = await readHandler();
            __classPrivateFieldGet(this, _ExposedThing_propertyListeners, "f").notify(property, data, property);
          } else {
            throw new Error("NotFoundError for property '" + name2 + "'");
          }
        }
        expose() {
          debug(`ExposedThing '${this.title}' exposing all Interactions and TD`);
          return new Promise((resolve2, reject) => {
            __classPrivateFieldGet(this, _ExposedThing_servient, "f").expose(this).then(() => {
              resolve2();
            }).catch((err) => reject(err));
          });
        }
        async destroy() {
          debug(`ExposedThing '${this.title}' destroying the thing and its interactions`);
          await __classPrivateFieldGet(this, _ExposedThing_servient, "f").destroyThing(this.id);
          __classPrivateFieldGet(this, _ExposedThing_eventListeners, "f").unregisterAll();
          __classPrivateFieldGet(this, _ExposedThing_propertyListeners, "f").unregisterAll();
          __classPrivateFieldGet(this, _ExposedThing_eventHandlers, "f").clear();
          __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").clear();
          __classPrivateFieldGet(this, _ExposedThing_eventHandlers, "f").clear();
        }
        setPropertyReadHandler(propertyName, handler) {
          debug(`ExposedThing '${this.title}' setting read handler for '${propertyName}'`);
          if (this.properties[propertyName] != null) {
            if (this.properties[propertyName].writeOnly === true) {
              throw new Error(`ExposedThing '${this.title}' cannot set read handler for property '${propertyName}' due to writeOnly flag`);
            } else {
              let propertyHandler = __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").get(propertyName);
              if (propertyHandler) {
                propertyHandler.readHandler = handler;
              } else {
                propertyHandler = { readHandler: handler };
              }
              __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").set(propertyName, propertyHandler);
            }
          } else {
            throw new Error(`ExposedThing '${this.title}' has no Property '${propertyName}'`);
          }
          return this;
        }
        setPropertyWriteHandler(propertyName, handler) {
          debug(`ExposedThing '${this.title}' setting write handler for '${propertyName}'`);
          if (this.properties[propertyName] != null) {
            if (this.properties[propertyName].readOnly === true) {
              throw new Error(`ExposedThing '${this.title}' cannot set write handler for property '${propertyName}' due to readOnly flag`);
            } else {
              let propertyHandler = __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").get(propertyName);
              if (propertyHandler) {
                propertyHandler.writeHandler = handler;
              } else {
                propertyHandler = { writeHandler: handler };
              }
              __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").set(propertyName, propertyHandler);
            }
          } else {
            throw new Error(`ExposedThing '${this.title}' has no Property '${propertyName}'`);
          }
          return this;
        }
        setPropertyObserveHandler(name2, handler) {
          debug(`ExposedThing '${this.title}' setting property observe handler for '${name2}'`);
          if (this.properties[name2] != null) {
            if (this.properties[name2].observable !== true) {
              throw new Error(`ExposedThing '${this.title}' cannot set observe handler for property '${name2}' since the observable flag is set to false`);
            } else {
              let propertyHandler = __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").get(name2);
              if (propertyHandler) {
                propertyHandler.observeHandler = handler;
              } else {
                propertyHandler = { observeHandler: handler };
              }
              __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").set(name2, propertyHandler);
            }
          } else {
            throw new Error(`ExposedThing '${this.title}' has no Property '${name2}'`);
          }
          return this;
        }
        setPropertyUnobserveHandler(name2, handler) {
          debug(`ExposedThing '${this.title}' setting property unobserve handler for '${name2}'`);
          if (this.properties[name2] != null) {
            if (this.properties[name2].observable !== true) {
              throw new Error(`ExposedThing '${this.title}' cannot set unobserve handler for property '${name2}' due to missing observable flag`);
            } else {
              let propertyHandler = __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").get(name2);
              if (propertyHandler) {
                propertyHandler.unobserveHandler = handler;
              } else {
                propertyHandler = { unobserveHandler: handler };
              }
              __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").set(name2, propertyHandler);
            }
          } else {
            throw new Error(`ExposedThing '${this.title}' has no Property '${name2}'`);
          }
          return this;
        }
        setActionHandler(actionName, handler) {
          debug(`ExposedThing '${this.title}' setting action handler for '${actionName}'`);
          if (this.actions[actionName] != null) {
            __classPrivateFieldGet(this, _ExposedThing_actionHandlers, "f").set(actionName, handler);
          } else {
            throw new Error(`ExposedThing '${this.title}' has no Action '${actionName}'`);
          }
          return this;
        }
        setEventSubscribeHandler(name2, handler) {
          debug(`ExposedThing '${this.title}' setting event subscribe handler for '${name2}'`);
          if (this.events[name2] != null) {
            let eventHandler = __classPrivateFieldGet(this, _ExposedThing_eventHandlers, "f").get(name2);
            if (eventHandler) {
              eventHandler.subscribe = handler;
            } else {
              eventHandler = { subscribe: handler };
            }
            __classPrivateFieldGet(this, _ExposedThing_eventHandlers, "f").set(name2, eventHandler);
          } else {
            throw new Error(`ExposedThing '${this.title}' has no Event '${name2}'`);
          }
          return this;
        }
        setEventUnsubscribeHandler(name2, handler) {
          debug(`ExposedThing '${this.title}' setting event unsubscribe handler for '${name2}'`);
          if (this.events[name2] != null) {
            let eventHandler = __classPrivateFieldGet(this, _ExposedThing_eventHandlers, "f").get(name2);
            if (eventHandler) {
              eventHandler.unsubscribe = handler;
            } else {
              eventHandler = { unsubscribe: handler };
            }
            __classPrivateFieldGet(this, _ExposedThing_eventHandlers, "f").set(name2, eventHandler);
          } else {
            throw new Error(`ExposedThing '${this.title}' has no Event '${name2}'`);
          }
          return this;
        }
        async handleInvokeAction(name2, inputContent, options) {
          if (this.actions[name2] != null) {
            debug(`ExposedThing '${this.title}' has Action state of '${name2}'`);
            const handler = __classPrivateFieldGet(this, _ExposedThing_actionHandlers, "f").get(name2);
            if (handler != null) {
              debug(`ExposedThing '${this.title}' calls registered handler for Action '${name2}'`);
              helpers_1.default.validateInteractionOptions(this, this.actions[name2], options);
              const form = this.actions[name2].forms[options.formIndex] ?? { contentType: "application/json" };
              const result = await handler(new interaction_output_1.InteractionOutput(inputContent, form, this.actions[name2].input), options);
              if (result !== void 0) {
                return content_serdes_1.default.valueToContent(result, this.actions[name2].output, form.contentType);
              }
            } else {
              throw new Error(`ExposedThing '${this.title}' has no handler for Action '${name2}'`);
            }
          } else {
            throw new Error(`ExposedThing '${this.title}', no action found for '${name2}'`);
          }
        }
        async handleReadProperty(propertyName, options) {
          if (this.properties[propertyName] != null) {
            debug(`ExposedThing '${this.title}' has Action state of '${propertyName}'`);
            const readHandler = __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").get(propertyName)?.readHandler;
            if (readHandler != null) {
              debug(`ExposedThing '${this.title}' calls registered readHandler for Property '${propertyName}'`);
              helpers_1.default.validateInteractionOptions(this, this.properties[propertyName], options);
              const result = await readHandler(options);
              const form = this.properties[propertyName]?.forms[options.formIndex] ?? {
                contentType: "application/json"
              };
              return content_serdes_1.default.valueToContent(result, this.properties[propertyName], form?.contentType ?? "application/json");
            } else {
              throw new Error(`ExposedThing '${this.title}' has no readHandler for Property '${propertyName}'`);
            }
          } else {
            throw new Error(`ExposedThing '${this.title}', no property found for '${propertyName}'`);
          }
        }
        async _handleReadProperties(propertyNames, options) {
          try {
            const output = /* @__PURE__ */ new Map();
            for (const propertyName of propertyNames) {
              const form = this.properties[propertyName].forms.find((form2) => form2.contentType === core_1.ContentSerdes.DEFAULT || form2.contentType == null);
              if (!form) {
                continue;
              }
              const contentResponse = await this.handleReadProperty(propertyName, options);
              output.set(propertyName, contentResponse);
            }
            return output;
          } catch (error) {
            throw new Error(`ConsumedThing '${this.title}', failed to read properties: ${propertyNames}.
 Error: ${error}`);
          }
        }
        async handleReadAllProperties(options) {
          const propertyNames = Object.keys(this.properties);
          return await this._handleReadProperties(propertyNames, options);
        }
        async handleReadMultipleProperties(propertyNames, options) {
          return await this._handleReadProperties(propertyNames, options);
        }
        async handleWriteProperty(propertyName, inputContent, options) {
          if (this.properties[propertyName] != null) {
            if (this.properties[propertyName].readOnly === true) {
              throw new Error(`ExposedThing '${this.title}', property '${propertyName}' is readOnly`);
            }
            helpers_1.default.validateInteractionOptions(this, this.properties[propertyName], options);
            const writeHandler = __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").get(propertyName)?.writeHandler;
            const form = this.properties[propertyName]?.forms[options.formIndex] ?? {};
            if (writeHandler != null) {
              await writeHandler(new interaction_output_1.InteractionOutput(inputContent, form, this.properties[propertyName]), options);
            } else {
              throw new Error(`ExposedThing '${this.title}' has no writeHandler for Property '${propertyName}'`);
            }
          } else {
            throw new Error(`ExposedThing '${this.title}', no property found for '${propertyName}'`);
          }
        }
        async handleWriteMultipleProperties(valueMap, options) {
          const promises2 = [];
          for (const [propertyName, property] of Object.entries(valueMap)) {
            const form = this.properties[propertyName].forms.find((form2) => form2.contentType === "application/json" || form2.contentType == null);
            if (form == null) {
              continue;
            }
            promises2.push(this.handleWriteProperty(propertyName, property, options));
          }
          try {
            await Promise.all(promises2);
          } catch (error) {
            throw new Error(`ExposedThing '${this.title}', failed to write multiple properties. ${error.message}`);
          }
        }
        async handleSubscribeEvent(name2, listener, options) {
          if (this.events[name2] != null) {
            helpers_1.default.validateInteractionOptions(this, this.events[name2], options);
            const formIndex = protocol_helpers_1.default.getFormIndexForOperation(this.events[name2], "event", "subscribeevent", options.formIndex);
            if (formIndex !== -1) {
              __classPrivateFieldGet(this, _ExposedThing_eventListeners, "f").register(this.events[name2], formIndex, listener);
              debug(`ExposedThing '${this.title}' subscribes to event '${name2}'`);
            } else {
              throw new Error(`ExposedThing '${this.title}', no property listener from found for '${name2}' with form index '${options.formIndex}'`);
            }
            const subscribe = __classPrivateFieldGet(this, _ExposedThing_eventHandlers, "f").get(name2)?.subscribe;
            if (subscribe) {
              await subscribe(options);
            }
            debug(`ExposedThing '${this.title}' subscribes to event '${name2}'`);
          } else {
            throw new Error(`ExposedThing '${this.title}', no event found for '${name2}'`);
          }
        }
        handleUnsubscribeEvent(name2, listener, options) {
          if (this.events[name2] != null) {
            helpers_1.default.validateInteractionOptions(this, this.events[name2], options);
            const formIndex = protocol_helpers_1.default.getFormIndexForOperation(this.events[name2], "event", "unsubscribeevent", options.formIndex);
            if (formIndex !== -1) {
              __classPrivateFieldGet(this, _ExposedThing_eventListeners, "f").unregister(this.events[name2], formIndex, listener);
            } else {
              throw new Error(`ExposedThing '${this.title}', no event listener from found for '${name2}' with form index '${options.formIndex}'`);
            }
            const unsubscribe = __classPrivateFieldGet(this, _ExposedThing_eventHandlers, "f").get(name2)?.unsubscribe;
            if (unsubscribe) {
              unsubscribe(options);
            }
            debug(`ExposedThing '${this.title}' unsubscribes from event '${name2}'`);
          } else {
            throw new Error(`ExposedThing '${this.title}', no event found for '${name2}'`);
          }
        }
        async handleObserveProperty(name2, listener, options) {
          if (this.properties[name2] != null) {
            helpers_1.default.validateInteractionOptions(this, this.properties[name2], options);
            const formIndex = protocol_helpers_1.default.getFormIndexForOperation(this.properties[name2], "property", "observeproperty", options.formIndex);
            if (formIndex !== -1) {
              __classPrivateFieldGet(this, _ExposedThing_propertyListeners, "f").register(this.properties[name2], formIndex, listener);
              debug(`ExposedThing '${this.title}' subscribes to property '${name2}'`);
            } else {
              throw new Error(`ExposedThing '${this.title}', no property listener from found for '${name2}' with form index '${options.formIndex}'`);
            }
            const observeHandler = __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").get(name2)?.observeHandler;
            if (observeHandler) {
              await observeHandler(options);
            }
          } else {
            throw new Error(`ExposedThing '${this.title}', no property found for '${name2}'`);
          }
        }
        handleUnobserveProperty(name2, listener, options) {
          if (this.properties[name2] != null) {
            helpers_1.default.validateInteractionOptions(this, this.properties[name2], options);
            const formIndex = protocol_helpers_1.default.getFormIndexForOperation(this.properties[name2], "property", "unobserveproperty", options.formIndex);
            if (formIndex !== -1) {
              __classPrivateFieldGet(this, _ExposedThing_propertyListeners, "f").unregister(this.properties[name2], formIndex, listener);
            } else {
              throw new Error(`ExposedThing '${this.title}', no property listener from found for '${name2}' with form index '${options.formIndex}'`);
            }
            const unobserveHandler = __classPrivateFieldGet(this, _ExposedThing_propertyHandlers, "f").get(name2)?.unobserveHandler;
            if (unobserveHandler) {
              unobserveHandler(options);
            }
          } else {
            throw new Error(`ExposedThing '${this.title}', no property found for '${name2}'`);
          }
        }
        static interactionInputToReadable(input) {
          let body;
          if (typeof ReadableStream !== "undefined" && input instanceof ReadableStream) {
            body = protocol_helpers_1.default.toNodeStream(input);
          } else if (input instanceof web_streams_polyfill_1.ReadableStream) {
            body = protocol_helpers_1.default.toNodeStream(input);
          } else if (Array.isArray(input) || typeof input === "object") {
            body = stream_1.Readable.from(Buffer2.from(JSON.stringify(input), "utf-8"));
          } else {
            body = stream_1.Readable.from(Buffer2.from(input.toString(), "utf-8"));
          }
          return body;
        }
      };
      _ExposedThing_propertyHandlers = /* @__PURE__ */ new WeakMap(), _ExposedThing_actionHandlers = /* @__PURE__ */ new WeakMap(), _ExposedThing_eventHandlers = /* @__PURE__ */ new WeakMap(), _ExposedThing_propertyListeners = /* @__PURE__ */ new WeakMap(), _ExposedThing_eventListeners = /* @__PURE__ */ new WeakMap(), _ExposedThing_servient = /* @__PURE__ */ new WeakMap();
      exports21.default = ExposedThing;
    }
  });

  // ../../node_modules/content-type/index.js
  var require_content_type = __commonJS({
    "../../node_modules/content-type/index.js"(exports21) {
      "use strict";
      init_buffer2();
      var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
      var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
      var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
      var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
      var QUOTE_REGEXP = /([\\"])/g;
      var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
      exports21.format = format3;
      exports21.parse = parse3;
      function format3(obj) {
        if (!obj || typeof obj !== "object") {
          throw new TypeError("argument obj is required");
        }
        var parameters = obj.parameters;
        var type2 = obj.type;
        if (!type2 || !TYPE_REGEXP.test(type2)) {
          throw new TypeError("invalid type");
        }
        var string = type2;
        if (parameters && typeof parameters === "object") {
          var param;
          var params = Object.keys(parameters).sort();
          for (var i5 = 0; i5 < params.length; i5++) {
            param = params[i5];
            if (!TOKEN_REGEXP.test(param)) {
              throw new TypeError("invalid parameter name");
            }
            string += "; " + param + "=" + qstring(parameters[param]);
          }
        }
        return string;
      }
      function parse3(string) {
        if (!string) {
          throw new TypeError("argument string is required");
        }
        var header = typeof string === "object" ? getcontenttype(string) : string;
        if (typeof header !== "string") {
          throw new TypeError("argument string is required to be a string");
        }
        var index = header.indexOf(";");
        var type2 = index !== -1 ? header.slice(0, index).trim() : header.trim();
        if (!TYPE_REGEXP.test(type2)) {
          throw new TypeError("invalid media type");
        }
        var obj = new ContentType(type2.toLowerCase());
        if (index !== -1) {
          var key;
          var match;
          var value;
          PARAM_REGEXP.lastIndex = index;
          while (match = PARAM_REGEXP.exec(header)) {
            if (match.index !== index) {
              throw new TypeError("invalid parameter format");
            }
            index += match[0].length;
            key = match[1].toLowerCase();
            value = match[2];
            if (value.charCodeAt(0) === 34) {
              value = value.slice(1, -1);
              if (value.indexOf("\\") !== -1) {
                value = value.replace(QESC_REGEXP, "$1");
              }
            }
            obj.parameters[key] = value;
          }
          if (index !== header.length) {
            throw new TypeError("invalid parameter format");
          }
        }
        return obj;
      }
      function getcontenttype(obj) {
        var header;
        if (typeof obj.getHeader === "function") {
          header = obj.getHeader("content-type");
        } else if (typeof obj.headers === "object") {
          header = obj.headers && obj.headers["content-type"];
        }
        if (typeof header !== "string") {
          throw new TypeError("content-type header is missing from object");
        }
        return header;
      }
      function qstring(val) {
        var str = String(val);
        if (TOKEN_REGEXP.test(str)) {
          return str;
        }
        if (str.length > 0 && !TEXT_REGEXP.test(str)) {
          throw new TypeError("invalid parameter value");
        }
        return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
      }
      function ContentType(type2) {
        this.parameters = /* @__PURE__ */ Object.create(null);
        this.type = type2;
      }
    }
  });

  // ../../node_modules/uritemplate/bin/uritemplate.js
  var require_uritemplate = __commonJS({
    "../../node_modules/uritemplate/bin/uritemplate.js"(exports21, module) {
      init_buffer2();
      (function(exportCallback) {
        "use strict";
        var UriTemplateError = function() {
          function UriTemplateError2(options) {
            this.options = options;
          }
          UriTemplateError2.prototype.toString = function() {
            if (JSON && JSON.stringify) {
              return JSON.stringify(this.options);
            } else {
              return this.options;
            }
          };
          return UriTemplateError2;
        }();
        var objectHelper = /* @__PURE__ */ function() {
          function isArray2(value) {
            return Object.prototype.toString.apply(value) === "[object Array]";
          }
          function isString2(value) {
            return Object.prototype.toString.apply(value) === "[object String]";
          }
          function isNumber2(value) {
            return Object.prototype.toString.apply(value) === "[object Number]";
          }
          function isBoolean2(value) {
            return Object.prototype.toString.apply(value) === "[object Boolean]";
          }
          function join(arr, separator) {
            var result = "", first = true, index;
            for (index = 0; index < arr.length; index += 1) {
              if (first) {
                first = false;
              } else {
                result += separator;
              }
              result += arr[index];
            }
            return result;
          }
          function map(arr, mapper) {
            var result = [], index = 0;
            for (; index < arr.length; index += 1) {
              result.push(mapper(arr[index]));
            }
            return result;
          }
          function filter(arr, predicate) {
            var result = [], index = 0;
            for (; index < arr.length; index += 1) {
              if (predicate(arr[index])) {
                result.push(arr[index]);
              }
            }
            return result;
          }
          function deepFreezeUsingObjectFreeze(object) {
            if (typeof object !== "object" || object === null) {
              return object;
            }
            Object.freeze(object);
            var property, propertyName;
            for (propertyName in object) {
              if (object.hasOwnProperty(propertyName)) {
                property = object[propertyName];
                if (typeof property === "object") {
                  deepFreeze(property);
                }
              }
            }
            return object;
          }
          function deepFreeze(object) {
            if (typeof Object.freeze === "function") {
              return deepFreezeUsingObjectFreeze(object);
            }
            return object;
          }
          return {
            isArray: isArray2,
            isString: isString2,
            isNumber: isNumber2,
            isBoolean: isBoolean2,
            join,
            map,
            filter,
            deepFreeze
          };
        }();
        var charHelper = /* @__PURE__ */ function() {
          function isAlpha(chr) {
            return chr >= "a" && chr <= "z" || chr >= "A" && chr <= "Z";
          }
          function isDigit(chr) {
            return chr >= "0" && chr <= "9";
          }
          function isHexDigit(chr) {
            return isDigit(chr) || chr >= "a" && chr <= "f" || chr >= "A" && chr <= "F";
          }
          return {
            isAlpha,
            isDigit,
            isHexDigit
          };
        }();
        var pctEncoder = /* @__PURE__ */ function() {
          var utf8 = {
            encode: function(chr) {
              return unescape(encodeURIComponent(chr));
            },
            numBytes: function(firstCharCode) {
              if (firstCharCode <= 127) {
                return 1;
              } else if (194 <= firstCharCode && firstCharCode <= 223) {
                return 2;
              } else if (224 <= firstCharCode && firstCharCode <= 239) {
                return 3;
              } else if (240 <= firstCharCode && firstCharCode <= 244) {
                return 4;
              }
              return 0;
            },
            isValidFollowingCharCode: function(charCode) {
              return 128 <= charCode && charCode <= 191;
            }
          };
          function encodeCharacter(chr) {
            var result = "", octets = utf8.encode(chr), octet, index;
            for (index = 0; index < octets.length; index += 1) {
              octet = octets.charCodeAt(index);
              result += "%" + (octet < 16 ? "0" : "") + octet.toString(16).toUpperCase();
            }
            return result;
          }
          function isPercentDigitDigit(text, start) {
            return text.charAt(start) === "%" && charHelper.isHexDigit(text.charAt(start + 1)) && charHelper.isHexDigit(text.charAt(start + 2));
          }
          function parseHex2(text, start) {
            return parseInt(text.substr(start, 2), 16);
          }
          function isPctEncoded(chr) {
            if (!isPercentDigitDigit(chr, 0)) {
              return false;
            }
            var firstCharCode = parseHex2(chr, 1);
            var numBytes = utf8.numBytes(firstCharCode);
            if (numBytes === 0) {
              return false;
            }
            for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {
              if (!isPercentDigitDigit(chr, 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(chr, 3 * byteNumber + 1))) {
                return false;
              }
            }
            return true;
          }
          function pctCharAt(text, startIndex) {
            var chr = text.charAt(startIndex);
            if (!isPercentDigitDigit(text, startIndex)) {
              return chr;
            }
            var utf8CharCode = parseHex2(text, startIndex + 1);
            var numBytes = utf8.numBytes(utf8CharCode);
            if (numBytes === 0) {
              return chr;
            }
            for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {
              if (!isPercentDigitDigit(text, startIndex + 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(text, startIndex + 3 * byteNumber + 1))) {
                return chr;
              }
            }
            return text.substr(startIndex, 3 * numBytes);
          }
          return {
            encodeCharacter,
            isPctEncoded,
            pctCharAt
          };
        }();
        var rfcCharHelper = /* @__PURE__ */ function() {
          function isVarchar(chr) {
            return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === "_" || pctEncoder.isPctEncoded(chr);
          }
          function isUnreserved(chr) {
            return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === "-" || chr === "." || chr === "_" || chr === "~";
          }
          function isReserved(chr) {
            return chr === ":" || chr === "/" || chr === "?" || chr === "#" || chr === "[" || chr === "]" || chr === "@" || chr === "!" || chr === "$" || chr === "&" || chr === "(" || chr === ")" || chr === "*" || chr === "+" || chr === "," || chr === ";" || chr === "=" || chr === "'";
          }
          return {
            isVarchar,
            isUnreserved,
            isReserved
          };
        }();
        var encodingHelper = /* @__PURE__ */ function() {
          function encode3(text, passReserved) {
            var result = "", index, chr = "";
            if (typeof text === "number" || typeof text === "boolean") {
              text = text.toString();
            }
            for (index = 0; index < text.length; index += chr.length) {
              chr = text.charAt(index);
              result += rfcCharHelper.isUnreserved(chr) || passReserved && rfcCharHelper.isReserved(chr) ? chr : pctEncoder.encodeCharacter(chr);
            }
            return result;
          }
          function encodePassReserved(text) {
            return encode3(text, true);
          }
          function encodeLiteralCharacter(literal, index) {
            var chr = pctEncoder.pctCharAt(literal, index);
            if (chr.length > 1) {
              return chr;
            } else {
              return rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);
            }
          }
          function encodeLiteral(literal) {
            var result = "", index, chr = "";
            for (index = 0; index < literal.length; index += chr.length) {
              chr = pctEncoder.pctCharAt(literal, index);
              if (chr.length > 1) {
                result += chr;
              } else {
                result += rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);
              }
            }
            return result;
          }
          return {
            encode: encode3,
            encodePassReserved,
            encodeLiteral,
            encodeLiteralCharacter
          };
        }();
        var operators = function() {
          var bySymbol = {};
          function create(symbol) {
            bySymbol[symbol] = {
              symbol,
              separator: symbol === "?" ? "&" : symbol === "" || symbol === "+" || symbol === "#" ? "," : symbol,
              named: symbol === ";" || symbol === "&" || symbol === "?",
              ifEmpty: symbol === "&" || symbol === "?" ? "=" : "",
              first: symbol === "+" ? "" : symbol,
              encode: symbol === "+" || symbol === "#" ? encodingHelper.encodePassReserved : encodingHelper.encode,
              toString: function() {
                return this.symbol;
              }
            };
          }
          create("");
          create("+");
          create("#");
          create(".");
          create("/");
          create(";");
          create("?");
          create("&");
          return {
            valueOf: function(chr) {
              if (bySymbol[chr]) {
                return bySymbol[chr];
              }
              if ("=,!@|".indexOf(chr) >= 0) {
                return null;
              }
              return bySymbol[""];
            }
          };
        }();
        function isDefined(object) {
          var propertyName;
          if (object === null || object === void 0) {
            return false;
          }
          if (objectHelper.isArray(object)) {
            return object.length > 0;
          }
          if (typeof object === "string" || typeof object === "number" || typeof object === "boolean") {
            return true;
          }
          for (propertyName in object) {
            if (object.hasOwnProperty(propertyName) && isDefined(object[propertyName])) {
              return true;
            }
          }
          return false;
        }
        var LiteralExpression = function() {
          function LiteralExpression2(literal) {
            this.literal = encodingHelper.encodeLiteral(literal);
          }
          LiteralExpression2.prototype.expand = function() {
            return this.literal;
          };
          LiteralExpression2.prototype.toString = LiteralExpression2.prototype.expand;
          return LiteralExpression2;
        }();
        var parse3 = /* @__PURE__ */ function() {
          function parseExpression(expressionText) {
            var operator, varspecs = [], varspec = null, varnameStart = null, maxLengthStart = null, index, chr = "";
            function closeVarname() {
              var varname = expressionText.substring(varnameStart, index);
              if (varname.length === 0) {
                throw new UriTemplateError({ expressionText, message: "a varname must be specified", position: index });
              }
              varspec = { varname, exploded: false, maxLength: null };
              varnameStart = null;
            }
            function closeMaxLength() {
              if (maxLengthStart === index) {
                throw new UriTemplateError({ expressionText, message: "after a ':' you have to specify the length", position: index });
              }
              varspec.maxLength = parseInt(expressionText.substring(maxLengthStart, index), 10);
              maxLengthStart = null;
            }
            operator = function(operatorText) {
              var op = operators.valueOf(operatorText);
              if (op === null) {
                throw new UriTemplateError({ expressionText, message: "illegal use of reserved operator", position: index, operator: operatorText });
              }
              return op;
            }(expressionText.charAt(0));
            index = operator.symbol.length;
            varnameStart = index;
            for (; index < expressionText.length; index += chr.length) {
              chr = pctEncoder.pctCharAt(expressionText, index);
              if (varnameStart !== null) {
                if (chr === ".") {
                  if (varnameStart === index) {
                    throw new UriTemplateError({ expressionText, message: "a varname MUST NOT start with a dot", position: index });
                  }
                  continue;
                }
                if (rfcCharHelper.isVarchar(chr)) {
                  continue;
                }
                closeVarname();
              }
              if (maxLengthStart !== null) {
                if (index === maxLengthStart && chr === "0") {
                  throw new UriTemplateError({ expressionText, message: "A :prefix must not start with digit 0", position: index });
                }
                if (charHelper.isDigit(chr)) {
                  if (index - maxLengthStart >= 4) {
                    throw new UriTemplateError({ expressionText, message: "A :prefix must have max 4 digits", position: index });
                  }
                  continue;
                }
                closeMaxLength();
              }
              if (chr === ":") {
                if (varspec.maxLength !== null) {
                  throw new UriTemplateError({ expressionText, message: "only one :maxLength is allowed per varspec", position: index });
                }
                if (varspec.exploded) {
                  throw new UriTemplateError({ expressionText, message: "an exploeded varspec MUST NOT be varspeced", position: index });
                }
                maxLengthStart = index + 1;
                continue;
              }
              if (chr === "*") {
                if (varspec === null) {
                  throw new UriTemplateError({ expressionText, message: "exploded without varspec", position: index });
                }
                if (varspec.exploded) {
                  throw new UriTemplateError({ expressionText, message: "exploded twice", position: index });
                }
                if (varspec.maxLength) {
                  throw new UriTemplateError({ expressionText, message: "an explode (*) MUST NOT follow to a prefix", position: index });
                }
                varspec.exploded = true;
                continue;
              }
              if (chr === ",") {
                varspecs.push(varspec);
                varspec = null;
                varnameStart = index + 1;
                continue;
              }
              throw new UriTemplateError({ expressionText, message: "illegal character", character: chr, position: index });
            }
            if (varnameStart !== null) {
              closeVarname();
            }
            if (maxLengthStart !== null) {
              closeMaxLength();
            }
            varspecs.push(varspec);
            return new VariableExpression(expressionText, operator, varspecs);
          }
          function parse4(uriTemplateText) {
            var index, chr, expressions = [], braceOpenIndex = null, literalStart = 0;
            for (index = 0; index < uriTemplateText.length; index += 1) {
              chr = uriTemplateText.charAt(index);
              if (literalStart !== null) {
                if (chr === "}") {
                  throw new UriTemplateError({ templateText: uriTemplateText, message: "unopened brace closed", position: index });
                }
                if (chr === "{") {
                  if (literalStart < index) {
                    expressions.push(new LiteralExpression(uriTemplateText.substring(literalStart, index)));
                  }
                  literalStart = null;
                  braceOpenIndex = index;
                }
                continue;
              }
              if (braceOpenIndex !== null) {
                if (chr === "{") {
                  throw new UriTemplateError({ templateText: uriTemplateText, message: "brace already opened", position: index });
                }
                if (chr === "}") {
                  if (braceOpenIndex + 1 === index) {
                    throw new UriTemplateError({ templateText: uriTemplateText, message: "empty braces", position: braceOpenIndex });
                  }
                  try {
                    expressions.push(parseExpression(uriTemplateText.substring(braceOpenIndex + 1, index)));
                  } catch (error) {
                    if (error.prototype === UriTemplateError.prototype) {
                      throw new UriTemplateError({ templateText: uriTemplateText, message: error.options.message, position: braceOpenIndex + error.options.position, details: error.options });
                    }
                    throw error;
                  }
                  braceOpenIndex = null;
                  literalStart = index + 1;
                }
                continue;
              }
              throw new Error("reached unreachable code");
            }
            if (braceOpenIndex !== null) {
              throw new UriTemplateError({ templateText: uriTemplateText, message: "unclosed brace", position: braceOpenIndex });
            }
            if (literalStart < uriTemplateText.length) {
              expressions.push(new LiteralExpression(uriTemplateText.substr(literalStart)));
            }
            return new UriTemplate(uriTemplateText, expressions);
          }
          return parse4;
        }();
        var VariableExpression = function() {
          function prettyPrint(value) {
            return JSON && JSON.stringify ? JSON.stringify(value) : value;
          }
          function isEmpty(value) {
            if (!isDefined(value)) {
              return true;
            }
            if (objectHelper.isString(value)) {
              return value === "";
            }
            if (objectHelper.isNumber(value) || objectHelper.isBoolean(value)) {
              return false;
            }
            if (objectHelper.isArray(value)) {
              return value.length === 0;
            }
            for (var propertyName in value) {
              if (value.hasOwnProperty(propertyName)) {
                return false;
              }
            }
            return true;
          }
          function propertyArray(object) {
            var result = [], propertyName;
            for (propertyName in object) {
              if (object.hasOwnProperty(propertyName)) {
                result.push({ name: propertyName, value: object[propertyName] });
              }
            }
            return result;
          }
          function VariableExpression2(templateText, operator, varspecs) {
            this.templateText = templateText;
            this.operator = operator;
            this.varspecs = varspecs;
          }
          VariableExpression2.prototype.toString = function() {
            return this.templateText;
          };
          function expandSimpleValue(varspec, operator, value) {
            var result = "";
            value = value.toString();
            if (operator.named) {
              result += encodingHelper.encodeLiteral(varspec.varname);
              if (value === "") {
                result += operator.ifEmpty;
                return result;
              }
              result += "=";
            }
            if (varspec.maxLength !== null) {
              value = value.substr(0, varspec.maxLength);
            }
            result += operator.encode(value);
            return result;
          }
          function valueDefined(nameValue) {
            return isDefined(nameValue.value);
          }
          function expandNotExploded(varspec, operator, value) {
            var arr = [], result = "";
            if (operator.named) {
              result += encodingHelper.encodeLiteral(varspec.varname);
              if (isEmpty(value)) {
                result += operator.ifEmpty;
                return result;
              }
              result += "=";
            }
            if (objectHelper.isArray(value)) {
              arr = value;
              arr = objectHelper.filter(arr, isDefined);
              arr = objectHelper.map(arr, operator.encode);
              result += objectHelper.join(arr, ",");
            } else {
              arr = propertyArray(value);
              arr = objectHelper.filter(arr, valueDefined);
              arr = objectHelper.map(arr, function(nameValue) {
                return operator.encode(nameValue.name) + "," + operator.encode(nameValue.value);
              });
              result += objectHelper.join(arr, ",");
            }
            return result;
          }
          function expandExplodedNamed(varspec, operator, value) {
            var isArray2 = objectHelper.isArray(value), arr = [];
            if (isArray2) {
              arr = value;
              arr = objectHelper.filter(arr, isDefined);
              arr = objectHelper.map(arr, function(listElement) {
                var tmp = encodingHelper.encodeLiteral(varspec.varname);
                if (isEmpty(listElement)) {
                  tmp += operator.ifEmpty;
                } else {
                  tmp += "=" + operator.encode(listElement);
                }
                return tmp;
              });
            } else {
              arr = propertyArray(value);
              arr = objectHelper.filter(arr, valueDefined);
              arr = objectHelper.map(arr, function(nameValue) {
                var tmp = encodingHelper.encodeLiteral(nameValue.name);
                if (isEmpty(nameValue.value)) {
                  tmp += operator.ifEmpty;
                } else {
                  tmp += "=" + operator.encode(nameValue.value);
                }
                return tmp;
              });
            }
            return objectHelper.join(arr, operator.separator);
          }
          function expandExplodedUnnamed(operator, value) {
            var arr = [], result = "";
            if (objectHelper.isArray(value)) {
              arr = value;
              arr = objectHelper.filter(arr, isDefined);
              arr = objectHelper.map(arr, operator.encode);
              result += objectHelper.join(arr, operator.separator);
            } else {
              arr = propertyArray(value);
              arr = objectHelper.filter(arr, function(nameValue) {
                return isDefined(nameValue.value);
              });
              arr = objectHelper.map(arr, function(nameValue) {
                return operator.encode(nameValue.name) + "=" + operator.encode(nameValue.value);
              });
              result += objectHelper.join(arr, operator.separator);
            }
            return result;
          }
          VariableExpression2.prototype.expand = function(variables) {
            var expanded = [], index, varspec, value, valueIsArr, oneExploded = false, operator = this.operator;
            for (index = 0; index < this.varspecs.length; index += 1) {
              varspec = this.varspecs[index];
              value = variables[varspec.varname];
              if (value === null || value === void 0) {
                continue;
              }
              if (varspec.exploded) {
                oneExploded = true;
              }
              valueIsArr = objectHelper.isArray(value);
              if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
                expanded.push(expandSimpleValue(varspec, operator, value));
              } else if (varspec.maxLength && isDefined(value)) {
                throw new Error("Prefix modifiers are not applicable to variables that have composite values. You tried to expand " + this + " with " + prettyPrint(value));
              } else if (!varspec.exploded) {
                if (operator.named || !isEmpty(value)) {
                  expanded.push(expandNotExploded(varspec, operator, value));
                }
              } else if (isDefined(value)) {
                if (operator.named) {
                  expanded.push(expandExplodedNamed(varspec, operator, value));
                } else {
                  expanded.push(expandExplodedUnnamed(operator, value));
                }
              }
            }
            if (expanded.length === 0) {
              return "";
            } else {
              return operator.first + objectHelper.join(expanded, operator.separator);
            }
          };
          return VariableExpression2;
        }();
        var UriTemplate = function() {
          function UriTemplate2(templateText, expressions) {
            this.templateText = templateText;
            this.expressions = expressions;
            objectHelper.deepFreeze(this);
          }
          UriTemplate2.prototype.toString = function() {
            return this.templateText;
          };
          UriTemplate2.prototype.expand = function(variables) {
            var index, result = "";
            for (index = 0; index < this.expressions.length; index += 1) {
              result += this.expressions[index].expand(variables);
            }
            return result;
          };
          UriTemplate2.parse = parse3;
          UriTemplate2.UriTemplateError = UriTemplateError;
          return UriTemplate2;
        }();
        exportCallback(UriTemplate);
      })(
        function(UriTemplate) {
          "use strict";
          if (typeof module !== "undefined") {
            module.exports = UriTemplate;
          } else if (typeof define === "function") {
            define([], function() {
              return UriTemplate;
            });
          } else if (typeof window !== "undefined") {
            window.UriTemplate = UriTemplate;
          } else {
            global.UriTemplate = UriTemplate;
          }
        }
      );
    }
  });

  // ../core/dist/consumed-thing.js
  var require_consumed_thing = __commonJS({
    "../core/dist/consumed-thing.js"(exports21) {
      "use strict";
      init_buffer2();
      var __classPrivateFieldSet = exports21 && exports21.__classPrivateFieldSet || function(receiver, state, value, kind, f5) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = exports21 && exports21.__classPrivateFieldGet || function(receiver, state, kind, f5) {
        if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
      };
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _ConsumedThingProperty_name;
      var _ConsumedThingProperty_thing;
      var _ConsumedThingAction_name;
      var _ConsumedThingAction_thing;
      var _ConsumedThingEvent_name;
      var _ConsumedThingEvent_thing;
      var _ConsumedThing_servient;
      var _ConsumedThing_clients;
      Object.defineProperty(exports21, "__esModule", { value: true });
      var thing_description_1 = require_thing_description();
      var helpers_1 = __importDefault(require_helpers());
      var content_type_1 = __importDefault(require_content_type());
      var content_serdes_1 = __importDefault(require_content_serdes());
      var UriTemplate = require_uritemplate();
      var interaction_output_1 = require_interaction_output();
      var logger_1 = require_logger();
      var { debug, warn } = (0, logger_1.createLoggers)("core", "consumed-thing");
      var Affordance;
      (function(Affordance2) {
        Affordance2[Affordance2["PropertyAffordance"] = 0] = "PropertyAffordance";
        Affordance2[Affordance2["ActionAffordance"] = 1] = "ActionAffordance";
        Affordance2[Affordance2["EventAffordance"] = 2] = "EventAffordance";
      })(Affordance || (Affordance = {}));
      var ConsumedThingProperty = class extends thing_description_1.ThingProperty {
        constructor(name2, thing) {
          super();
          _ConsumedThingProperty_name.set(this, void 0);
          _ConsumedThingProperty_thing.set(this, void 0);
          __classPrivateFieldSet(this, _ConsumedThingProperty_name, name2, "f");
          __classPrivateFieldSet(this, _ConsumedThingProperty_thing, thing, "f");
        }
      };
      _ConsumedThingProperty_name = /* @__PURE__ */ new WeakMap(), _ConsumedThingProperty_thing = /* @__PURE__ */ new WeakMap();
      var ConsumedThingAction = class extends thing_description_1.ThingAction {
        constructor(name2, thing) {
          super();
          _ConsumedThingAction_name.set(this, void 0);
          _ConsumedThingAction_thing.set(this, void 0);
          __classPrivateFieldSet(this, _ConsumedThingAction_name, name2, "f");
          __classPrivateFieldSet(this, _ConsumedThingAction_thing, thing, "f");
        }
      };
      _ConsumedThingAction_name = /* @__PURE__ */ new WeakMap(), _ConsumedThingAction_thing = /* @__PURE__ */ new WeakMap();
      var ConsumedThingEvent = class extends thing_description_1.ThingEvent {
        constructor(name2, thing) {
          super();
          _ConsumedThingEvent_name.set(this, void 0);
          _ConsumedThingEvent_thing.set(this, void 0);
          __classPrivateFieldSet(this, _ConsumedThingEvent_name, name2, "f");
          __classPrivateFieldSet(this, _ConsumedThingEvent_thing, thing, "f");
        }
      };
      _ConsumedThingEvent_name = /* @__PURE__ */ new WeakMap(), _ConsumedThingEvent_thing = /* @__PURE__ */ new WeakMap();
      var InternalSubscription = class {
        constructor(thing, name2, client) {
          this.thing = thing;
          this.name = name2;
          this.client = client;
          this.active = true;
        }
      };
      function handleUriVariables(thing, ti, form, options) {
        const ut = UriTemplate.parse(form.href);
        const uriVariables = helpers_1.default.parseInteractionOptions(thing, ti, options).uriVariables;
        const updatedHref = ut.expand(uriVariables ?? {});
        if (updatedHref !== form.href) {
          const updForm = { ...form };
          updForm.href = updatedHref;
          form = updForm;
          debug(`ConsumedThing '${thing.title}' update form URI to ${form.href}`);
        }
        return form;
      }
      var InternalPropertySubscription = class extends InternalSubscription {
        constructor(thing, name2, client, form) {
          super(thing, name2, client);
          this.form = form;
          this.active = false;
          const index = this.thing.properties?.[name2].forms.indexOf(form);
          if (index === void 0 || index < 0) {
            throw new Error(`Could not find form ${form.href} in property ${name2}`);
          }
          this.formIndex = index;
        }
        async stop(options) {
          await this.unobserveProperty(options);
          this.thing["observedProperties"].delete(this.name);
        }
        async unobserveProperty(options = {}) {
          const tp = this.thing.properties[this.name];
          if (tp == null) {
            throw new Error(`ConsumedThing '${this.thing.title}' does not have property ${this.name}`);
          }
          options.formIndex ??= this.matchingUnsubscribeForm();
          const { form } = this.thing.getClientFor(tp.forms, "unobserveproperty", Affordance.PropertyAffordance, options);
          if (form == null) {
            throw new Error(`ConsumedThing '${this.thing.title}' did not get suitable form`);
          }
          const formWithoutURIvariables = handleUriVariables(this.thing, tp, form, options);
          debug(`ConsumedThing '${this.thing.title}' unobserving to ${form.href}`);
          await this.client.unlinkResource(formWithoutURIvariables);
          this.active = false;
        }
        matchingUnsubscribeForm() {
          const refForm = this.thing.properties[this.name].forms[this.formIndex];
          if (Array.isArray(refForm.op) && refForm.op.includes("unobserveproperty")) {
            return this.formIndex;
          }
          const bestFormMatch = this.findFormIndexWithScoring(this.formIndex, this.thing.properties[this.name].forms, "unobserveproperty");
          if (bestFormMatch === -1) {
            throw new Error(`Could not find matching form for unsubscribe`);
          }
          return bestFormMatch;
        }
        findFormIndexWithScoring(formIndex, forms, operation) {
          const refForm = forms[formIndex];
          let maxScore = 0;
          let maxScoreIndex = -1;
          for (let i5 = 0; i5 < forms.length; i5++) {
            let score = 0;
            const form = forms[i5];
            if (form.op === operation || form?.op?.includes(operation) === true && Array.isArray(form.op) === true) {
              score += 1;
            }
            if (new URL(form.href).origin === new URL(refForm.href).origin) {
              score += 1;
            }
            if (form.contentType === refForm.contentType) {
              score += 1;
            }
            if (score > maxScore) {
              maxScore = score;
              maxScoreIndex = i5;
            }
          }
          return maxScoreIndex;
        }
      };
      function findFormIndexWithScoring(formIndex, forms, operation) {
        const refForm = forms[formIndex];
        let maxScore = 0;
        let maxScoreIndex = -1;
        for (let i5 = 0; i5 < forms.length; i5++) {
          let score = 0;
          const form = forms[i5];
          if (form.op === operation || form?.op?.includes(operation) === true && Array.isArray(form.op) === true) {
            score += 1;
          }
          if (new URL(form.href).origin === new URL(refForm.href).origin) {
            score += 1;
          }
          if (form.contentType === refForm.contentType) {
            score += 1;
          }
          if (score > maxScore) {
            maxScore = score;
            maxScoreIndex = i5;
          }
        }
        return maxScoreIndex;
      }
      var InternalEventSubscription = class extends InternalSubscription {
        constructor(thing, name2, client, form) {
          super(thing, name2, client);
          this.form = form;
          const index = this.thing.events?.[name2].forms.indexOf(form);
          if (index === void 0 || index < 0) {
            throw new Error(`Could not find form ${form.href} in event ${name2}`);
          }
          this.formIndex = index;
        }
        async stop(options) {
          await this.unsubscribeEvent(options);
          this.thing["subscribedEvents"].delete(this.name);
        }
        async unsubscribeEvent(options = {}) {
          const te2 = this.thing.events[this.name];
          if (te2 == null) {
            throw new Error(`ConsumedThing '${this.thing.title}' does not have event ${this.name}`);
          }
          options.formIndex ??= this.matchingUnsubscribeForm();
          const { form } = this.thing.getClientFor(te2.forms, "unsubscribeevent", Affordance.EventAffordance, options);
          if (form == null) {
            throw new Error(`ConsumedThing '${this.thing.title}' did not get suitable form`);
          }
          const formWithoutURIvariables = handleUriVariables(this.thing, te2, form, options);
          debug(`ConsumedThing '${this.thing.title}' unsubscribing to ${form.href}`);
          this.client.unlinkResource(formWithoutURIvariables);
          this.active = false;
        }
        matchingUnsubscribeForm() {
          const refForm = this.thing.events[this.name].forms[this.formIndex];
          if (refForm.op == null || Array.isArray(refForm.op) && refForm.op.includes("unsubscribeevent")) {
            return this.formIndex;
          }
          const bestFormMatch = findFormIndexWithScoring(this.formIndex, this.thing.events[this.name].forms, "unsubscribeevent");
          if (bestFormMatch === -1) {
            throw new Error(`Could not find matching form for unsubscribe`);
          }
          return bestFormMatch;
        }
      };
      var ConsumedThing = class extends thing_description_1.Thing {
        constructor(servient, thingModel) {
          super();
          _ConsumedThing_servient.set(this, void 0);
          _ConsumedThing_clients.set(this, void 0);
          this.subscribedEvents = /* @__PURE__ */ new Map();
          this.observedProperties = /* @__PURE__ */ new Map();
          __classPrivateFieldSet(this, _ConsumedThing_servient, servient, "f");
          __classPrivateFieldSet(this, _ConsumedThing_clients, /* @__PURE__ */ new Map(), "f");
          this.properties = {};
          this.actions = {};
          this.events = {};
          const deepClonedModel = helpers_1.default.structuredClone(thingModel ?? {});
          Object.assign(this, deepClonedModel);
          this.extendInteractions();
        }
        getThingDescription() {
          return JSON.parse(JSON.stringify(this));
        }
        emitEvent(name2, data) {
          warn("not implemented");
        }
        extendInteractions() {
          for (const [propertyName, property] of Object.entries(this.properties)) {
            const newProp = helpers_1.default.extend(property, new ConsumedThingProperty(propertyName, this));
            this.properties[propertyName] = newProp;
          }
          for (const [actionName, action] of Object.entries(this.actions)) {
            const newAction = helpers_1.default.extend(action, new ConsumedThingAction(actionName, this));
            this.actions[actionName] = newAction;
          }
          for (const [eventName, event] of Object.entries(this.events)) {
            const newEvent = helpers_1.default.extend(event, new ConsumedThingEvent(eventName, this));
            this.events[eventName] = newEvent;
          }
        }
        findForm(forms, op, affordance, schemes, idx) {
          let form;
          for (const f5 of forms) {
            let fop = "";
            if (f5.op !== void 0) {
              fop = f5.op;
            } else {
              switch (affordance) {
                case Affordance.PropertyAffordance:
                  fop = ["readproperty", "writeproperty"];
                  break;
                case Affordance.ActionAffordance:
                  fop = "invokeaction";
                  break;
                case Affordance.EventAffordance:
                  fop = "subscribeevent";
                  break;
              }
            }
            if (fop.indexOf(op) !== -1 && f5.href.indexOf(schemes[idx] + ":") !== -1) {
              form = f5;
              break;
            }
          }
          return form;
        }
        getSecuritySchemes(security) {
          const scs = [];
          for (const s5 of security) {
            const ws = this.securityDefinitions[s5 + ""];
            if (ws != null) {
              scs.push(ws);
            }
          }
          return scs;
        }
        ensureClientSecurity(client, form) {
          if (this.securityDefinitions != null) {
            const logStatement = () => debug(`ConsumedThing '${this.title}' setting credentials for ${client} based on thing security`);
            if (form != null && Array.isArray(form.security) && form.security.length > 0) {
              logStatement();
              client.setSecurity(this.getSecuritySchemes(form.security), __classPrivateFieldGet(this, _ConsumedThing_servient, "f").retrieveCredentials(this.id));
            } else if (Array.isArray(this.security) && this.security.length > 0) {
              logStatement();
              client.setSecurity(this.getSecuritySchemes(this.security), __classPrivateFieldGet(this, _ConsumedThing_servient, "f").getCredentials(this.id));
            }
          }
        }
        getClientFor(forms, op, affordance, options) {
          if (forms.length === 0) {
            throw new Error(`ConsumedThing '${this.title}' has no links for this interaction`);
          }
          let form;
          let client;
          if (options?.formIndex !== void 0) {
            debug(`ConsumedThing '${this.title}' asked to use formIndex '${options.formIndex}'`);
            if (options.formIndex >= 0 && options.formIndex < forms.length) {
              form = forms[options.formIndex];
              const scheme = helpers_1.default.extractScheme(form.href);
              if (__classPrivateFieldGet(this, _ConsumedThing_servient, "f").hasClientFor(scheme)) {
                debug(`ConsumedThing '${this.title}' got client for '${scheme}'`);
                client = __classPrivateFieldGet(this, _ConsumedThing_servient, "f").getClientFor(scheme);
                if (!__classPrivateFieldGet(this, _ConsumedThing_clients, "f").get(scheme)) {
                  this.ensureClientSecurity(client, form);
                  __classPrivateFieldGet(this, _ConsumedThing_clients, "f").set(scheme, client);
                }
              } else {
                throw new Error(`ConsumedThing '${this.title}' missing ClientFactory for '${scheme}'`);
              }
            } else {
              throw new Error(`ConsumedThing '${this.title}' missing formIndex '${options.formIndex}'`);
            }
          } else {
            const schemes = forms.map((link) => helpers_1.default.extractScheme(link.href));
            const cacheIdx = schemes.findIndex((scheme) => __classPrivateFieldGet(this, _ConsumedThing_clients, "f").has(scheme));
            if (cacheIdx !== -1) {
              debug(`ConsumedThing '${this.title}' chose cached client for '${schemes[cacheIdx]}'`);
              client = __classPrivateFieldGet(this, _ConsumedThing_clients, "f").get(schemes[cacheIdx]);
              form = this.findForm(forms, op, affordance, schemes, cacheIdx);
            } else {
              debug(`ConsumedThing '${this.title}' has no client in cache (${cacheIdx})`);
              const srvIdx = schemes.findIndex((scheme) => __classPrivateFieldGet(this, _ConsumedThing_servient, "f").hasClientFor(scheme));
              if (srvIdx === -1)
                throw new Error(`ConsumedThing '${this.title}' missing ClientFactory for '${schemes}'`);
              client = __classPrivateFieldGet(this, _ConsumedThing_servient, "f").getClientFor(schemes[srvIdx]);
              debug(`ConsumedThing '${this.title}' got new client for '${schemes[srvIdx]}'`);
              __classPrivateFieldGet(this, _ConsumedThing_clients, "f").set(schemes[srvIdx], client);
              form = this.findForm(forms, op, affordance, schemes, srvIdx);
              this.ensureClientSecurity(client, form);
            }
          }
          return { client, form };
        }
        async readProperty(propertyName, options) {
          const tp = this.properties[propertyName];
          if (tp == null) {
            throw new Error(`ConsumedThing '${this.title}' does not have property ${propertyName}`);
          }
          let { client, form } = this.getClientFor(tp.forms, "readproperty", Affordance.PropertyAffordance, options);
          if (form == null) {
            throw new Error(`ConsumedThing '${this.title}' did not get suitable form`);
          }
          if (client == null) {
            throw new Error(`ConsumedThing '${this.title}' did not get suitable client for ${form.href}`);
          }
          debug(`ConsumedThing '${this.title}' reading ${form.href}`);
          form = this.handleUriVariables(tp, form, options);
          const content = await client.readResource(form);
          try {
            return this.handleInteractionOutput(content, form, tp, false);
          } catch (e5) {
            const error = e5 instanceof Error ? e5 : new Error(JSON.stringify(e5));
            throw new Error(`Error while processing property for ${tp.title}. ${error.message}`);
          }
        }
        handleInteractionOutput(content, form, outputDataSchema, ignoreValidation) {
          content.type ??= form.contentType ?? "application/json";
          if (form.response != null) {
            const parsedMediaTypeContent = content_type_1.default.parse(content.type);
            const parsedMediaTypeForm = content_type_1.default.parse(form.response.contentType);
            if (parsedMediaTypeContent.type !== parsedMediaTypeForm.type) {
              throw new Error(`Unexpected type '${content.type}' in response. Should be '${form.response.contentType}'`);
            }
          }
          return new interaction_output_1.InteractionOutput(content, form, outputDataSchema, { ignoreValidation });
        }
        async _readProperties(propertyNames) {
          const promises2 = [];
          for (const propertyName of propertyNames) {
            promises2.push(this.readProperty(propertyName));
          }
          const output = /* @__PURE__ */ new Map();
          try {
            const result = await Promise.all(promises2);
            let index = 0;
            for (const propertyName of propertyNames) {
              output.set(propertyName, result[index]);
              index++;
            }
            return output;
          } catch (err) {
            throw new Error(`ConsumedThing '${this.title}', failed to read properties: ${propertyNames}.
 Error: ${err}`);
          }
        }
        readAllProperties(options) {
          const propertyNames = [];
          for (const [propertyName, property] of Object.entries(this.properties)) {
            const { form } = this.getClientFor(property.forms, "readproperty", Affordance.PropertyAffordance, options);
            if (form != null) {
              propertyNames.push(propertyName);
            }
          }
          return this._readProperties(propertyNames);
        }
        readMultipleProperties(propertyNames, options) {
          return this._readProperties(propertyNames);
        }
        async writeProperty(propertyName, value, options) {
          const tp = this.properties[propertyName];
          if (tp == null) {
            throw new Error(`ConsumedThing '${this.title}' does not have property ${propertyName}`);
          }
          let { client, form } = this.getClientFor(tp.forms, "writeproperty", Affordance.PropertyAffordance, options);
          if (form == null) {
            throw new Error(`ConsumedThing '${this.title}' did not get suitable form`);
          }
          if (client == null) {
            throw new Error(`ConsumedThing '${this.title}' did not get suitable client for ${form.href}`);
          }
          debug(`ConsumedThing '${this.title}' writing ${form.href} with '${value}'`);
          const content = content_serdes_1.default.valueToContent(value, tp, form.contentType);
          form = this.handleUriVariables(tp, form, options);
          await client.writeResource(form, content);
        }
        async writeMultipleProperties(valueMap, options) {
          const promises2 = [];
          for (const [propertyName, value] of valueMap.entries()) {
            promises2.push(this.writeProperty(propertyName, value));
          }
          try {
            await Promise.all(promises2);
          } catch (err) {
            throw new Error(`ConsumedThing '${this.title}', failed to write multiple properties: ${valueMap}
 Error: ${err}`);
          }
        }
        async invokeAction(actionName, parameter, options) {
          const ta = this.actions[actionName];
          if (ta == null) {
            throw new Error(`ConsumedThing '${this.title}' does not have action ${actionName}`);
          }
          let { client, form } = this.getClientFor(ta.forms, "invokeaction", Affordance.ActionAffordance, options);
          if (form == null) {
            throw new Error(`ConsumedThing '${this.title}' did not get suitable form`);
          }
          if (client == null) {
            throw new Error(`ConsumedThing '${this.title}' did not get suitable client for ${form.href}`);
          }
          debug(`ConsumedThing '${this.title}' invoking ${form.href}${parameter !== void 0 ? " with '" + parameter + "'" : ""}`);
          let input;
          if (parameter !== void 0) {
            input = content_serdes_1.default.valueToContent(parameter, ta.input, form.contentType);
          }
          form = this.handleUriVariables(ta, form, options);
          const content = await client.invokeResource(form, input);
          try {
            const ignoreValidation = ta.synchronous === void 0 ? true : !ta.synchronous;
            return this.handleInteractionOutput(content, form, ta.output, ignoreValidation);
          } catch (e5) {
            const error = e5 instanceof Error ? e5 : new Error(JSON.stringify(e5));
            throw new Error(`Error while processing action for ${ta.title}. ${error.message}`);
          }
        }
        async observeProperty(name2, listener, errorListener, options) {
          const tp = this.properties[name2];
          if (tp == null) {
            throw new Error(`ConsumedThing '${this.title}' does not have property ${name2}`);
          }
          const { client, form } = this.getClientFor(tp.forms, "observeproperty", Affordance.PropertyAffordance, options);
          if (form == null) {
            throw new Error(`ConsumedThing '${this.title}' did not get suitable form`);
          }
          if (client == null) {
            throw new Error(`ConsumedThing '${this.title}' did not get suitable client for ${form.href}`);
          }
          if (this.observedProperties.has(name2)) {
            throw new Error(`ConsumedThing '${this.title}' has already a function subscribed to ${name2}. You can only observe once`);
          }
          debug(`ConsumedThing '${this.title}' observing to ${form.href}`);
          const formWithoutURITemplates = this.handleUriVariables(tp, form, options);
          await client.subscribeResource(formWithoutURITemplates, (content) => {
            try {
              listener(this.handleInteractionOutput(content, form, tp, false));
            } catch (e5) {
              const error = e5 instanceof Error ? e5 : new Error(JSON.stringify(e5));
              warn(`Error while processing observe property for ${tp.title}. ${error.message}`);
              warn(e5);
            }
          }, (err) => {
            errorListener?.(err);
          }, () => {
          });
          const subscription = new InternalPropertySubscription(this, name2, client, form);
          this.observedProperties.set(name2, subscription);
          return subscription;
        }
        async subscribeEvent(name2, listener, errorListener, options) {
          const te2 = this.events[name2];
          if (te2 == null) {
            throw new Error(`ConsumedThing '${this.title}' does not have event ${name2}`);
          }
          const { client, form } = this.getClientFor(te2.forms, "subscribeevent", Affordance.EventAffordance, options);
          if (form == null) {
            throw new Error(`ConsumedThing '${this.title}' did not get suitable form`);
          }
          if (client == null) {
            throw new Error(`ConsumedThing '${this.title}' did not get suitable client for ${form.href}`);
          }
          if (this.subscribedEvents.has(name2)) {
            throw new Error(`ConsumedThing '${this.title}' has already a function subscribed to ${name2}. You can only subscribe once`);
          }
          debug(`ConsumedThing '${this.title}' subscribing to ${form.href}`);
          const formWithoutURITemplates = this.handleUriVariables(te2, form, options);
          await client.subscribeResource(formWithoutURITemplates, (content) => {
            try {
              listener(this.handleInteractionOutput(content, form, te2.data, false));
            } catch (e5) {
              const error = e5 instanceof Error ? e5 : new Error(JSON.stringify(e5));
              warn(`Error while processing event for ${te2.title}. ${error.message}`);
              warn(e5);
            }
          }, (err) => {
            errorListener?.(err);
          }, () => {
          });
          const subscription = new InternalEventSubscription(this, name2, client, form);
          this.subscribedEvents.set(name2, subscription);
          return subscription;
        }
        handleUriVariables(ti, form, options) {
          return handleUriVariables(this, ti, form, options);
        }
      };
      _ConsumedThing_servient = /* @__PURE__ */ new WeakMap(), _ConsumedThing_clients = /* @__PURE__ */ new WeakMap();
      exports21.default = ConsumedThing;
    }
  });

  // ../core/dist/validation.js
  var require_validation2 = __commonJS({
    "../core/dist/validation.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.isThingDescription = isThingDescription;
      exports21.getLastValidationErrors = getLastValidationErrors;
      var helpers_1 = __importDefault(require_helpers());
      function isThingDescription(input) {
        return helpers_1.default.tsSchemaValidator(input);
      }
      function getLastValidationErrors() {
        const errors = helpers_1.default.tsSchemaValidator.errors?.map((o5) => o5.message).join("\n");
        return new Error(errors);
      }
    }
  });

  // ../core/dist/wot-impl.js
  var require_wot_impl = __commonJS({
    "../core/dist/wot-impl.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.DataType = void 0;
      var serdes_1 = require_serdes();
      var exposed_thing_1 = __importDefault(require_exposed_thing());
      var consumed_thing_1 = __importDefault(require_consumed_thing());
      var helpers_1 = __importDefault(require_helpers());
      var logger_1 = require_logger();
      var content_serdes_1 = __importDefault(require_content_serdes());
      var validation_1 = require_validation2();
      var util_1 = (init_util(), __toCommonJS(util_exports));
      var { debug } = (0, logger_1.createLoggers)("core", "wot-impl");
      var ThingDiscoveryProcess = class {
        constructor(directory, filter) {
          this.directory = directory;
          this.filter = filter;
          this.filter = filter;
          this.done = false;
        }
        async stop() {
          this.done = true;
        }
        async *[Symbol.asyncIterator]() {
          let rawThingDescriptions;
          try {
            const thingsPropertyOutput = await this.directory.readProperty("things");
            rawThingDescriptions = await thingsPropertyOutput.value();
          } catch (error) {
            this.error = error instanceof Error ? error : new Error((0, util_1.inspect)(error));
            this.done = true;
            return;
          }
          for (const outputValue of rawThingDescriptions) {
            if (this.done) {
              return;
            }
            if (!(0, validation_1.isThingDescription)(outputValue)) {
              this.error = (0, validation_1.getLastValidationErrors)();
              continue;
            }
            yield outputValue;
          }
          this.done = true;
        }
      };
      var WoTImpl = class {
        constructor(srv) {
          this.srv = srv;
        }
        async discover(filter) {
          throw new Error("not implemented");
        }
        async exploreDirectory(url, filter) {
          const directoryThingDescription = await this.requestThingDescription(url);
          const consumedDirectory = await this.consume(directoryThingDescription);
          return new ThingDiscoveryProcess(consumedDirectory, filter);
        }
        async requestThingDescription(url) {
          const uriScheme = helpers_1.default.extractScheme(url);
          const client = this.srv.getClientFor(uriScheme);
          const content = await client.requestThingDescription(url);
          const value = content_serdes_1.default.contentToValue({ type: content.type, body: await content.toBuffer() }, {});
          if ((0, validation_1.isThingDescription)(value)) {
            return value;
          }
          throw (0, validation_1.getLastValidationErrors)();
        }
        async consume(td) {
          try {
            const thing = (0, serdes_1.parseTD)(JSON.stringify(td), true);
            const newThing = new consumed_thing_1.default(this.srv, thing);
            debug(`WoTImpl consuming TD ${newThing.id != null ? `'${newThing.id}'` : "without id"} to instantiate ConsumedThing '${newThing.title}'`);
            return newThing;
          } catch (err) {
            throw new Error(`Cannot consume TD because ${err instanceof Error ? err.message : err}`);
          }
        }
        produce(init2) {
          return new Promise((resolve2, reject) => {
            try {
              const validated = helpers_1.default.validateExposedThingInit(init2);
              if (!validated.valid) {
                throw new Error("Thing Description JSON schema validation failed:\n" + validated.errors);
              }
              const newThing = new exposed_thing_1.default(this.srv, init2);
              debug(`WoTImpl producing new ExposedThing '${newThing.title}'`);
              if (this.srv.addThing(newThing)) {
                resolve2(newThing);
              } else {
                throw new Error("Thing already exists: " + newThing.title);
              }
            } catch (err) {
              reject(new Error(`Cannot produce ExposedThing because " + ${err instanceof Error ? err.message : err}`));
            }
          });
        }
      };
      exports21.default = WoTImpl;
      var DataType;
      (function(DataType2) {
        DataType2["boolean"] = "boolean";
        DataType2["number"] = "number";
        DataType2["integer"] = "integer";
        DataType2["string"] = "string";
        DataType2["object"] = "object";
        DataType2["array"] = "array";
        DataType2["null"] = "null";
      })(DataType || (exports21.DataType = DataType = {}));
    }
  });

  // ../../node_modules/uuid/dist/rng-browser.js
  var require_rng_browser = __commonJS({
    "../../node_modules/uuid/dist/rng-browser.js"(exports21, module) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.default = rng;
      var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
      var rnds8 = new Uint8Array(16);
      function rng() {
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
        return getRandomValues(rnds8);
      }
      module.exports = exports21.default;
    }
  });

  // ../../node_modules/uuid/dist/bytesToUuid.js
  var require_bytesToUuid = __commonJS({
    "../../node_modules/uuid/dist/bytesToUuid.js"(exports21, module) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.default = void 0;
      var byteToHex = [];
      for (i5 = 0; i5 < 256; ++i5) {
        byteToHex[i5] = (i5 + 256).toString(16).substr(1);
      }
      var i5;
      function bytesToUuid(buf, offset) {
        var i6 = offset || 0;
        var bth = byteToHex;
        return [bth[buf[i6++]], bth[buf[i6++]], bth[buf[i6++]], bth[buf[i6++]], "-", bth[buf[i6++]], bth[buf[i6++]], "-", bth[buf[i6++]], bth[buf[i6++]], "-", bth[buf[i6++]], bth[buf[i6++]], "-", bth[buf[i6++]], bth[buf[i6++]], bth[buf[i6++]], bth[buf[i6++]], bth[buf[i6++]], bth[buf[i6++]]].join("");
      }
      var _default = bytesToUuid;
      exports21.default = _default;
      module.exports = exports21.default;
    }
  });

  // ../../node_modules/uuid/dist/v1.js
  var require_v1 = __commonJS({
    "../../node_modules/uuid/dist/v1.js"(exports21, module) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.default = void 0;
      var _rng = _interopRequireDefault(require_rng_browser());
      var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _nodeId;
      var _clockseq;
      var _lastMSecs = 0;
      var _lastNSecs = 0;
      function v1(options, buf, offset) {
        var i5 = buf && offset || 0;
        var b4 = buf || [];
        options = options || {};
        var node = options.node || _nodeId;
        var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
        if (node == null || clockseq == null) {
          var seedBytes = options.random || (options.rng || _rng.default)();
          if (node == null) {
            node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
          }
          if (clockseq == null) {
            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
          }
        }
        var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
        var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
        var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
        if (dt < 0 && options.clockseq === void 0) {
          clockseq = clockseq + 1 & 16383;
        }
        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
          nsecs = 0;
        }
        if (nsecs >= 1e4) {
          throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        }
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
        msecs += 122192928e5;
        var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
        b4[i5++] = tl >>> 24 & 255;
        b4[i5++] = tl >>> 16 & 255;
        b4[i5++] = tl >>> 8 & 255;
        b4[i5++] = tl & 255;
        var tmh = msecs / 4294967296 * 1e4 & 268435455;
        b4[i5++] = tmh >>> 8 & 255;
        b4[i5++] = tmh & 255;
        b4[i5++] = tmh >>> 24 & 15 | 16;
        b4[i5++] = tmh >>> 16 & 255;
        b4[i5++] = clockseq >>> 8 | 128;
        b4[i5++] = clockseq & 255;
        for (var n5 = 0; n5 < 6; ++n5) {
          b4[i5 + n5] = node[n5];
        }
        return buf ? buf : (0, _bytesToUuid.default)(b4);
      }
      var _default = v1;
      exports21.default = _default;
      module.exports = exports21.default;
    }
  });

  // ../../node_modules/uuid/dist/v35.js
  var require_v35 = __commonJS({
    "../../node_modules/uuid/dist/v35.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.default = _default;
      exports21.URL = exports21.DNS = void 0;
      var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function uuidToBytes(uuid) {
        var bytes = [];
        uuid.replace(/[a-fA-F0-9]{2}/g, function(hex) {
          bytes.push(parseInt(hex, 16));
        });
        return bytes;
      }
      function stringToBytes(str) {
        str = unescape(encodeURIComponent(str));
        var bytes = new Array(str.length);
        for (var i5 = 0; i5 < str.length; i5++) {
          bytes[i5] = str.charCodeAt(i5);
        }
        return bytes;
      }
      var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      exports21.DNS = DNS;
      var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
      exports21.URL = URL2;
      function _default(name2, version4, hashfunc) {
        var generateUUID = function(value, namespace, buf, offset) {
          var off2 = buf && offset || 0;
          if (typeof value == "string") value = stringToBytes(value);
          if (typeof namespace == "string") namespace = uuidToBytes(namespace);
          if (!Array.isArray(value)) throw TypeError("value must be an array of bytes");
          if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError("namespace must be uuid string or an Array of 16 byte values");
          var bytes = hashfunc(namespace.concat(value));
          bytes[6] = bytes[6] & 15 | version4;
          bytes[8] = bytes[8] & 63 | 128;
          if (buf) {
            for (var idx = 0; idx < 16; ++idx) {
              buf[off2 + idx] = bytes[idx];
            }
          }
          return buf || (0, _bytesToUuid.default)(bytes);
        };
        try {
          generateUUID.name = name2;
        } catch (err) {
        }
        generateUUID.DNS = DNS;
        generateUUID.URL = URL2;
        return generateUUID;
      }
    }
  });

  // ../../node_modules/uuid/dist/md5-browser.js
  var require_md5_browser = __commonJS({
    "../../node_modules/uuid/dist/md5-browser.js"(exports21, module) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.default = void 0;
      function md5(bytes) {
        if (typeof bytes == "string") {
          var msg = unescape(encodeURIComponent(bytes));
          bytes = new Array(msg.length);
          for (var i5 = 0; i5 < msg.length; i5++) bytes[i5] = msg.charCodeAt(i5);
        }
        return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
      }
      function md5ToHexEncodedArray(input) {
        var i5;
        var x3;
        var output = [];
        var length32 = input.length * 32;
        var hexTab = "0123456789abcdef";
        var hex;
        for (i5 = 0; i5 < length32; i5 += 8) {
          x3 = input[i5 >> 5] >>> i5 % 32 & 255;
          hex = parseInt(hexTab.charAt(x3 >>> 4 & 15) + hexTab.charAt(x3 & 15), 16);
          output.push(hex);
        }
        return output;
      }
      function wordsToMd5(x3, len) {
        x3[len >> 5] |= 128 << len % 32;
        x3[(len + 64 >>> 9 << 4) + 14] = len;
        var i5;
        var olda;
        var oldb;
        var oldc;
        var oldd;
        var a5 = 1732584193;
        var b4 = -271733879;
        var c5 = -1732584194;
        var d4 = 271733878;
        for (i5 = 0; i5 < x3.length; i5 += 16) {
          olda = a5;
          oldb = b4;
          oldc = c5;
          oldd = d4;
          a5 = md5ff(a5, b4, c5, d4, x3[i5], 7, -680876936);
          d4 = md5ff(d4, a5, b4, c5, x3[i5 + 1], 12, -389564586);
          c5 = md5ff(c5, d4, a5, b4, x3[i5 + 2], 17, 606105819);
          b4 = md5ff(b4, c5, d4, a5, x3[i5 + 3], 22, -1044525330);
          a5 = md5ff(a5, b4, c5, d4, x3[i5 + 4], 7, -176418897);
          d4 = md5ff(d4, a5, b4, c5, x3[i5 + 5], 12, 1200080426);
          c5 = md5ff(c5, d4, a5, b4, x3[i5 + 6], 17, -1473231341);
          b4 = md5ff(b4, c5, d4, a5, x3[i5 + 7], 22, -45705983);
          a5 = md5ff(a5, b4, c5, d4, x3[i5 + 8], 7, 1770035416);
          d4 = md5ff(d4, a5, b4, c5, x3[i5 + 9], 12, -1958414417);
          c5 = md5ff(c5, d4, a5, b4, x3[i5 + 10], 17, -42063);
          b4 = md5ff(b4, c5, d4, a5, x3[i5 + 11], 22, -1990404162);
          a5 = md5ff(a5, b4, c5, d4, x3[i5 + 12], 7, 1804603682);
          d4 = md5ff(d4, a5, b4, c5, x3[i5 + 13], 12, -40341101);
          c5 = md5ff(c5, d4, a5, b4, x3[i5 + 14], 17, -1502002290);
          b4 = md5ff(b4, c5, d4, a5, x3[i5 + 15], 22, 1236535329);
          a5 = md5gg(a5, b4, c5, d4, x3[i5 + 1], 5, -165796510);
          d4 = md5gg(d4, a5, b4, c5, x3[i5 + 6], 9, -1069501632);
          c5 = md5gg(c5, d4, a5, b4, x3[i5 + 11], 14, 643717713);
          b4 = md5gg(b4, c5, d4, a5, x3[i5], 20, -373897302);
          a5 = md5gg(a5, b4, c5, d4, x3[i5 + 5], 5, -701558691);
          d4 = md5gg(d4, a5, b4, c5, x3[i5 + 10], 9, 38016083);
          c5 = md5gg(c5, d4, a5, b4, x3[i5 + 15], 14, -660478335);
          b4 = md5gg(b4, c5, d4, a5, x3[i5 + 4], 20, -405537848);
          a5 = md5gg(a5, b4, c5, d4, x3[i5 + 9], 5, 568446438);
          d4 = md5gg(d4, a5, b4, c5, x3[i5 + 14], 9, -1019803690);
          c5 = md5gg(c5, d4, a5, b4, x3[i5 + 3], 14, -187363961);
          b4 = md5gg(b4, c5, d4, a5, x3[i5 + 8], 20, 1163531501);
          a5 = md5gg(a5, b4, c5, d4, x3[i5 + 13], 5, -1444681467);
          d4 = md5gg(d4, a5, b4, c5, x3[i5 + 2], 9, -51403784);
          c5 = md5gg(c5, d4, a5, b4, x3[i5 + 7], 14, 1735328473);
          b4 = md5gg(b4, c5, d4, a5, x3[i5 + 12], 20, -1926607734);
          a5 = md5hh(a5, b4, c5, d4, x3[i5 + 5], 4, -378558);
          d4 = md5hh(d4, a5, b4, c5, x3[i5 + 8], 11, -2022574463);
          c5 = md5hh(c5, d4, a5, b4, x3[i5 + 11], 16, 1839030562);
          b4 = md5hh(b4, c5, d4, a5, x3[i5 + 14], 23, -35309556);
          a5 = md5hh(a5, b4, c5, d4, x3[i5 + 1], 4, -1530992060);
          d4 = md5hh(d4, a5, b4, c5, x3[i5 + 4], 11, 1272893353);
          c5 = md5hh(c5, d4, a5, b4, x3[i5 + 7], 16, -155497632);
          b4 = md5hh(b4, c5, d4, a5, x3[i5 + 10], 23, -1094730640);
          a5 = md5hh(a5, b4, c5, d4, x3[i5 + 13], 4, 681279174);
          d4 = md5hh(d4, a5, b4, c5, x3[i5], 11, -358537222);
          c5 = md5hh(c5, d4, a5, b4, x3[i5 + 3], 16, -722521979);
          b4 = md5hh(b4, c5, d4, a5, x3[i5 + 6], 23, 76029189);
          a5 = md5hh(a5, b4, c5, d4, x3[i5 + 9], 4, -640364487);
          d4 = md5hh(d4, a5, b4, c5, x3[i5 + 12], 11, -421815835);
          c5 = md5hh(c5, d4, a5, b4, x3[i5 + 15], 16, 530742520);
          b4 = md5hh(b4, c5, d4, a5, x3[i5 + 2], 23, -995338651);
          a5 = md5ii(a5, b4, c5, d4, x3[i5], 6, -198630844);
          d4 = md5ii(d4, a5, b4, c5, x3[i5 + 7], 10, 1126891415);
          c5 = md5ii(c5, d4, a5, b4, x3[i5 + 14], 15, -1416354905);
          b4 = md5ii(b4, c5, d4, a5, x3[i5 + 5], 21, -57434055);
          a5 = md5ii(a5, b4, c5, d4, x3[i5 + 12], 6, 1700485571);
          d4 = md5ii(d4, a5, b4, c5, x3[i5 + 3], 10, -1894986606);
          c5 = md5ii(c5, d4, a5, b4, x3[i5 + 10], 15, -1051523);
          b4 = md5ii(b4, c5, d4, a5, x3[i5 + 1], 21, -2054922799);
          a5 = md5ii(a5, b4, c5, d4, x3[i5 + 8], 6, 1873313359);
          d4 = md5ii(d4, a5, b4, c5, x3[i5 + 15], 10, -30611744);
          c5 = md5ii(c5, d4, a5, b4, x3[i5 + 6], 15, -1560198380);
          b4 = md5ii(b4, c5, d4, a5, x3[i5 + 13], 21, 1309151649);
          a5 = md5ii(a5, b4, c5, d4, x3[i5 + 4], 6, -145523070);
          d4 = md5ii(d4, a5, b4, c5, x3[i5 + 11], 10, -1120210379);
          c5 = md5ii(c5, d4, a5, b4, x3[i5 + 2], 15, 718787259);
          b4 = md5ii(b4, c5, d4, a5, x3[i5 + 9], 21, -343485551);
          a5 = safeAdd(a5, olda);
          b4 = safeAdd(b4, oldb);
          c5 = safeAdd(c5, oldc);
          d4 = safeAdd(d4, oldd);
        }
        return [a5, b4, c5, d4];
      }
      function bytesToWords(input) {
        var i5;
        var output = [];
        output[(input.length >> 2) - 1] = void 0;
        for (i5 = 0; i5 < output.length; i5 += 1) {
          output[i5] = 0;
        }
        var length8 = input.length * 8;
        for (i5 = 0; i5 < length8; i5 += 8) {
          output[i5 >> 5] |= (input[i5 / 8] & 255) << i5 % 32;
        }
        return output;
      }
      function safeAdd(x3, y5) {
        var lsw = (x3 & 65535) + (y5 & 65535);
        var msw = (x3 >> 16) + (y5 >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 65535;
      }
      function bitRotateLeft(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
      }
      function md5cmn(q2, a5, b4, x3, s5, t5) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a5, q2), safeAdd(x3, t5)), s5), b4);
      }
      function md5ff(a5, b4, c5, d4, x3, s5, t5) {
        return md5cmn(b4 & c5 | ~b4 & d4, a5, b4, x3, s5, t5);
      }
      function md5gg(a5, b4, c5, d4, x3, s5, t5) {
        return md5cmn(b4 & d4 | c5 & ~d4, a5, b4, x3, s5, t5);
      }
      function md5hh(a5, b4, c5, d4, x3, s5, t5) {
        return md5cmn(b4 ^ c5 ^ d4, a5, b4, x3, s5, t5);
      }
      function md5ii(a5, b4, c5, d4, x3, s5, t5) {
        return md5cmn(c5 ^ (b4 | ~d4), a5, b4, x3, s5, t5);
      }
      var _default = md5;
      exports21.default = _default;
      module.exports = exports21.default;
    }
  });

  // ../../node_modules/uuid/dist/v3.js
  var require_v3 = __commonJS({
    "../../node_modules/uuid/dist/v3.js"(exports21, module) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.default = void 0;
      var _v = _interopRequireDefault(require_v35());
      var _md = _interopRequireDefault(require_md5_browser());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var v32 = (0, _v.default)("v3", 48, _md.default);
      var _default = v32;
      exports21.default = _default;
      module.exports = exports21.default;
    }
  });

  // ../../node_modules/uuid/dist/v4.js
  var require_v4 = __commonJS({
    "../../node_modules/uuid/dist/v4.js"(exports21, module) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.default = void 0;
      var _rng = _interopRequireDefault(require_rng_browser());
      var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function v42(options, buf, offset) {
        var i5 = buf && offset || 0;
        if (typeof options == "string") {
          buf = options === "binary" ? new Array(16) : null;
          options = null;
        }
        options = options || {};
        var rnds = options.random || (options.rng || _rng.default)();
        rnds[6] = rnds[6] & 15 | 64;
        rnds[8] = rnds[8] & 63 | 128;
        if (buf) {
          for (var ii = 0; ii < 16; ++ii) {
            buf[i5 + ii] = rnds[ii];
          }
        }
        return buf || (0, _bytesToUuid.default)(rnds);
      }
      var _default = v42;
      exports21.default = _default;
      module.exports = exports21.default;
    }
  });

  // ../../node_modules/uuid/dist/sha1-browser.js
  var require_sha1_browser = __commonJS({
    "../../node_modules/uuid/dist/sha1-browser.js"(exports21, module) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.default = void 0;
      function f5(s5, x3, y5, z3) {
        switch (s5) {
          case 0:
            return x3 & y5 ^ ~x3 & z3;
          case 1:
            return x3 ^ y5 ^ z3;
          case 2:
            return x3 & y5 ^ x3 & z3 ^ y5 & z3;
          case 3:
            return x3 ^ y5 ^ z3;
        }
      }
      function ROTL(x3, n5) {
        return x3 << n5 | x3 >>> 32 - n5;
      }
      function sha1(bytes) {
        var K2 = [1518500249, 1859775393, 2400959708, 3395469782];
        var H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        if (typeof bytes == "string") {
          var msg = unescape(encodeURIComponent(bytes));
          bytes = new Array(msg.length);
          for (var i5 = 0; i5 < msg.length; i5++) bytes[i5] = msg.charCodeAt(i5);
        }
        bytes.push(128);
        var l5 = bytes.length / 4 + 2;
        var N3 = Math.ceil(l5 / 16);
        var M3 = new Array(N3);
        for (var i5 = 0; i5 < N3; i5++) {
          M3[i5] = new Array(16);
          for (var j3 = 0; j3 < 16; j3++) {
            M3[i5][j3] = bytes[i5 * 64 + j3 * 4] << 24 | bytes[i5 * 64 + j3 * 4 + 1] << 16 | bytes[i5 * 64 + j3 * 4 + 2] << 8 | bytes[i5 * 64 + j3 * 4 + 3];
          }
        }
        M3[N3 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
        M3[N3 - 1][14] = Math.floor(M3[N3 - 1][14]);
        M3[N3 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
        for (var i5 = 0; i5 < N3; i5++) {
          var W2 = new Array(80);
          for (var t5 = 0; t5 < 16; t5++) W2[t5] = M3[i5][t5];
          for (var t5 = 16; t5 < 80; t5++) {
            W2[t5] = ROTL(W2[t5 - 3] ^ W2[t5 - 8] ^ W2[t5 - 14] ^ W2[t5 - 16], 1);
          }
          var a5 = H2[0];
          var b4 = H2[1];
          var c5 = H2[2];
          var d4 = H2[3];
          var e5 = H2[4];
          for (var t5 = 0; t5 < 80; t5++) {
            var s5 = Math.floor(t5 / 20);
            var T3 = ROTL(a5, 5) + f5(s5, b4, c5, d4) + e5 + K2[s5] + W2[t5] >>> 0;
            e5 = d4;
            d4 = c5;
            c5 = ROTL(b4, 30) >>> 0;
            b4 = a5;
            a5 = T3;
          }
          H2[0] = H2[0] + a5 >>> 0;
          H2[1] = H2[1] + b4 >>> 0;
          H2[2] = H2[2] + c5 >>> 0;
          H2[3] = H2[3] + d4 >>> 0;
          H2[4] = H2[4] + e5 >>> 0;
        }
        return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
      }
      var _default = sha1;
      exports21.default = _default;
      module.exports = exports21.default;
    }
  });

  // ../../node_modules/uuid/dist/v5.js
  var require_v5 = __commonJS({
    "../../node_modules/uuid/dist/v5.js"(exports21, module) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      exports21.default = void 0;
      var _v = _interopRequireDefault(require_v35());
      var _sha = _interopRequireDefault(require_sha1_browser());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var v5 = (0, _v.default)("v5", 80, _sha.default);
      var _default = v5;
      exports21.default = _default;
      module.exports = exports21.default;
    }
  });

  // ../../node_modules/uuid/dist/index.js
  var require_dist3 = __commonJS({
    "../../node_modules/uuid/dist/index.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", {
        value: true
      });
      Object.defineProperty(exports21, "v1", {
        enumerable: true,
        get: function() {
          return _v.default;
        }
      });
      Object.defineProperty(exports21, "v3", {
        enumerable: true,
        get: function() {
          return _v2.default;
        }
      });
      Object.defineProperty(exports21, "v4", {
        enumerable: true,
        get: function() {
          return _v3.default;
        }
      });
      Object.defineProperty(exports21, "v5", {
        enumerable: true,
        get: function() {
          return _v4.default;
        }
      });
      var _v = _interopRequireDefault(require_v1());
      var _v2 = _interopRequireDefault(require_v3());
      var _v3 = _interopRequireDefault(require_v4());
      var _v4 = _interopRequireDefault(require_v5());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
    }
  });

  // ../core/dist/servient.js
  var require_servient = __commonJS({
    "../core/dist/servient.js"(exports21) {
      "use strict";
      init_buffer2();
      var __classPrivateFieldGet = exports21 && exports21.__classPrivateFieldGet || function(receiver, state, kind, f5) {
        if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
      };
      var __classPrivateFieldSet = exports21 && exports21.__classPrivateFieldSet || function(receiver, state, value, kind, f5) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
      };
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _Servient_wotInstance;
      var _Servient_shutdown;
      Object.defineProperty(exports21, "__esModule", { value: true });
      var wot_impl_1 = __importDefault(require_wot_impl());
      var content_serdes_1 = __importDefault(require_content_serdes());
      var uuid_1 = require_dist3();
      var logger_1 = require_logger();
      var core_1 = require_core3();
      var { debug, warn } = (0, logger_1.createLoggers)("core", "servient");
      var Servient = class {
        constructor() {
          this.servers = [];
          this.clientFactories = /* @__PURE__ */ new Map();
          this.things = /* @__PURE__ */ new Map();
          this.credentialStore = /* @__PURE__ */ new Map();
          _Servient_wotInstance.set(this, void 0);
          _Servient_shutdown.set(this, false);
        }
        addMediaType(codec, offered = false) {
          content_serdes_1.default.addCodec(codec, offered);
        }
        expose(thing) {
          if (this.servers.length === 0) {
            warn(`Servient has no servers to expose Things`);
            return new Promise((resolve2) => {
              resolve2();
            });
          }
          debug(`Servient exposing '${thing.title}'`);
          const tdTemplate = core_1.Helpers.structuredClone(thing);
          thing.forms = [];
          for (const property of Object.values(thing.properties)) {
            property.forms = [];
          }
          for (const action of Object.values(thing.actions)) {
            action.forms = [];
          }
          for (const event of Object.values(thing.events)) {
            event.forms = [];
          }
          const serverPromises = [];
          this.servers.forEach((server) => {
            serverPromises.push(server.expose(thing, tdTemplate));
          });
          return new Promise((resolve2, reject) => {
            Promise.all(serverPromises).then(() => resolve2()).catch((err) => reject(err));
          });
        }
        addThing(thing) {
          if (!thing.id) {
            thing.id = "urn:uuid:" + (0, uuid_1.v4)();
            warn(`Servient generating ID for '${thing.title}': '${thing.id}'`);
          }
          if (!this.things.has(thing.id)) {
            this.things.set(thing.id, thing);
            debug(`Servient reset ID '${thing.id}' with '${thing.title}'`);
            return true;
          } else {
            return false;
          }
        }
        destroyThing(thingId) {
          return new Promise((resolve2, reject) => {
            if (this.things.has(thingId)) {
              debug(`Servient destroying thing with id '${thingId}'`);
              this.things.delete(thingId);
              const serverPromises = [];
              this.servers.forEach((server) => {
                serverPromises.push(server.destroy(thingId));
              });
              Promise.all(serverPromises).then(() => resolve2(true)).catch((err) => reject(err));
            } else {
              warn(`Servient was asked to destroy thing but failed to find thing with id '${thingId}'`);
              resolve2(false);
            }
          });
        }
        getThing(id) {
          if (this.things.has(id)) {
            return this.things.get(id);
          } else
            return void 0;
        }
        getThings() {
          debug(`Servient getThings size == '${this.things.size}'`);
          const ts = {};
          this.things.forEach((thing, id) => {
            ts[id] = thing.getThingDescription();
          });
          return ts;
        }
        addServer(server) {
          this.things.forEach((thing, id) => server.expose(thing));
          this.servers.push(server);
          return true;
        }
        getServers() {
          return this.servers.slice(0);
        }
        addClientFactory(clientFactory) {
          debug(`Servient adding client factory for '${clientFactory.scheme}'`);
          this.clientFactories.set(clientFactory.scheme, clientFactory);
        }
        removeClientFactory(scheme) {
          debug(`Servient removing client factory for '${scheme}'`);
          this.clientFactories.get(scheme)?.destroy();
          return this.clientFactories.delete(scheme);
        }
        hasClientFor(scheme) {
          debug(`Servient checking for '${scheme}' scheme in ${this.clientFactories.size} ClientFactories`);
          return this.clientFactories.has(scheme);
        }
        getClientFor(scheme) {
          const clientFactory = this.clientFactories.get(scheme);
          if (clientFactory) {
            debug(`Servient creating client for scheme '${scheme}'`);
            return clientFactory.getClient();
          } else {
            throw new Error(`Servient has no ClientFactory for scheme '${scheme}'`);
          }
        }
        getClientSchemes() {
          return Array.from(this.clientFactories.keys());
        }
        addCredentials(credentials) {
          for (const [credentialKey, credentialValue] of Object.entries(credentials ?? {})) {
            debug(`Servient storing credentials for '${credentialKey}'`);
            const currentCredentials = this.credentialStore.get(credentialKey) ?? [];
            if (currentCredentials.length === 0) {
              this.credentialStore.set(credentialKey, currentCredentials);
            }
            currentCredentials.push(credentialValue);
          }
        }
        getCredentials(identifier) {
          debug(`Servient looking up credentials for '${identifier}' (@deprecated)`);
          const currentCredentials = this.credentialStore.get(identifier);
          if (currentCredentials && currentCredentials.length > 0) {
            return currentCredentials[0];
          } else {
            return void 0;
          }
        }
        retrieveCredentials(identifier) {
          debug(`Servient looking up credentials for '${identifier}'`);
          return this.credentialStore.get(identifier);
        }
        async start() {
          if (__classPrivateFieldGet(this, _Servient_wotInstance, "f") !== void 0) {
            debug("Servient started already -> nop -> returning previous WoT implementation");
            return __classPrivateFieldGet(this, _Servient_wotInstance, "f");
          }
          if (__classPrivateFieldGet(this, _Servient_shutdown, "f")) {
            throw Error("Servient cannot be started (again) since it was already stopped");
          }
          const serverStatus = [];
          this.servers.forEach((server) => serverStatus.push(server.start(this)));
          this.clientFactories.forEach((clientFactory) => clientFactory.init());
          await Promise.all(serverStatus);
          return __classPrivateFieldSet(this, _Servient_wotInstance, new wot_impl_1.default(this), "f");
        }
        async shutdown() {
          if (__classPrivateFieldGet(this, _Servient_wotInstance, "f") === void 0) {
            throw Error("Servient cannot be shutdown, wasn't even started");
          }
          if (__classPrivateFieldGet(this, _Servient_shutdown, "f")) {
            debug("Servient shutdown already -> nop");
            return;
          }
          this.clientFactories.forEach((clientFactory) => clientFactory.destroy());
          const promises2 = this.servers.map((server) => server.stop());
          await Promise.all(promises2);
          __classPrivateFieldSet(this, _Servient_shutdown, true, "f");
          __classPrivateFieldSet(this, _Servient_wotInstance, void 0, "f");
        }
      };
      _Servient_wotInstance = /* @__PURE__ */ new WeakMap(), _Servient_shutdown = /* @__PURE__ */ new WeakMap();
      exports21.default = Servient;
    }
  });

  // ../core/dist/core.js
  var require_core3 = __commonJS({
    "../core/dist/core.js"(exports21) {
      "use strict";
      init_buffer2();
      var __createBinding = exports21 && exports21.__createBinding || (Object.create ? function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m4, k3);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k3];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o5[k22] = m4[k3];
      });
      var __exportStar = exports21 && exports21.__exportStar || function(m4, exports22) {
        for (var p5 in m4) if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports22, p5)) __createBinding(exports22, m4, p5);
      };
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.createWarnLogger = exports21.createInfoLogger = exports21.createErrorLogger = exports21.createDebugLogger = exports21.createLoggers = exports21.ProtocolHelpers = exports21.Helpers = exports21.ExposedThing = exports21.ConsumedThing = exports21.DefaultContent = exports21.Content = exports21.NetconfOctetstreamCodecCodec = exports21.Base64Codec = exports21.TextCodec = exports21.CborCodec = exports21.JsonCodec = exports21.Servient = void 0;
      var servient_1 = __importDefault(require_servient());
      exports21.Servient = servient_1.default;
      exports21.default = servient_1.default;
      __exportStar(require_thing_description(), exports21);
      __exportStar(require_serdes(), exports21);
      __exportStar(require_content_serdes(), exports21);
      var json_codec_1 = require_json_codec();
      Object.defineProperty(exports21, "JsonCodec", { enumerable: true, get: function() {
        return __importDefault(json_codec_1).default;
      } });
      var cbor_codec_1 = require_cbor_codec();
      Object.defineProperty(exports21, "CborCodec", { enumerable: true, get: function() {
        return __importDefault(cbor_codec_1).default;
      } });
      var text_codec_1 = require_text_codec();
      Object.defineProperty(exports21, "TextCodec", { enumerable: true, get: function() {
        return __importDefault(text_codec_1).default;
      } });
      var base64_codec_1 = require_base64_codec();
      Object.defineProperty(exports21, "Base64Codec", { enumerable: true, get: function() {
        return __importDefault(base64_codec_1).default;
      } });
      var octetstream_codec_1 = require_octetstream_codec();
      Object.defineProperty(exports21, "NetconfOctetstreamCodecCodec", { enumerable: true, get: function() {
        return __importDefault(octetstream_codec_1).default;
      } });
      __exportStar(require_protocol_interfaces(), exports21);
      var content_1 = require_content();
      Object.defineProperty(exports21, "Content", { enumerable: true, get: function() {
        return content_1.Content;
      } });
      Object.defineProperty(exports21, "DefaultContent", { enumerable: true, get: function() {
        return content_1.DefaultContent;
      } });
      var consumed_thing_1 = require_consumed_thing();
      Object.defineProperty(exports21, "ConsumedThing", { enumerable: true, get: function() {
        return __importDefault(consumed_thing_1).default;
      } });
      var exposed_thing_1 = require_exposed_thing();
      Object.defineProperty(exports21, "ExposedThing", { enumerable: true, get: function() {
        return __importDefault(exposed_thing_1).default;
      } });
      var helpers_1 = require_helpers();
      Object.defineProperty(exports21, "Helpers", { enumerable: true, get: function() {
        return __importDefault(helpers_1).default;
      } });
      var protocol_helpers_1 = require_protocol_helpers();
      Object.defineProperty(exports21, "ProtocolHelpers", { enumerable: true, get: function() {
        return __importDefault(protocol_helpers_1).default;
      } });
      var logger_1 = require_logger();
      Object.defineProperty(exports21, "createLoggers", { enumerable: true, get: function() {
        return logger_1.createLoggers;
      } });
      Object.defineProperty(exports21, "createDebugLogger", { enumerable: true, get: function() {
        return logger_1.createDebugLogger;
      } });
      Object.defineProperty(exports21, "createErrorLogger", { enumerable: true, get: function() {
        return logger_1.createErrorLogger;
      } });
      Object.defineProperty(exports21, "createInfoLogger", { enumerable: true, get: function() {
        return logger_1.createInfoLogger;
      } });
      Object.defineProperty(exports21, "createWarnLogger", { enumerable: true, get: function() {
        return logger_1.createWarnLogger;
      } });
    }
  });

  // ../binding-http/node_modules/node-fetch/browser.js
  var require_browser2 = __commonJS({
    "../binding-http/node_modules/node-fetch/browser.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var getGlobal = function() {
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw new Error("unable to locate global object");
      };
      var globalObject = getGlobal();
      module.exports = exports21 = globalObject.fetch;
      if (globalObject.fetch) {
        exports21.default = globalObject.fetch.bind(globalObject);
      }
      exports21.Headers = globalObject.Headers;
      exports21.Request = globalObject.Request;
      exports21.Response = globalObject.Response;
    }
  });

  // ../../node_modules/rxjs/util/isArray.js
  var require_isArray = __commonJS({
    "../../node_modules/rxjs/util/isArray.js"(exports21) {
      "use strict";
      init_buffer2();
      exports21.isArray = Array.isArray || function(x3) {
        return x3 && typeof x3.length === "number";
      };
    }
  });

  // ../../node_modules/rxjs/util/isObject.js
  var require_isObject = __commonJS({
    "../../node_modules/rxjs/util/isObject.js"(exports21) {
      "use strict";
      init_buffer2();
      function isObject2(x3) {
        return x3 != null && typeof x3 === "object";
      }
      exports21.isObject = isObject2;
    }
  });

  // ../../node_modules/rxjs/util/isFunction.js
  var require_isFunction = __commonJS({
    "../../node_modules/rxjs/util/isFunction.js"(exports21) {
      "use strict";
      init_buffer2();
      function isFunction2(x3) {
        return typeof x3 === "function";
      }
      exports21.isFunction = isFunction2;
    }
  });

  // ../../node_modules/rxjs/util/errorObject.js
  var require_errorObject = __commonJS({
    "../../node_modules/rxjs/util/errorObject.js"(exports21) {
      "use strict";
      init_buffer2();
      exports21.errorObject = { e: {} };
    }
  });

  // ../../node_modules/rxjs/util/tryCatch.js
  var require_tryCatch = __commonJS({
    "../../node_modules/rxjs/util/tryCatch.js"(exports21) {
      "use strict";
      init_buffer2();
      var errorObject_1 = require_errorObject();
      var tryCatchTarget;
      function tryCatcher() {
        try {
          return tryCatchTarget.apply(this, arguments);
        } catch (e5) {
          errorObject_1.errorObject.e = e5;
          return errorObject_1.errorObject;
        }
      }
      function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
      }
      exports21.tryCatch = tryCatch;
    }
  });

  // ../../node_modules/rxjs/util/UnsubscriptionError.js
  var require_UnsubscriptionError = __commonJS({
    "../../node_modules/rxjs/util/UnsubscriptionError.js"(exports21) {
      "use strict";
      init_buffer2();
      var __extends = exports21 && exports21.__extends || function(d4, b4) {
        for (var p5 in b4) if (b4.hasOwnProperty(p5)) d4[p5] = b4[p5];
        function __() {
          this.constructor = d4;
        }
        d4.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
      var UnsubscriptionError = function(_super) {
        __extends(UnsubscriptionError2, _super);
        function UnsubscriptionError2(errors) {
          _super.call(this);
          this.errors = errors;
          var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function(err2, i5) {
            return i5 + 1 + ") " + err2.toString();
          }).join("\n  ") : "");
          this.name = err.name = "UnsubscriptionError";
          this.stack = err.stack;
          this.message = err.message;
        }
        return UnsubscriptionError2;
      }(Error);
      exports21.UnsubscriptionError = UnsubscriptionError;
    }
  });

  // ../../node_modules/rxjs/Subscription.js
  var require_Subscription = __commonJS({
    "../../node_modules/rxjs/Subscription.js"(exports21) {
      "use strict";
      init_buffer2();
      var isArray_1 = require_isArray();
      var isObject_1 = require_isObject();
      var isFunction_1 = require_isFunction();
      var tryCatch_1 = require_tryCatch();
      var errorObject_1 = require_errorObject();
      var UnsubscriptionError_1 = require_UnsubscriptionError();
      var Subscription = function() {
        function Subscription2(unsubscribe) {
          this.closed = false;
          this._parent = null;
          this._parents = null;
          this._subscriptions = null;
          if (unsubscribe) {
            this._unsubscribe = unsubscribe;
          }
        }
        Subscription2.prototype.unsubscribe = function() {
          var hasErrors = false;
          var errors;
          if (this.closed) {
            return;
          }
          var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
          this.closed = true;
          this._parent = null;
          this._parents = null;
          this._subscriptions = null;
          var index = -1;
          var len = _parents ? _parents.length : 0;
          while (_parent) {
            _parent.remove(this);
            _parent = ++index < len && _parents[index] || null;
          }
          if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
              hasErrors = true;
              errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
          }
          if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
              var sub = _subscriptions[index];
              if (isObject_1.isObject(sub)) {
                var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                if (trial === errorObject_1.errorObject) {
                  hasErrors = true;
                  errors = errors || [];
                  var err = errorObject_1.errorObject.e;
                  if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                    errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            }
          }
          if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
          }
        };
        Subscription2.prototype.add = function(teardown) {
          if (!teardown || teardown === Subscription2.EMPTY) {
            return Subscription2.EMPTY;
          }
          if (teardown === this) {
            return this;
          }
          var subscription = teardown;
          switch (typeof teardown) {
            case "function":
              subscription = new Subscription2(teardown);
            case "object":
              if (subscription.closed || typeof subscription.unsubscribe !== "function") {
                return subscription;
              } else if (this.closed) {
                subscription.unsubscribe();
                return subscription;
              } else if (typeof subscription._addParent !== "function") {
                var tmp = subscription;
                subscription = new Subscription2();
                subscription._subscriptions = [tmp];
              }
              break;
            default:
              throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
          }
          var subscriptions = this._subscriptions || (this._subscriptions = []);
          subscriptions.push(subscription);
          subscription._addParent(this);
          return subscription;
        };
        Subscription2.prototype.remove = function(subscription) {
          var subscriptions = this._subscriptions;
          if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
              subscriptions.splice(subscriptionIndex, 1);
            }
          }
        };
        Subscription2.prototype._addParent = function(parent) {
          var _a = this, _parent = _a._parent, _parents = _a._parents;
          if (!_parent || _parent === parent) {
            this._parent = parent;
          } else if (!_parents) {
            this._parents = [parent];
          } else if (_parents.indexOf(parent) === -1) {
            _parents.push(parent);
          }
        };
        Subscription2.EMPTY = function(empty2) {
          empty2.closed = true;
          return empty2;
        }(new Subscription2());
        return Subscription2;
      }();
      exports21.Subscription = Subscription;
      function flattenUnsubscriptionErrors(errors) {
        return errors.reduce(function(errs, err) {
          return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
        }, []);
      }
    }
  });

  // (disabled):../../node_modules/client-oauth2/node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "(disabled):../../node_modules/client-oauth2/node_modules/safe-buffer/index.js"() {
      init_buffer2();
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/querystring.js
  var querystring_exports = {};
  __export(querystring_exports, {
    decode: () => decode,
    default: () => exports17,
    encode: () => encode,
    parse: () => parse,
    stringify: () => stringify
  });
  function dew$28() {
    if (_dewExec$28) return exports$37;
    _dewExec$28 = true;
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    exports$37 = function(qs, sep, eq, options) {
      sep = sep || "&";
      eq = eq || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i5 = 0; i5 < len; ++i5) {
        var x3 = qs[i5].replace(regexp, "%20"), idx = x3.indexOf(eq), kstr, vstr, k3, v5;
        if (idx >= 0) {
          kstr = x3.substr(0, idx);
          vstr = x3.substr(idx + 1);
        } else {
          kstr = x3;
          vstr = "";
        }
        k3 = decodeURIComponent(kstr);
        v5 = decodeURIComponent(vstr);
        if (!hasOwnProperty(obj, k3)) {
          obj[k3] = v5;
        } else if (Array.isArray(obj[k3])) {
          obj[k3].push(v5);
        } else {
          obj[k3] = [obj[k3], v5];
        }
      }
      return obj;
    };
    return exports$37;
  }
  function dew$110() {
    if (_dewExec$110) return exports$210;
    _dewExec$110 = true;
    var stringifyPrimitive = function(v5) {
      switch (typeof v5) {
        case "string":
          return v5;
        case "boolean":
          return v5 ? "true" : "false";
        case "number":
          return isFinite(v5) ? v5 : "";
        default:
          return "";
      }
    };
    exports$210 = function(obj, sep, eq, name2) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return Object.keys(obj).map(function(k3) {
          var ks = encodeURIComponent(stringifyPrimitive(k3)) + eq;
          if (Array.isArray(obj[k3])) {
            return obj[k3].map(function(v5) {
              return ks + encodeURIComponent(stringifyPrimitive(v5));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k3]));
          }
        }).filter(Boolean).join(sep);
      }
      if (!name2) return "";
      return encodeURIComponent(stringifyPrimitive(name2)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
    return exports$210;
  }
  function dew16() {
    if (_dewExec16) return exports$112;
    _dewExec16 = true;
    exports$112.decode = exports$112.parse = dew$28();
    exports$112.encode = exports$112.stringify = dew$110();
    return exports$112;
  }
  var exports$37, _dewExec$28, exports$210, _dewExec$110, exports$112, _dewExec16, exports17, decode, encode, parse, stringify;
  var init_querystring = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/querystring.js"() {
      init_buffer2();
      exports$37 = {};
      _dewExec$28 = false;
      exports$210 = {};
      _dewExec$110 = false;
      exports$112 = {};
      _dewExec16 = false;
      exports17 = dew16();
      exports17["decode"];
      exports17["parse"];
      exports17["encode"];
      exports17["stringify"];
      decode = exports17.decode;
      encode = exports17.encode;
      parse = exports17.parse;
      stringify = exports17.stringify;
    }
  });

  // ../../node_modules/client-oauth2/src/request/browser.js
  var require_browser3 = __commonJS({
    "../../node_modules/client-oauth2/src/request/browser.js"(exports21, module) {
      init_buffer2();
      module.exports = function request3(method, url, body, headers) {
        return new Promise(function(resolve2, reject) {
          var xhr = new window.XMLHttpRequest();
          xhr.open(method, url);
          xhr.onload = function() {
            return resolve2({
              status: xhr.status,
              body: xhr.responseText
            });
          };
          xhr.onerror = xhr.onabort = function() {
            return reject(new Error(xhr.statusText || "XHR aborted: " + url));
          };
          Object.keys(headers).forEach(function(header) {
            xhr.setRequestHeader(header, headers[header]);
          });
          xhr.send(body);
        });
      };
    }
  });

  // ../../node_modules/client-oauth2/src/client-oauth2.js
  var require_client_oauth2 = __commonJS({
    "../../node_modules/client-oauth2/src/client-oauth2.js"(exports21, module) {
      init_buffer2();
      var Buffer3 = require_safe_buffer().Buffer;
      var Querystring = (init_querystring(), __toCommonJS(querystring_exports));
      var defaultRequest = require_browser3();
      var DEFAULT_URL_BASE = "https://example.org/";
      var btoa;
      if (typeof Buffer3 === "function") {
        btoa = btoaBuffer;
      } else {
        btoa = window.btoa.bind(window);
      }
      module.exports = ClientOAuth2;
      var DEFAULT_HEADERS = {
        Accept: "application/json, application/x-www-form-urlencoded",
        "Content-Type": "application/x-www-form-urlencoded"
      };
      var ERROR_RESPONSES = {
        invalid_request: [
          "The request is missing a required parameter, includes an",
          "invalid parameter value, includes a parameter more than",
          "once, or is otherwise malformed."
        ].join(" "),
        invalid_client: [
          "Client authentication failed (e.g., unknown client, no",
          "client authentication included, or unsupported",
          "authentication method)."
        ].join(" "),
        invalid_grant: [
          "The provided authorization grant (e.g., authorization",
          "code, resource owner credentials) or refresh token is",
          "invalid, expired, revoked, does not match the redirection",
          "URI used in the authorization request, or was issued to",
          "another client."
        ].join(" "),
        unauthorized_client: [
          "The client is not authorized to request an authorization",
          "code using this method."
        ].join(" "),
        unsupported_grant_type: [
          "The authorization grant type is not supported by the",
          "authorization server."
        ].join(" "),
        access_denied: [
          "The resource owner or authorization server denied the request."
        ].join(" "),
        unsupported_response_type: [
          "The authorization server does not support obtaining",
          "an authorization code using this method."
        ].join(" "),
        invalid_scope: [
          "The requested scope is invalid, unknown, or malformed."
        ].join(" "),
        server_error: [
          "The authorization server encountered an unexpected",
          "condition that prevented it from fulfilling the request.",
          "(This error code is needed because a 500 Internal Server",
          "Error HTTP status code cannot be returned to the client",
          "via an HTTP redirect.)"
        ].join(" "),
        temporarily_unavailable: [
          "The authorization server is currently unable to handle",
          "the request due to a temporary overloading or maintenance",
          "of the server."
        ].join(" ")
      };
      function btoaBuffer(string) {
        return Buffer3.from(string).toString("base64");
      }
      function expects(obj) {
        for (var i5 = 1; i5 < arguments.length; i5++) {
          var prop = arguments[i5];
          if (obj[prop] == null) {
            throw new TypeError('Expected "' + prop + '" to exist');
          }
        }
      }
      function getAuthError(body) {
        var message = ERROR_RESPONSES[body.error] || body.error_description || body.error;
        if (message) {
          var err = new Error(message);
          err.body = body;
          err.code = "EAUTH";
          return err;
        }
      }
      function parseResponseBody(body) {
        try {
          return JSON.parse(body);
        } catch (e5) {
          return Querystring.parse(body);
        }
      }
      function sanitizeScope(scopes) {
        return Array.isArray(scopes) ? scopes.join(" ") : toString(scopes);
      }
      function createUri(options, tokenType) {
        expects(options, "clientId", "authorizationUri");
        const qs = {
          client_id: options.clientId,
          redirect_uri: options.redirectUri,
          response_type: tokenType,
          state: options.state
        };
        if (options.scopes !== void 0) {
          qs.scope = sanitizeScope(options.scopes);
        }
        const sep = options.authorizationUri.includes("?") ? "&" : "?";
        return options.authorizationUri + sep + Querystring.stringify(
          Object.assign(qs, options.query)
        );
      }
      function auth(username, password) {
        return "Basic " + btoa(toString(username) + ":" + toString(password));
      }
      function toString(str) {
        return str == null ? "" : String(str);
      }
      function requestOptions(requestOptions2, options) {
        return {
          url: requestOptions2.url,
          method: requestOptions2.method,
          body: Object.assign({}, requestOptions2.body, options.body),
          query: Object.assign({}, requestOptions2.query, options.query),
          headers: Object.assign({}, requestOptions2.headers, options.headers)
        };
      }
      function ClientOAuth2(options, request3) {
        this.options = options;
        this.request = request3 || defaultRequest;
        this.code = new CodeFlow(this);
        this.token = new TokenFlow(this);
        this.owner = new OwnerFlow(this);
        this.credentials = new CredentialsFlow(this);
        this.jwt = new JwtBearerFlow(this);
      }
      ClientOAuth2.Token = ClientOAuth2Token;
      ClientOAuth2.prototype.createToken = function(access, refresh, type2, data) {
        var options = Object.assign(
          {},
          data,
          typeof access === "string" ? { access_token: access } : access,
          typeof refresh === "string" ? { refresh_token: refresh } : refresh,
          typeof type2 === "string" ? { token_type: type2 } : type2
        );
        return new ClientOAuth2.Token(this, options);
      };
      ClientOAuth2.prototype._request = function(options) {
        var url = options.url;
        var body = Querystring.stringify(options.body);
        var query = Querystring.stringify(options.query);
        if (query) {
          url += (url.indexOf("?") === -1 ? "?" : "&") + query;
        }
        return this.request(options.method, url, body, options.headers).then(function(res) {
          var body2 = parseResponseBody(res.body);
          var authErr = getAuthError(body2);
          if (authErr) {
            return Promise.reject(authErr);
          }
          if (res.status < 200 || res.status >= 399) {
            var statusErr = new Error("HTTP status " + res.status);
            statusErr.status = res.status;
            statusErr.body = res.body;
            statusErr.code = "ESTATUS";
            return Promise.reject(statusErr);
          }
          return body2;
        });
      };
      function ClientOAuth2Token(client, data) {
        this.client = client;
        this.data = data;
        this.tokenType = data.token_type && data.token_type.toLowerCase();
        this.accessToken = data.access_token;
        this.refreshToken = data.refresh_token;
        this.expiresIn(Number(data.expires_in));
      }
      ClientOAuth2Token.prototype.expiresIn = function(duration) {
        if (typeof duration === "number") {
          this.expires = /* @__PURE__ */ new Date();
          this.expires.setSeconds(this.expires.getSeconds() + duration);
        } else if (duration instanceof Date) {
          this.expires = new Date(duration.getTime());
        } else {
          throw new TypeError("Unknown duration: " + duration);
        }
        return this.expires;
      };
      ClientOAuth2Token.prototype.sign = function(requestObject) {
        if (!this.accessToken) {
          throw new Error("Unable to sign without access token");
        }
        requestObject.headers = requestObject.headers || {};
        if (this.tokenType === "bearer") {
          requestObject.headers.Authorization = "Bearer " + this.accessToken;
        } else {
          var parts = requestObject.url.split("#");
          var token = "access_token=" + this.accessToken;
          var url = parts[0].replace(/[?&]access_token=[^&#]/, "");
          var fragment = parts[1] ? "#" + parts[1] : "";
          requestObject.url = url + (url.indexOf("?") > -1 ? "&" : "?") + token + fragment;
          requestObject.headers.Pragma = "no-store";
          requestObject.headers["Cache-Control"] = "no-store";
        }
        return requestObject;
      };
      ClientOAuth2Token.prototype.refresh = function(opts) {
        var self2 = this;
        var options = Object.assign({}, this.client.options, opts);
        if (!this.refreshToken) {
          return Promise.reject(new Error("No refresh token"));
        }
        return this.client._request(requestOptions({
          url: options.accessTokenUri,
          method: "POST",
          headers: Object.assign({}, DEFAULT_HEADERS, {
            Authorization: auth(options.clientId, options.clientSecret)
          }),
          body: {
            refresh_token: this.refreshToken,
            grant_type: "refresh_token"
          }
        }, options)).then(function(data) {
          return self2.client.createToken(Object.assign({}, self2.data, data));
        });
      };
      ClientOAuth2Token.prototype.expired = function() {
        return Date.now() > this.expires.getTime();
      };
      function OwnerFlow(client) {
        this.client = client;
      }
      OwnerFlow.prototype.getToken = function(username, password, opts) {
        var self2 = this;
        var options = Object.assign({}, this.client.options, opts);
        const body = {
          username,
          password,
          grant_type: "password"
        };
        if (options.scopes !== void 0) {
          body.scope = sanitizeScope(options.scopes);
        }
        return this.client._request(requestOptions({
          url: options.accessTokenUri,
          method: "POST",
          headers: Object.assign({}, DEFAULT_HEADERS, {
            Authorization: auth(options.clientId, options.clientSecret)
          }),
          body
        }, options)).then(function(data) {
          return self2.client.createToken(data);
        });
      };
      function TokenFlow(client) {
        this.client = client;
      }
      TokenFlow.prototype.getUri = function(opts) {
        var options = Object.assign({}, this.client.options, opts);
        return createUri(options, "token");
      };
      TokenFlow.prototype.getToken = function(uri, opts) {
        var options = Object.assign({}, this.client.options, opts);
        var url = typeof uri === "object" ? uri : new URL(uri, DEFAULT_URL_BASE);
        var expectedUrl = new URL(options.redirectUri, DEFAULT_URL_BASE);
        if (typeof url.pathname === "string" && url.pathname !== expectedUrl.pathname) {
          return Promise.reject(
            new TypeError("Redirected path should match configured path, but got: " + url.pathname)
          );
        }
        if (!url.hash && !url.search) {
          return Promise.reject(new TypeError("Unable to process uri: " + uri));
        }
        var data = Object.assign(
          {},
          typeof url.search === "string" ? Querystring.parse(url.search.substr(1)) : url.search || {},
          typeof url.hash === "string" ? Querystring.parse(url.hash.substr(1)) : url.hash || {}
        );
        var err = getAuthError(data);
        if (err) {
          return Promise.reject(err);
        }
        if (options.state != null && data.state !== options.state) {
          return Promise.reject(new TypeError("Invalid state: " + data.state));
        }
        return Promise.resolve(this.client.createToken(data));
      };
      function CredentialsFlow(client) {
        this.client = client;
      }
      CredentialsFlow.prototype.getToken = function(opts) {
        var self2 = this;
        var options = Object.assign({}, this.client.options, opts);
        expects(options, "clientId", "clientSecret", "accessTokenUri");
        const body = {
          grant_type: "client_credentials"
        };
        if (options.scopes !== void 0) {
          body.scope = sanitizeScope(options.scopes);
        }
        return this.client._request(requestOptions({
          url: options.accessTokenUri,
          method: "POST",
          headers: Object.assign({}, DEFAULT_HEADERS, {
            Authorization: auth(options.clientId, options.clientSecret)
          }),
          body
        }, options)).then(function(data) {
          return self2.client.createToken(data);
        });
      };
      function CodeFlow(client) {
        this.client = client;
      }
      CodeFlow.prototype.getUri = function(opts) {
        var options = Object.assign({}, this.client.options, opts);
        return createUri(options, "code");
      };
      CodeFlow.prototype.getToken = function(uri, opts) {
        var self2 = this;
        var options = Object.assign({}, this.client.options, opts);
        expects(options, "clientId", "accessTokenUri");
        var url = typeof uri === "object" ? uri : new URL(uri, DEFAULT_URL_BASE);
        if (typeof options.redirectUri === "string" && typeof url.pathname === "string" && url.pathname !== new URL(options.redirectUri, DEFAULT_URL_BASE).pathname) {
          return Promise.reject(
            new TypeError("Redirected path should match configured path, but got: " + url.pathname)
          );
        }
        if (!url.search || !url.search.substr(1)) {
          return Promise.reject(new TypeError("Unable to process uri: " + uri));
        }
        var data = typeof url.search === "string" ? Querystring.parse(url.search.substr(1)) : url.search || {};
        var err = getAuthError(data);
        if (err) {
          return Promise.reject(err);
        }
        if (options.state != null && data.state !== options.state) {
          return Promise.reject(new TypeError("Invalid state: " + data.state));
        }
        if (!data.code) {
          return Promise.reject(new TypeError("Missing code, unable to request token"));
        }
        var headers = Object.assign({}, DEFAULT_HEADERS);
        var body = { code: data.code, grant_type: "authorization_code", redirect_uri: options.redirectUri };
        if (options.clientSecret) {
          headers.Authorization = auth(options.clientId, options.clientSecret);
        } else {
          body.client_id = options.clientId;
        }
        return this.client._request(requestOptions({
          url: options.accessTokenUri,
          method: "POST",
          headers,
          body
        }, options)).then(function(data2) {
          return self2.client.createToken(data2);
        });
      };
      function JwtBearerFlow(client) {
        this.client = client;
      }
      JwtBearerFlow.prototype.getToken = function(token, opts) {
        var self2 = this;
        var options = Object.assign({}, this.client.options, opts);
        var headers = Object.assign({}, DEFAULT_HEADERS);
        expects(options, "accessTokenUri");
        if (options.clientId) {
          headers.Authorization = auth(options.clientId, options.clientSecret);
        }
        const body = {
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          assertion: token
        };
        if (options.scopes !== void 0) {
          body.scope = sanitizeScope(options.scopes);
        }
        return this.client._request(requestOptions({
          url: options.accessTokenUri,
          method: "POST",
          headers,
          body
        }, options)).then(function(data) {
          return self2.client.createToken(data);
        });
      };
    }
  });

  // ../../node_modules/strict-uri-encode/index.js
  var require_strict_uri_encode = __commonJS({
    "../../node_modules/strict-uri-encode/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x3) => `%${x3.charCodeAt(0).toString(16).toUpperCase()}`);
    }
  });

  // ../../node_modules/decode-uri-component/index.js
  var require_decode_uri_component = __commonJS({
    "../../node_modules/decode-uri-component/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      var token = "%[a-f0-9]{2}";
      var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
      var multiMatcher = new RegExp("(" + token + ")+", "gi");
      function decodeComponents(components, split) {
        try {
          return [decodeURIComponent(components.join(""))];
        } catch (err) {
        }
        if (components.length === 1) {
          return components;
        }
        split = split || 1;
        var left = components.slice(0, split);
        var right = components.slice(split);
        return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
      }
      function decode3(input) {
        try {
          return decodeURIComponent(input);
        } catch (err) {
          var tokens = input.match(singleMatcher) || [];
          for (var i5 = 1; i5 < tokens.length; i5++) {
            input = decodeComponents(tokens, i5).join("");
            tokens = input.match(singleMatcher) || [];
          }
          return input;
        }
      }
      function customDecodeURIComponent(input) {
        var replaceMap = {
          "%FE%FF": "\uFFFD\uFFFD",
          "%FF%FE": "\uFFFD\uFFFD"
        };
        var match = multiMatcher.exec(input);
        while (match) {
          try {
            replaceMap[match[0]] = decodeURIComponent(match[0]);
          } catch (err) {
            var result = decode3(match[0]);
            if (result !== match[0]) {
              replaceMap[match[0]] = result;
            }
          }
          match = multiMatcher.exec(input);
        }
        replaceMap["%C2"] = "\uFFFD";
        var entries = Object.keys(replaceMap);
        for (var i5 = 0; i5 < entries.length; i5++) {
          var key = entries[i5];
          input = input.replace(new RegExp(key, "g"), replaceMap[key]);
        }
        return input;
      }
      module.exports = function(encodedURI) {
        if (typeof encodedURI !== "string") {
          throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
        }
        try {
          encodedURI = encodedURI.replace(/\+/g, " ");
          return decodeURIComponent(encodedURI);
        } catch (err) {
          return customDecodeURIComponent(encodedURI);
        }
      };
    }
  });

  // ../../node_modules/split-on-first/index.js
  var require_split_on_first = __commonJS({
    "../../node_modules/split-on-first/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      module.exports = (string, separator) => {
        if (!(typeof string === "string" && typeof separator === "string")) {
          throw new TypeError("Expected the arguments to be of type `string`");
        }
        if (separator === "") {
          return [string];
        }
        const separatorIndex = string.indexOf(separator);
        if (separatorIndex === -1) {
          return [string];
        }
        return [
          string.slice(0, separatorIndex),
          string.slice(separatorIndex + separator.length)
        ];
      };
    }
  });

  // ../../node_modules/filter-obj/index.js
  var require_filter_obj = __commonJS({
    "../../node_modules/filter-obj/index.js"(exports21, module) {
      "use strict";
      init_buffer2();
      module.exports = function(obj, predicate) {
        var ret = {};
        var keys = Object.keys(obj);
        var isArr = Array.isArray(predicate);
        for (var i5 = 0; i5 < keys.length; i5++) {
          var key = keys[i5];
          var val = obj[key];
          if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
            ret[key] = val;
          }
        }
        return ret;
      };
    }
  });

  // ../../node_modules/query-string/index.js
  var require_query_string = __commonJS({
    "../../node_modules/query-string/index.js"(exports21) {
      "use strict";
      init_buffer2();
      var strictUriEncode = require_strict_uri_encode();
      var decodeComponent = require_decode_uri_component();
      var splitOnFirst = require_split_on_first();
      var filterObject = require_filter_obj();
      var isNullOrUndefined2 = (value) => value === null || value === void 0;
      var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
      function encoderForArrayFormat(options) {
        switch (options.arrayFormat) {
          case "index":
            return (key) => (result, value) => {
              const index = result.length;
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode3(key, options), "[", index, "]"].join("")];
              }
              return [
                ...result,
                [encode3(key, options), "[", encode3(index, options), "]=", encode3(value, options)].join("")
              ];
            };
          case "bracket":
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode3(key, options), "[]"].join("")];
              }
              return [...result, [encode3(key, options), "[]=", encode3(value, options)].join("")];
            };
          case "colon-list-separator":
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode3(key, options), ":list="].join("")];
              }
              return [...result, [encode3(key, options), ":list=", encode3(value, options)].join("")];
            };
          case "comma":
          case "separator":
          case "bracket-separator": {
            const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              value = value === null ? "" : value;
              if (result.length === 0) {
                return [[encode3(key, options), keyValueSep, encode3(value, options)].join("")];
              }
              return [[result, encode3(value, options)].join(options.arrayFormatSeparator)];
            };
          }
          default:
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, encode3(key, options)];
              }
              return [...result, [encode3(key, options), "=", encode3(value, options)].join("")];
            };
        }
      }
      function parserForArrayFormat(options) {
        let result;
        switch (options.arrayFormat) {
          case "index":
            return (key, value, accumulator) => {
              result = /\[(\d*)\]$/.exec(key);
              key = key.replace(/\[\d*\]$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = {};
              }
              accumulator[key][result[1]] = value;
            };
          case "bracket":
            return (key, value, accumulator) => {
              result = /(\[\])$/.exec(key);
              key = key.replace(/\[\]$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = [value];
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
          case "colon-list-separator":
            return (key, value, accumulator) => {
              result = /(:list)$/.exec(key);
              key = key.replace(/:list$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = [value];
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
          case "comma":
          case "separator":
            return (key, value, accumulator) => {
              const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
              const isEncodedArray = typeof value === "string" && !isArray2 && decode3(value, options).includes(options.arrayFormatSeparator);
              value = isEncodedArray ? decode3(value, options) : value;
              const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode3(item, options)) : value === null ? value : decode3(value, options);
              accumulator[key] = newValue;
            };
          case "bracket-separator":
            return (key, value, accumulator) => {
              const isArray2 = /(\[\])$/.test(key);
              key = key.replace(/\[\]$/, "");
              if (!isArray2) {
                accumulator[key] = value ? decode3(value, options) : value;
                return;
              }
              const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode3(item, options));
              if (accumulator[key] === void 0) {
                accumulator[key] = arrayValue;
                return;
              }
              accumulator[key] = [].concat(accumulator[key], arrayValue);
            };
          default:
            return (key, value, accumulator) => {
              if (accumulator[key] === void 0) {
                accumulator[key] = value;
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
        }
      }
      function validateArrayFormatSeparator(value) {
        if (typeof value !== "string" || value.length !== 1) {
          throw new TypeError("arrayFormatSeparator must be single character string");
        }
      }
      function encode3(value, options) {
        if (options.encode) {
          return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
        }
        return value;
      }
      function decode3(value, options) {
        if (options.decode) {
          return decodeComponent(value);
        }
        return value;
      }
      function keysSorter(input) {
        if (Array.isArray(input)) {
          return input.sort();
        }
        if (typeof input === "object") {
          return keysSorter(Object.keys(input)).sort((a5, b4) => Number(a5) - Number(b4)).map((key) => input[key]);
        }
        return input;
      }
      function removeHash(input) {
        const hashStart = input.indexOf("#");
        if (hashStart !== -1) {
          input = input.slice(0, hashStart);
        }
        return input;
      }
      function getHash(url) {
        let hash = "";
        const hashStart = url.indexOf("#");
        if (hashStart !== -1) {
          hash = url.slice(hashStart);
        }
        return hash;
      }
      function extract(input) {
        input = removeHash(input);
        const queryStart = input.indexOf("?");
        if (queryStart === -1) {
          return "";
        }
        return input.slice(queryStart + 1);
      }
      function parseValue(value, options) {
        if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
          value = Number(value);
        } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
          value = value.toLowerCase() === "true";
        }
        return value;
      }
      function parse3(query, options) {
        options = Object.assign({
          decode: true,
          sort: true,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
          parseNumbers: false,
          parseBooleans: false
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const formatter = parserForArrayFormat(options);
        const ret = /* @__PURE__ */ Object.create(null);
        if (typeof query !== "string") {
          return ret;
        }
        query = query.trim().replace(/^[?#&]/, "");
        if (!query) {
          return ret;
        }
        for (const param of query.split("&")) {
          if (param === "") {
            continue;
          }
          let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
          value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode3(value, options);
          formatter(decode3(key, options), value, ret);
        }
        for (const key of Object.keys(ret)) {
          const value = ret[key];
          if (typeof value === "object" && value !== null) {
            for (const k3 of Object.keys(value)) {
              value[k3] = parseValue(value[k3], options);
            }
          } else {
            ret[key] = parseValue(value, options);
          }
        }
        if (options.sort === false) {
          return ret;
        }
        return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
          const value = ret[key];
          if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
            result[key] = keysSorter(value);
          } else {
            result[key] = value;
          }
          return result;
        }, /* @__PURE__ */ Object.create(null));
      }
      exports21.extract = extract;
      exports21.parse = parse3;
      exports21.stringify = (object, options) => {
        if (!object) {
          return "";
        }
        options = Object.assign({
          encode: true,
          strict: true,
          arrayFormat: "none",
          arrayFormatSeparator: ","
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
        const formatter = encoderForArrayFormat(options);
        const objectCopy = {};
        for (const key of Object.keys(object)) {
          if (!shouldFilter(key)) {
            objectCopy[key] = object[key];
          }
        }
        const keys = Object.keys(objectCopy);
        if (options.sort !== false) {
          keys.sort(options.sort);
        }
        return keys.map((key) => {
          const value = object[key];
          if (value === void 0) {
            return "";
          }
          if (value === null) {
            return encode3(key, options);
          }
          if (Array.isArray(value)) {
            if (value.length === 0 && options.arrayFormat === "bracket-separator") {
              return encode3(key, options) + "[]";
            }
            return value.reduce(formatter(key), []).join("&");
          }
          return encode3(key, options) + "=" + encode3(value, options);
        }).filter((x3) => x3.length > 0).join("&");
      };
      exports21.parseUrl = (url, options) => {
        options = Object.assign({
          decode: true
        }, options);
        const [url_, hash] = splitOnFirst(url, "#");
        return Object.assign(
          {
            url: url_.split("?")[0] || "",
            query: parse3(extract(url), options)
          },
          options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode3(hash, options) } : {}
        );
      };
      exports21.stringifyUrl = (object, options) => {
        options = Object.assign({
          encode: true,
          strict: true,
          [encodeFragmentIdentifier]: true
        }, options);
        const url = removeHash(object.url).split("?")[0] || "";
        const queryFromUrl = exports21.extract(object.url);
        const parsedQueryFromUrl = exports21.parse(queryFromUrl, { sort: false });
        const query = Object.assign(parsedQueryFromUrl, object.query);
        let queryString = exports21.stringify(query, options);
        if (queryString) {
          queryString = `?${queryString}`;
        }
        let hash = getHash(object.url);
        if (object.fragmentIdentifier) {
          hash = `#${options[encodeFragmentIdentifier] ? encode3(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
        }
        return `${url}${queryString}${hash}`;
      };
      exports21.pick = (input, filter, options) => {
        options = Object.assign({
          parseFragmentIdentifier: true,
          [encodeFragmentIdentifier]: false
        }, options);
        const { url, query, fragmentIdentifier } = exports21.parseUrl(input, options);
        return exports21.stringifyUrl({
          url,
          query: filterObject(query, filter),
          fragmentIdentifier
        }, options);
      };
      exports21.exclude = (input, filter, options) => {
        const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
        return exports21.pick(input, exclusionFilter, options);
      };
    }
  });

  // ../binding-http/dist/credential.js
  var require_credential = __commonJS({
    "../binding-http/dist/credential.js"(exports21) {
      "use strict";
      init_buffer2();
      var __createBinding = exports21 && exports21.__createBinding || (Object.create ? function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m4, k3);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k3];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o5[k22] = m4[k3];
      });
      var __setModuleDefault = exports21 && exports21.__setModuleDefault || (Object.create ? function(o5, v5) {
        Object.defineProperty(o5, "default", { enumerable: true, value: v5 });
      } : function(o5, v5) {
        o5["default"] = v5;
      });
      var __importStar = exports21 && exports21.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o5) {
          ownKeys = Object.getOwnPropertyNames || function(o6) {
            var ar = [];
            for (var k3 in o6) if (Object.prototype.hasOwnProperty.call(o6, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o5);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i5 = 0; i5 < k3.length; i5++) if (k3[i5] !== "default") __createBinding(result, mod, k3[i5]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.TuyaCustomBearer = exports21.OAuthCredential = exports21.BasicKeyCredential = exports21.BearerCredential = exports21.BasicCredential = exports21.Credential = void 0;
      var node_fetch_1 = __importStar(require_browser2());
      var crypto2 = __importStar((init_empty(), __toCommonJS(empty_exports)));
      var queryString = __importStar(require_query_string());
      var Credential = class {
      };
      exports21.Credential = Credential;
      var BasicCredential = class extends Credential {
        constructor({ username, password }, options) {
          super();
          if (username === void 0 || password === void 0 || username === null || password === null) {
            throw new Error(`No Basic credentials for Thing`);
          }
          this.username = username;
          this.password = password;
          this.options = options;
        }
        async sign(request3) {
          const result = request3.clone();
          let headerName = "authorization";
          if (this.options !== void 0 && this.options.in === "header" && this.options.name !== void 0) {
            headerName = this.options.name;
          }
          result.headers.set(headerName, "Basic " + Buffer2.from(this.username + ":" + this.password).toString("base64"));
          return result;
        }
      };
      exports21.BasicCredential = BasicCredential;
      var BearerCredential = class extends Credential {
        constructor({ token }, options) {
          super();
          if (token === void 0 || token === null) {
            throw new Error(`No Bearer credentials for Thing`);
          }
          this.token = token;
          this.options = options;
        }
        async sign(request3) {
          const result = request3.clone();
          let headerName = "authorization";
          if (this.options.in === "header" && this.options.name !== void 0) {
            headerName = this.options.name;
          }
          result.headers.set(headerName, "Bearer " + this.token);
          return result;
        }
      };
      exports21.BearerCredential = BearerCredential;
      var BasicKeyCredential = class extends Credential {
        constructor({ apiKey }, options) {
          super();
          if (apiKey === void 0 || apiKey === null) {
            throw new Error(`No API key credentials for Thing`);
          }
          this.apiKey = apiKey;
          this.options = options;
        }
        async sign(request3) {
          const result = request3.clone();
          let headerName = "authorization";
          if (this.options.in === "header" && this.options.name !== void 0) {
            headerName = this.options.name;
          }
          result.headers.append(headerName, this.apiKey);
          return result;
        }
      };
      exports21.BasicKeyCredential = BasicKeyCredential;
      var OAuthCredential = class _OAuthCredential extends Credential {
        constructor(token, refresh) {
          super();
          this.token = token;
          this.refresh = refresh;
          this.token = token;
        }
        async sign(request3) {
          if (this.token instanceof Promise) {
            const tokenRequest = this.token;
            this.token = await tokenRequest;
          }
          let tempRequest = { url: request3.url, headers: {} };
          tempRequest = this.token.sign(tempRequest);
          const mergeHeaders = new node_fetch_1.Request(request3, tempRequest);
          return mergeHeaders;
        }
        async refreshToken() {
          if (this.token instanceof Promise) {
            throw new Error("Uninitialized token. You have to call sing before refresh");
          }
          let newToken;
          if (this.refresh) {
            newToken = await this.refresh();
          } else {
            newToken = await this.token.refresh();
          }
          return new _OAuthCredential(newToken, this.refresh);
        }
      };
      exports21.OAuthCredential = OAuthCredential;
      var TuyaCustomBearer = class extends Credential {
        constructor(credentials, scheme) {
          super();
          this.key = credentials.key;
          this.secret = credentials.secret;
          this.baseUri = scheme.baseUri;
        }
        async sign(request3) {
          const isTokenExpired = this.isTokenExpired();
          if (this.token === void 0 || this.token === "" || isTokenExpired)
            await this.requestAndRefreshToken(isTokenExpired);
          const url = request3.url;
          const body = request3.body?.read().toString();
          const method = request3.method;
          const headers = this.getHeaders(true, request3.headers.raw(), body, url, method);
          Object.assign(headers, request3.headers.raw());
          return new node_fetch_1.Request(url, { method, body: body !== "" ? body : void 0, headers });
        }
        async requestAndRefreshToken(refresh) {
          const headers = this.getHeaders(false, {});
          const request3 = {
            headers,
            method: "GET"
          };
          let url = `${this.baseUri}/token?grant_type=1`;
          if (refresh) {
            url = `${this.baseUri}/token/${this.refreshToken}`;
          }
          const data = await (await (0, node_fetch_1.default)(url, request3)).json();
          const success = data.success ?? false;
          if (success) {
            this.token = data.result?.access_token;
            this.refreshToken = data.result?.refresh_token;
            const expireTime = data.result?.expire_time;
            if (expireTime != null) {
              this.expireTime = new Date(Date.now() + expireTime * 1e3);
            }
          } else {
            throw new Error("token fetch failed");
          }
        }
        getHeaders(NormalRequest, headers, body, url, method) {
          const requestTime = Date.now().toString();
          const replaceUri = this.baseUri.replace("/v1.0", "");
          const _url = url?.replace(replaceUri, "");
          const sign = this.requestSign(NormalRequest, requestTime, body, _url, method);
          return {
            t: requestTime,
            client_id: this.key,
            sign_method: "HMAC-SHA256",
            sign,
            access_token: this.token ?? ""
          };
        }
        requestSign(NormalRequest, requestTime, body, path2 = "", method) {
          const bodyHash = crypto2.createHash("sha256").update(body ?? "").digest("hex");
          let signUrl = "/v1.0/token?grant_type=1";
          const headerString = "";
          let useToken = "";
          const _method = method ?? "GET";
          if (NormalRequest) {
            useToken = this.token ?? "";
            const pathQuery = queryString.parse(path2.split("?")[1]);
            let query = {};
            query = Object.assign(query, pathQuery);
            const sortedQuery = {};
            Object.keys(query).sort().forEach((i5) => {
              sortedQuery[i5] = query[i5];
            });
            const qs = queryString.stringify(sortedQuery);
            signUrl = decodeURIComponent(qs ? `${path2.split("?")[0]}?${qs}` : path2);
          }
          const endStr = [this.key, useToken, requestTime, [_method, bodyHash, headerString, signUrl].join("\n")].join("");
          const sign = crypto2.createHmac("sha256", this.secret).update(endStr).digest("hex").toUpperCase();
          return sign;
        }
        isTokenExpired() {
          return this.expireTime ? Date.now() > this.expireTime.getTime() : false;
        }
      };
      exports21.TuyaCustomBearer = TuyaCustomBearer;
    }
  });

  // ../binding-http/dist/oauth-manager.js
  var require_oauth_manager = __commonJS({
    "../binding-http/dist/oauth-manager.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      var core_1 = require_core3();
      var client_oauth2_1 = __importDefault(require_client_oauth2());
      var https_1 = (init_https(), __toCommonJS(https_exports));
      var credential_1 = require_credential();
      function createRequestFunction(rejectUnauthorized) {
        return (method, url, body, headers) => {
          return new Promise((resolve2, reject) => {
            const parsedURL = new URL(url);
            const options = {
              method,
              host: parsedURL.hostname,
              port: parseInt(parsedURL.port),
              path: parsedURL.pathname + parsedURL.search,
              headers
            };
            options.rejectUnauthorized = rejectUnauthorized;
            const req = (0, https_1.request)(options);
            req.on("response", (response) => {
              response.setEncoding("utf8");
              const body2 = [];
              response.on("data", (data) => {
                body2.push(data);
              });
              response.on("end", () => {
                resolve2({
                  status: response.statusCode ?? 500,
                  body: body2.toString()
                });
              });
            });
            req.on("error", (er) => {
              reject(er);
            });
            req.write(body);
            req.end();
          });
        };
      }
      var OAuthManager = class {
        constructor() {
          this.tokenStore = /* @__PURE__ */ new Map();
        }
        handleClient(securityScheme, credentials) {
          const clientFlow = new client_oauth2_1.default({
            clientId: credentials.clientId,
            clientSecret: credentials.clientSecret,
            accessTokenUri: securityScheme.token,
            scopes: core_1.Helpers.toStringArray(securityScheme.scopes),
            body: {}
          }, createRequestFunction(false));
          const token = clientFlow.credentials.getToken();
          return new credential_1.OAuthCredential(token, clientFlow.credentials.getToken.bind(clientFlow.credentials));
        }
        handleResourceOwnerCredential(securityScheme, credentials) {
          const clientFlow = new client_oauth2_1.default({
            clientId: credentials.clientId,
            clientSecret: credentials.clientSecret,
            accessTokenUri: securityScheme.token,
            scopes: core_1.Helpers.toStringArray(securityScheme.scopes)
          }, createRequestFunction(false));
          const token = clientFlow.owner.getToken(credentials.username, credentials.password);
          return new credential_1.OAuthCredential(token);
        }
      };
      exports21.default = OAuthManager;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/punycode.js
  function dew17() {
    if (_dewExec17) return exports$113;
    _dewExec17 = true;
    const maxInt = 2147483647;
    const base = 36;
    const tMin = 1;
    const tMax = 26;
    const skew = 38;
    const damp = 700;
    const initialBias = 72;
    const initialN = 128;
    const delimiter = "-";
    const regexPunycode = /^xn--/;
    const regexNonASCII = /[^\0-\x7F]/;
    const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    const errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    const baseMinusTMin = base - tMin;
    const floor = Math.floor;
    const stringFromCharCode = String.fromCharCode;
    function error(type2) {
      throw new RangeError(errors[type2]);
    }
    function map(array, callback) {
      const result = [];
      let length = array.length;
      while (length--) {
        result[length] = callback(array[length]);
      }
      return result;
    }
    function mapDomain(domain2, callback) {
      const parts = domain2.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        domain2 = parts[1];
      }
      domain2 = domain2.replace(regexSeparators, ".");
      const labels = domain2.split(".");
      const encoded = map(labels, callback).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      const output = [];
      let counter = 0;
      const length = string.length;
      while (counter < length) {
        const value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          const extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
    const basicToDigit = function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    };
    const digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    const adapt = function(delta, numPoints, firstTime) {
      let k3 = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k3 += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k3 + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    const decode3 = function(input) {
      const output = [];
      const inputLength = input.length;
      let i5 = 0;
      let n5 = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j3 = 0; j3 < basic; ++j3) {
        if (input.charCodeAt(j3) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j3));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i5;
        for (let w3 = 1, k3 = base; ; k3 += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base) {
            error("invalid-input");
          }
          if (digit > floor((maxInt - i5) / w3)) {
            error("overflow");
          }
          i5 += digit * w3;
          const t5 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
          if (digit < t5) {
            break;
          }
          const baseMinusT = base - t5;
          if (w3 > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w3 *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i5 - oldi, out, oldi == 0);
        if (floor(i5 / out) > maxInt - n5) {
          error("overflow");
        }
        n5 += floor(i5 / out);
        i5 %= out;
        output.splice(i5++, 0, n5);
      }
      return String.fromCodePoint(...output);
    };
    const encode3 = function(input) {
      const output = [];
      input = ucs2decode(input);
      const inputLength = input.length;
      let n5 = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m4 = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n5 && currentValue < m4) {
            m4 = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m4 - n5 > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m4 - n5) * handledCPCountPlusOne;
        n5 = m4;
        for (const currentValue of input) {
          if (currentValue < n5 && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue === n5) {
            let q2 = delta;
            for (let k3 = base; ; k3 += base) {
              const t5 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
              if (q2 < t5) {
                break;
              }
              const qMinusT = q2 - t5;
              const baseMinusT = base - t5;
              output.push(stringFromCharCode(digitToBasic(t5 + qMinusT % baseMinusT, 0)));
              q2 = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q2, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n5;
      }
      return output.join("");
    };
    const toUnicode2 = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode3(string.slice(4).toLowerCase()) : string;
      });
    };
    const toASCII2 = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode3(string) : string;
      });
    };
    const punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.3.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode3,
      "encode": encode3,
      "toASCII": toASCII2,
      "toUnicode": toUnicode2
    };
    exports$113 = punycode;
    return exports$113;
  }
  var exports$113, _dewExec17, exports18, decode2, encode2, toASCII, toUnicode, ucs2, version3;
  var init_punycode = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/punycode.js"() {
      init_buffer2();
      exports$113 = {};
      _dewExec17 = false;
      exports18 = dew17();
      decode2 = exports18.decode;
      encode2 = exports18.encode;
      toASCII = exports18.toASCII;
      toUnicode = exports18.toUnicode;
      ucs2 = exports18.ucs2;
      version3 = exports18.version;
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/chunk-BlJi4mNy.js
  function dew18() {
    if (_dewExec18) return exports$114;
    _dewExec18 = true;
    var process$1 = process2;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i5 = 0; i5 <= path2.length; ++i5) {
        if (i5 < path2.length) code = path2.charCodeAt(i5);
        else if (code === 47) break;
        else code = 47;
        if (code === 47) {
          if (lastSlash === i5 - 1 || dots === 1) ;
          else if (lastSlash !== i5 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i5;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i5;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0) res += "/..";
              else res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0) res += "/" + path2.slice(lastSlash + 1, i5);
            else res = path2.slice(lastSlash + 1, i5);
            lastSegmentLength = i5 - lastSlash - 1;
          }
          lastSlash = i5;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve2() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd2;
        for (var i5 = arguments.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
          var path2;
          if (i5 >= 0) path2 = arguments[i5];
          else {
            if (cwd2 === void 0) cwd2 = process$1.cwd();
            path2 = cwd2;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0) return "/" + resolvedPath;
          else return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var isAbsolute = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute);
        if (path2.length === 0 && !isAbsolute) path2 = ".";
        if (path2.length > 0 && trailingSeparator) path2 += "/";
        if (isAbsolute) return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0) return ".";
        var joined;
        for (var i5 = 0; i5 < arguments.length; ++i5) {
          var arg = arguments[i5];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0) joined = arg;
            else joined += "/" + arg;
          }
        }
        if (joined === void 0) return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47) break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i5 = 0;
        for (; i5 <= length; ++i5) {
          if (i5 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i5) === 47) {
                return to.slice(toStart + i5 + 1);
              } else if (i5 === 0) {
                return to.slice(toStart + i5);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i5) === 47) {
                lastCommonSep = i5;
              } else if (i5 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i5);
          var toCode = to.charCodeAt(toStart + i5);
          if (fromCode !== toCode) break;
          else if (fromCode === 47) lastCommonSep = i5;
        }
        var out = "";
        for (i5 = fromStart + lastCommonSep + 1; i5 <= fromEnd; ++i5) {
          if (i5 === fromEnd || from.charCodeAt(i5) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
          }
        }
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47) ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path2) {
        return path2;
      },
      dirname: function dirname(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var code = path2.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i5 = path2.length - 1; i5 >= 1; --i5) {
          code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              end = i5;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path2.slice(0, end);
      },
      basename: function basename(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i5;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i5 = path2.length - 1; i5 >= 0; --i5) {
            var code = path2.charCodeAt(i5);
            if (code === 47) {
              if (!matchedSlash) {
                start = i5 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i5 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i5;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i5 = path2.length - 1; i5 >= 0; --i5) {
            if (path2.charCodeAt(i5) === 47) {
              if (!matchedSlash) {
                start = i5 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i5 + 1;
            }
          }
          if (end === -1) return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i5 = path2.length - 1; i5 >= 0; --i5) {
          var code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i5 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i5;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format3(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse3(path2) {
        assertPath(path2);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path2.length === 0) return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i5 = path2.length - 1;
        var preDotState = 0;
        for (; i5 >= start; --i5) {
          code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i5 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i5;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end);
            else ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    exports$114 = posix;
    return exports$114;
  }
  var exports$114, _dewExec18, exports19;
  var init_chunk_BlJi4mNy = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/chunk-BlJi4mNy.js"() {
      init_buffer2();
      init_chunk_DEMDiNwt();
      exports$114 = {};
      _dewExec18 = false;
      exports19 = dew18();
    }
  });

  // ../../node_modules/@jspm/core/nodelibs/browser/url.js
  var url_exports = {};
  __export(url_exports, {
    URL: () => _URL,
    Url: () => Url,
    default: () => exports20,
    fileURLToPath: () => fileURLToPath2,
    format: () => format2,
    parse: () => parse2,
    pathToFileURL: () => pathToFileURL2,
    resolve: () => resolve,
    resolveObject: () => resolveObject
  });
  function dew$76() {
    if (_dewExec$76) return exports$86;
    _dewExec$76 = true;
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O4) {
      return O4.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = empty;
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol2(inspectCustom) ? inspectCustom : null;
    exports$86 = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && opts.quoteStyle !== "single" && opts.quoteStyle !== "double") {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray2(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect2(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp2(obj)) {
        var name2 = nameOf(obj);
        var keys = arrObjKeys(obj, inspect2);
        return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol2(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s5 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i5 = 0; i5 < attrs.length; i5++) {
          s5 += " " + attrs[i5].name + "=" + wrapQuotes(quote(attrs[i5].value), "double", opts);
        }
        s5 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s5 += "...";
        }
        s5 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s5;
      }
      if (isArray2(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect2);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError2(obj)) {
        var parts = arrObjKeys(obj, inspect2);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, {
            depth: maxDepth - depth
          });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect2(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber2(obj)) {
        return markBoxed(inspect2(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect2(bigIntValueOf.call(obj)));
      }
      if (isBoolean2(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString2(obj)) {
        return markBoxed(inspect2(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof _global8 !== "undefined" && obj === _global8) {
        return "{ [object globalThis] }";
      }
      if (!isDate2(obj) && !isRegExp2(obj)) {
        var ys = arrObjKeys(obj, inspect2);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s5, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s5 + quoteChar;
    }
    function quote(s5) {
      return $replace.call(String(s5), /"/g, "&quot;");
    }
    function isArray2(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate2(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp2(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError2(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString2(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber2(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean2(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol2(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e5) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e5) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in (this || _global8);
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f5) {
      if (f5.name) {
        return f5.name;
      }
      var m4 = $match.call(functionToString.call(f5), /^function\s*([\w$]+)/);
      if (m4) {
        return m4[1];
      }
      return null;
    }
    function indexOf(xs, x3) {
      if (xs.indexOf) {
        return xs.indexOf(x3);
      }
      for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
        if (xs[i5] === x3) {
          return i5;
        }
      }
      return -1;
    }
    function isMap(x3) {
      if (!mapSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        mapSize.call(x3);
        try {
          setSize.call(x3);
        } catch (s5) {
          return true;
        }
        return x3 instanceof Map;
      } catch (e5) {
      }
      return false;
    }
    function isWeakMap(x3) {
      if (!weakMapHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x3, weakMapHas);
        try {
          weakSetHas.call(x3, weakSetHas);
        } catch (s5) {
          return true;
        }
        return x3 instanceof WeakMap;
      } catch (e5) {
      }
      return false;
    }
    function isWeakRef(x3) {
      if (!weakRefDeref || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x3);
        return true;
      } catch (e5) {
      }
      return false;
    }
    function isSet(x3) {
      if (!setSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        setSize.call(x3);
        try {
          mapSize.call(x3);
        } catch (m4) {
          return true;
        }
        return x3 instanceof Set;
      } catch (e5) {
      }
      return false;
    }
    function isWeakSet(x3) {
      if (!weakSetHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x3, weakSetHas);
        try {
          weakMapHas.call(x3, weakMapHas);
        } catch (s5) {
          return true;
        }
        return x3 instanceof WeakSet;
      } catch (e5) {
      }
      return false;
    }
    function isElement(x3) {
      if (!x3 || typeof x3 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x3 instanceof HTMLElement) {
        return true;
      }
      return typeof x3.nodeName === "string" && typeof x3.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s5 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s5, "single", opts);
    }
    function lowbyte(c5) {
      var n5 = c5.charCodeAt(0);
      var x3 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n5];
      if (x3) {
        return "\\" + x3;
      }
      return "\\x" + (n5 < 16 ? "0" : "") + $toUpperCase.call(n5.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type2) {
      return type2 + " { ? }";
    }
    function collectionOf(type2, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type2 + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i5 = 0; i5 < xs.length; i5++) {
        if (indexOf(xs[i5], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect2) {
      var isArr = isArray2(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i5 = 0; i5 < obj.length; i5++) {
          xs[i5] = has(obj, i5) ? inspect2(obj[i5], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k3 = 0; k3 < syms.length; k3++) {
          symMap["$" + syms[k3]] = syms[k3];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect2(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j3 = 0; j3 < syms.length; j3++) {
          if (isEnumerable.call(obj, syms[j3])) {
            xs.push("[" + inspect2(syms[j3]) + "]: " + inspect2(obj[syms[j3]], obj));
          }
        }
      }
      return xs;
    }
    return exports$86;
  }
  function dew$67() {
    if (_dewExec$67) return exports$77;
    _dewExec$67 = true;
    var GetIntrinsic = dew$73();
    var callBound = dew13();
    var inspect2 = dew$76();
    var $TypeError = dew$e3();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('.').ListNode<typeof value>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    exports$77 = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect2(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = {
                key: {},
                next: null
              };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
    return exports$77;
  }
  function dew$57() {
    if (_dewExec$57) return exports$67;
    _dewExec$57 = true;
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    exports$67 = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
    return exports$67;
  }
  function dew$47() {
    if (_dewExec$47) return exports$57;
    _dewExec$47 = true;
    var formats = dew$57();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i5 = 0; i5 < 256; ++i5) {
        array.push("%" + ((i5 < 16 ? "0" : "") + i5.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue2) {
      while (queue2.length > 1) {
        var item = queue2.pop();
        var obj = item.obj[item.prop];
        if (isArray2(obj)) {
          var compacted = [];
          for (var j3 = 0; j3 < obj.length; ++j3) {
            if (typeof obj[j3] !== "undefined") {
              compacted.push(obj[j3]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i5 = 0; i5 < source.length; ++i5) {
        if (typeof source[i5] !== "undefined") {
          obj[i5] = source[i5];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray2(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray2(target) && !isArray2(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray2(target) && isArray2(source)) {
        source.forEach(function(item, i5) {
          if (has.call(target, i5)) {
            var targetItem = target[i5];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i5] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i5] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode3 = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e5) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode3 = function encode4(str, defaultEncoder, charset, kind, format3) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j3 = 0; j3 < string.length; j3 += limit) {
        var segment = string.length >= limit ? string.slice(j3, j3 + limit) : string;
        var arr = [];
        for (var i5 = 0; i5 < segment.length; ++i5) {
          var c5 = segment.charCodeAt(i5);
          if (c5 === 45 || c5 === 46 || c5 === 95 || c5 === 126 || c5 >= 48 && c5 <= 57 || c5 >= 65 && c5 <= 90 || c5 >= 97 && c5 <= 122 || format3 === formats.RFC1738 && (c5 === 40 || c5 === 41)) {
            arr[arr.length] = segment.charAt(i5);
            continue;
          }
          if (c5 < 128) {
            arr[arr.length] = hexTable[c5];
            continue;
          }
          if (c5 < 2048) {
            arr[arr.length] = hexTable[192 | c5 >> 6] + hexTable[128 | c5 & 63];
            continue;
          }
          if (c5 < 55296 || c5 >= 57344) {
            arr[arr.length] = hexTable[224 | c5 >> 12] + hexTable[128 | c5 >> 6 & 63] + hexTable[128 | c5 & 63];
            continue;
          }
          i5 += 1;
          c5 = 65536 + ((c5 & 1023) << 10 | segment.charCodeAt(i5) & 1023);
          arr[arr.length] = hexTable[240 | c5 >> 18] + hexTable[128 | c5 >> 12 & 63] + hexTable[128 | c5 >> 6 & 63] + hexTable[128 | c5 & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue2 = [{
        obj: {
          o: value
        },
        prop: "o"
      }];
      var refs = [];
      for (var i5 = 0; i5 < queue2.length; ++i5) {
        var item = queue2[i5];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j3 = 0; j3 < keys.length; ++j3) {
          var key = keys[j3];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue2.push({
              obj,
              prop: key
            });
            refs.push(val);
          }
        }
      }
      compactQueue(queue2);
      return value;
    };
    var isRegExp2 = function isRegExp3(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer2 = function isBuffer3(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a5, b4) {
      return [].concat(a5, b4);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray2(val)) {
        var mapped = [];
        for (var i5 = 0; i5 < val.length; i5 += 1) {
          mapped.push(fn(val[i5]));
        }
        return mapped;
      }
      return fn(val);
    };
    exports$57 = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode: decode3,
      encode: encode3,
      isBuffer: isBuffer2,
      isRegExp: isRegExp2,
      maybeMap,
      merge
    };
    return exports$57;
  }
  function dew$37() {
    if (_dewExec$37) return exports$47;
    _dewExec$37 = true;
    var getSideChannel = dew$67();
    var utils = dew$47();
    var formats = dew$57();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray2 = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v5) {
      return typeof v5 === "string" || typeof v5 === "number" || typeof v5 === "boolean" || typeof v5 === "symbol" || typeof v5 === "bigint";
    };
    var sentinel = {};
    var stringify2 = function stringify3(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format3, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format3) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format3);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format3))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray2(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{
          value: obj.length > 0 ? obj.join(",") || null : void 0
        }];
      } else if (isArray2(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, "%2E") : prefix;
      var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray2(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j3 = 0; j3 < objKeys.length; ++j3) {
        var key = objKeys[j3];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
        var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify3(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format3, formatter, encodeValuesOnly, charset, valueSideChannel));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format3 = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format3 = opts.format;
      }
      var formatter = formats.formatters[format3];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray2(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format: format3,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    exports$47 = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray2(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i5 = 0; i5 < objKeys.length; ++i5) {
        var key = objKeys[i5];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify2(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
    return exports$47;
  }
  function dew$29() {
    if (_dewExec$29) return exports$38;
    _dewExec$29 = true;
    var utils = dew$47();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {
        __proto__: null
      };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i5;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i5 = 0; i5 < parts.length; ++i5) {
          if (parts[i5].indexOf("utf8=") === 0) {
            if (parts[i5] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i5] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i5;
            i5 = parts.length;
          }
        }
      }
      for (i5 = 0; i5 < parts.length; ++i5) {
        if (i5 === skipIndex) {
          continue;
        }
        var part = parts[i5];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
            return options.decoder(encodedVal, defaults.decoder, charset, "value");
          });
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray2(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i5 = chain.length - 1; i5 >= 0; --i5) {
        var obj;
        var root = chain[i5];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = {
              0: leaf
            };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i5 = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i5 < options.depth) {
        i5 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    exports$38 = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i5 = 0; i5 < keys.length; ++i5) {
        var key = keys[i5];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
    return exports$38;
  }
  function dew$111() {
    if (_dewExec$111) return exports$211;
    _dewExec$111 = true;
    var stringify2 = dew$37();
    var parse3 = dew$29();
    var formats = dew$57();
    exports$211 = {
      formats,
      parse: parse3,
      stringify: stringify2
    };
    return exports$211;
  }
  function dew19() {
    if (_dewExec19) return exports$115;
    _dewExec19 = true;
    var punycode = exports18;
    function Url2() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
      javascript: true,
      "javascript:": true
    }, hostlessProtocol = {
      javascript: true,
      "javascript:": true
    }, slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    }, querystring = dew$111();
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && typeof url === "object" && url instanceof Url2) {
        return url;
      }
      var u5 = new Url2();
      u5.parse(url, parseQueryString, slashesDenoteHost);
      return u5;
    }
    Url2.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (typeof url !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url = uSplit.join(splitter);
      var rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i5 = 0; i5 < hostEndingChars.length; i5++) {
          var hec = rest.indexOf(hostEndingChars[i5]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i5 = 0; i5 < nonHostChars.length; i5++) {
          var hec = rest.indexOf(nonHostChars[i5]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i5 = 0, l5 = hostparts.length; i5 < l5; i5++) {
            var part = hostparts[i5];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j3 = 0, k3 = part.length; j3 < k3; j3++) {
                if (part.charCodeAt(j3) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j3];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i5);
                var notHost = hostparts.slice(i5 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p5 = this.port ? ":" + this.port : "";
        var h5 = this.hostname || "";
        this.host = h5 + p5;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i5 = 0, l5 = autoEscape.length; i5 < l5; i5++) {
          var ae2 = autoEscape[i5];
          if (rest.indexOf(ae2) === -1) {
            continue;
          }
          var esc = encodeURIComponent(ae2);
          if (esc === ae2) {
            esc = escape(ae2);
          }
          rest = rest.split(ae2).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p5 = this.pathname || "";
        var s5 = this.search || "";
        this.path = p5 + s5;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (typeof obj === "string") {
        obj = urlParse(obj);
      }
      if (!(obj instanceof Url2)) {
        return Url2.prototype.format.call(obj);
      }
      return obj.format();
    }
    Url2.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
        query = querystring.stringify(this.query, {
          arrayFormat: "repeat",
          addQueryPrefix: false
        });
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":") {
        protocol += ":";
      }
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/") {
          pathname = "/" + pathname;
        }
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#") {
        hash = "#" + hash;
      }
      if (search && search.charAt(0) !== "?") {
        search = "?" + search;
      }
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    Url2.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    function urlResolveObject(source, relative) {
      if (!source) {
        return relative;
      }
      return urlParse(source, false, true).resolveObject(relative);
    }
    Url2.prototype.resolveObject = function(relative) {
      if (typeof relative === "string") {
        var rel = new Url2();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url2();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol") {
            result[rkey] = relative[rkey];
          }
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.pathname = "/";
          result.path = result.pathname;
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v5 = 0; v5 < keys.length; v5++) {
            var k3 = keys[v5];
            result[k3] = relative[k3];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift())) {
          }
          if (!relative.host) {
            relative.host = "";
          }
          if (!relative.hostname) {
            relative.hostname = "";
          }
          if (relPath[0] !== "") {
            relPath.unshift("");
          }
          if (relPath.length < 2) {
            relPath.unshift("");
          }
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p5 = result.pathname || "";
          var s5 = result.search || "";
          result.path = p5 + s5;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "") {
            srcPath[0] = result.host;
          } else {
            srcPath.unshift(result.host);
          }
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "") {
              relPath[0] = relative.host;
            } else {
              relPath.unshift(relative.host);
            }
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath) {
          srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (relative.search != null) {
        if (psychotic) {
          result.host = srcPath.shift();
          result.hostname = result.host;
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.hostname = authInHost.shift();
            result.host = result.hostname;
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (result.pathname !== null || result.search !== null) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i5 = srcPath.length; i5 >= 0; i5--) {
        last = srcPath[i5];
        if (last === ".") {
          srcPath.splice(i5, 1);
        } else if (last === "..") {
          srcPath.splice(i5, 1);
          up++;
        } else if (up) {
          srcPath.splice(i5, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        result.host = result.hostname;
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.hostname = authInHost.shift();
          result.host = result.hostname;
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (srcPath.length > 0) {
        result.pathname = srcPath.join("/");
      } else {
        result.pathname = null;
        result.path = null;
      }
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url2.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    exports$115.parse = urlParse;
    exports$115.resolve = urlResolve;
    exports$115.resolveObject = urlResolveObject;
    exports$115.format = urlFormat;
    exports$115.Url = Url2;
    return exports$115;
  }
  function fileURLToPath2(path2) {
    if (typeof path2 === "string") path2 = new URL(path2);
    else if (!(path2 instanceof URL)) {
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    }
    if (path2.protocol !== "file:") {
      throw new Deno.errors.InvalidData("invalid url scheme");
    }
    return isWindows2 ? getPathFromURLWin2(path2) : getPathFromURLPosix2(path2);
  }
  function getPathFromURLWin2(url) {
    const hostname2 = url.hostname;
    let pathname = url.pathname;
    for (let n5 = 0; n5 < pathname.length; n5++) {
      if (pathname[n5] === "%") {
        const third = pathname.codePointAt(n5 + 2) || 32;
        if (pathname[n5 + 1] === "2" && third === 102 || // 2f 2F /
        pathname[n5 + 1] === "5" && third === 99) {
          throw new Deno.errors.InvalidData(
            "must not include encoded \\ or / characters"
          );
        }
      }
    }
    pathname = pathname.replace(forwardSlashRegEx2, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname2 !== "") {
      return `\\\\${hostname2}${pathname}`;
    } else {
      const letter = pathname.codePointAt(1) | 32;
      const sep = pathname[2];
      if (letter < CHAR_LOWERCASE_A2 || letter > CHAR_LOWERCASE_Z2 || // a..z A..Z
      sep !== ":") {
        throw new Deno.errors.InvalidData("file url path must be absolute");
      }
      return pathname.slice(1);
    }
  }
  function getPathFromURLPosix2(url) {
    if (url.hostname !== "") {
      throw new Deno.errors.InvalidData("invalid file url hostname");
    }
    const pathname = url.pathname;
    for (let n5 = 0; n5 < pathname.length; n5++) {
      if (pathname[n5] === "%") {
        const third = pathname.codePointAt(n5 + 2) || 32;
        if (pathname[n5 + 1] === "2" && third === 102) {
          throw new Deno.errors.InvalidData(
            "must not include encoded / characters"
          );
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFileURL2(filepath) {
    let resolved = exports19.resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if ((filePathLast === CHAR_FORWARD_SLASH2 || isWindows2 && filePathLast === CHAR_BACKWARD_SLASH2) && resolved[resolved.length - 1] !== exports19.sep) {
      resolved += "/";
    }
    const outURL = new URL("file://");
    if (resolved.includes("%")) resolved = resolved.replace(percentRegEx2, "%25");
    if (!isWindows2 && resolved.includes("\\")) {
      resolved = resolved.replace(backslashRegEx2, "%5C");
    }
    if (resolved.includes("\n")) resolved = resolved.replace(newlineRegEx2, "%0A");
    if (resolved.includes("\r")) {
      resolved = resolved.replace(carriageReturnRegEx2, "%0D");
    }
    if (resolved.includes("	")) resolved = resolved.replace(tabRegEx2, "%09");
    outURL.pathname = resolved;
    return outURL;
  }
  var empty, exports$86, _dewExec$76, _global8, exports$77, _dewExec$67, exports$67, _dewExec$57, exports$57, _dewExec$47, exports$47, _dewExec$37, exports$38, _dewExec$29, exports$211, _dewExec$111, exports$115, _dewExec19, exports20, processPlatform2, Url, format2, resolve, resolveObject, parse2, _URL, CHAR_BACKWARD_SLASH2, CHAR_FORWARD_SLASH2, CHAR_LOWERCASE_A2, CHAR_LOWERCASE_Z2, isWindows2, forwardSlashRegEx2, percentRegEx2, backslashRegEx2, newlineRegEx2, carriageReturnRegEx2, tabRegEx2;
  var init_url = __esm({
    "../../node_modules/@jspm/core/nodelibs/browser/url.js"() {
      init_buffer2();
      init_punycode();
      init_chunk_DtcTpLWz();
      init_chunk_BlJi4mNy();
      init_chunk_DEMDiNwt();
      empty = Object.freeze(/* @__PURE__ */ Object.create(null));
      exports$86 = {};
      _dewExec$76 = false;
      _global8 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$77 = {};
      _dewExec$67 = false;
      exports$67 = {};
      _dewExec$57 = false;
      exports$57 = {};
      _dewExec$47 = false;
      exports$47 = {};
      _dewExec$37 = false;
      exports$38 = {};
      _dewExec$29 = false;
      exports$211 = {};
      _dewExec$111 = false;
      exports$115 = {};
      _dewExec19 = false;
      exports20 = dew19();
      exports20["parse"];
      exports20["resolve"];
      exports20["resolveObject"];
      exports20["format"];
      exports20["Url"];
      processPlatform2 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
      exports20.URL = typeof URL !== "undefined" ? URL : null;
      exports20.pathToFileURL = pathToFileURL2;
      exports20.fileURLToPath = fileURLToPath2;
      Url = exports20.Url;
      format2 = exports20.format;
      resolve = exports20.resolve;
      resolveObject = exports20.resolveObject;
      parse2 = exports20.parse;
      _URL = exports20.URL;
      CHAR_BACKWARD_SLASH2 = 92;
      CHAR_FORWARD_SLASH2 = 47;
      CHAR_LOWERCASE_A2 = 97;
      CHAR_LOWERCASE_Z2 = 122;
      isWindows2 = processPlatform2 === "win32";
      forwardSlashRegEx2 = /\//g;
      percentRegEx2 = /%/g;
      backslashRegEx2 = /\\/g;
      newlineRegEx2 = /\n/g;
      carriageReturnRegEx2 = /\r/g;
      tabRegEx2 = /\t/g;
    }
  });

  // ../../node_modules/eventsource/lib/eventsource.js
  var require_eventsource = __commonJS({
    "../../node_modules/eventsource/lib/eventsource.js"(exports21, module) {
      init_buffer2();
      var parse3 = (init_url(), __toCommonJS(url_exports)).parse;
      var events = (init_events(), __toCommonJS(events_exports));
      var https = (init_https(), __toCommonJS(https_exports));
      var http = (init_http(), __toCommonJS(http_exports));
      var util = (init_util(), __toCommonJS(util_exports));
      var httpsOptions = [
        "pfx",
        "key",
        "passphrase",
        "cert",
        "ca",
        "ciphers",
        "rejectUnauthorized",
        "secureProtocol",
        "servername",
        "checkServerIdentity"
      ];
      var bom = [239, 187, 191];
      var colon = 58;
      var space = 32;
      var lineFeed = 10;
      var carriageReturn = 13;
      var maxBufferAheadAllocation = 1024 * 256;
      var reUnsafeHeader = /^(cookie|authorization)$/i;
      function hasBom(buf) {
        return bom.every(function(charCode, index) {
          return buf[index] === charCode;
        });
      }
      function EventSource(url, eventSourceInitDict) {
        var readyState = EventSource.CONNECTING;
        var headers = eventSourceInitDict && eventSourceInitDict.headers;
        var hasNewOrigin = false;
        Object.defineProperty(this, "readyState", {
          get: function() {
            return readyState;
          }
        });
        Object.defineProperty(this, "url", {
          get: function() {
            return url;
          }
        });
        var self2 = this;
        self2.reconnectInterval = 1e3;
        self2.connectionInProgress = false;
        function onConnectionClosed(message) {
          if (readyState === EventSource.CLOSED) return;
          readyState = EventSource.CONNECTING;
          _emit("error", new Event("error", { message }));
          if (reconnectUrl) {
            url = reconnectUrl;
            reconnectUrl = null;
            hasNewOrigin = false;
          }
          setTimeout(function() {
            if (readyState !== EventSource.CONNECTING || self2.connectionInProgress) {
              return;
            }
            self2.connectionInProgress = true;
            connect();
          }, self2.reconnectInterval);
        }
        var req;
        var lastEventId = "";
        if (headers && headers["Last-Event-ID"]) {
          lastEventId = headers["Last-Event-ID"];
          delete headers["Last-Event-ID"];
        }
        var discardTrailingNewline = false;
        var data = "";
        var eventName = "";
        var reconnectUrl = null;
        function connect() {
          var options = parse3(url);
          var isSecure = options.protocol === "https:";
          options.headers = { "Cache-Control": "no-cache", "Accept": "text/event-stream" };
          if (lastEventId) options.headers["Last-Event-ID"] = lastEventId;
          if (headers) {
            var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;
            for (var i5 in reqHeaders) {
              var header = reqHeaders[i5];
              if (header) {
                options.headers[i5] = header;
              }
            }
          }
          options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);
          if (eventSourceInitDict && eventSourceInitDict.createConnection !== void 0) {
            options.createConnection = eventSourceInitDict.createConnection;
          }
          var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;
          if (useProxy) {
            var proxy = parse3(eventSourceInitDict.proxy);
            isSecure = proxy.protocol === "https:";
            options.protocol = isSecure ? "https:" : "http:";
            options.path = url;
            options.headers.Host = options.host;
            options.hostname = proxy.hostname;
            options.host = proxy.host;
            options.port = proxy.port;
          }
          if (eventSourceInitDict && eventSourceInitDict.https) {
            for (var optName in eventSourceInitDict.https) {
              if (httpsOptions.indexOf(optName) === -1) {
                continue;
              }
              var option = eventSourceInitDict.https[optName];
              if (option !== void 0) {
                options[optName] = option;
              }
            }
          }
          if (eventSourceInitDict && eventSourceInitDict.withCredentials !== void 0) {
            options.withCredentials = eventSourceInitDict.withCredentials;
          }
          req = (isSecure ? https : http).request(options, function(res) {
            self2.connectionInProgress = false;
            if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {
              _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage }));
              onConnectionClosed();
              return;
            }
            if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {
              var location2 = res.headers.location;
              if (!location2) {
                _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage }));
                return;
              }
              var prevOrigin = new URL(url).origin;
              var nextOrigin = new URL(location2).origin;
              hasNewOrigin = prevOrigin !== nextOrigin;
              if (res.statusCode === 307) reconnectUrl = url;
              url = location2;
              process.nextTick(connect);
              return;
            }
            if (res.statusCode !== 200) {
              _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage }));
              return self2.close();
            }
            readyState = EventSource.OPEN;
            res.on("close", function() {
              res.removeAllListeners("close");
              res.removeAllListeners("end");
              onConnectionClosed();
            });
            res.on("end", function() {
              res.removeAllListeners("close");
              res.removeAllListeners("end");
              onConnectionClosed();
            });
            _emit("open", new Event("open"));
            var buf;
            var newBuffer;
            var startingPos = 0;
            var startingFieldLength = -1;
            var newBufferSize = 0;
            var bytesUsed = 0;
            res.on("data", function(chunk) {
              if (!buf) {
                buf = chunk;
                if (hasBom(buf)) {
                  buf = buf.slice(bom.length);
                }
                bytesUsed = buf.length;
              } else {
                if (chunk.length > buf.length - bytesUsed) {
                  newBufferSize = buf.length * 2 + chunk.length;
                  if (newBufferSize > maxBufferAheadAllocation) {
                    newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation;
                  }
                  newBuffer = Buffer2.alloc(newBufferSize);
                  buf.copy(newBuffer, 0, 0, bytesUsed);
                  buf = newBuffer;
                }
                chunk.copy(buf, bytesUsed);
                bytesUsed += chunk.length;
              }
              var pos = 0;
              var length = bytesUsed;
              while (pos < length) {
                if (discardTrailingNewline) {
                  if (buf[pos] === lineFeed) {
                    ++pos;
                  }
                  discardTrailingNewline = false;
                }
                var lineLength = -1;
                var fieldLength = startingFieldLength;
                var c5;
                for (var i6 = startingPos; lineLength < 0 && i6 < length; ++i6) {
                  c5 = buf[i6];
                  if (c5 === colon) {
                    if (fieldLength < 0) {
                      fieldLength = i6 - pos;
                    }
                  } else if (c5 === carriageReturn) {
                    discardTrailingNewline = true;
                    lineLength = i6 - pos;
                  } else if (c5 === lineFeed) {
                    lineLength = i6 - pos;
                  }
                }
                if (lineLength < 0) {
                  startingPos = length - pos;
                  startingFieldLength = fieldLength;
                  break;
                } else {
                  startingPos = 0;
                  startingFieldLength = -1;
                }
                parseEventStreamLine(buf, pos, fieldLength, lineLength);
                pos += lineLength + 1;
              }
              if (pos === length) {
                buf = void 0;
                bytesUsed = 0;
              } else if (pos > 0) {
                buf = buf.slice(pos, bytesUsed);
                bytesUsed = buf.length;
              }
            });
          });
          req.on("error", function(err) {
            self2.connectionInProgress = false;
            onConnectionClosed(err.message);
          });
          if (req.setNoDelay) req.setNoDelay(true);
          req.end();
        }
        connect();
        function _emit() {
          if (self2.listeners(arguments[0]).length > 0) {
            self2.emit.apply(self2, arguments);
          }
        }
        this._close = function() {
          if (readyState === EventSource.CLOSED) return;
          readyState = EventSource.CLOSED;
          if (req.abort) req.abort();
          if (req.xhr && req.xhr.abort) req.xhr.abort();
        };
        function parseEventStreamLine(buf, pos, fieldLength, lineLength) {
          if (lineLength === 0) {
            if (data.length > 0) {
              var type2 = eventName || "message";
              _emit(type2, new MessageEvent(type2, {
                data: data.slice(0, -1),
                // remove trailing newline
                lastEventId,
                origin: new URL(url).origin
              }));
              data = "";
            }
            eventName = void 0;
          } else if (fieldLength > 0) {
            var noValue = fieldLength < 0;
            var step = 0;
            var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();
            if (noValue) {
              step = lineLength;
            } else if (buf[pos + fieldLength + 1] !== space) {
              step = fieldLength + 1;
            } else {
              step = fieldLength + 2;
            }
            pos += step;
            var valueLength = lineLength - step;
            var value = buf.slice(pos, pos + valueLength).toString();
            if (field === "data") {
              data += value + "\n";
            } else if (field === "event") {
              eventName = value;
            } else if (field === "id") {
              lastEventId = value;
            } else if (field === "retry") {
              var retry = parseInt(value, 10);
              if (!Number.isNaN(retry)) {
                self2.reconnectInterval = retry;
              }
            }
          }
        }
      }
      module.exports = EventSource;
      util.inherits(EventSource, events.EventEmitter);
      EventSource.prototype.constructor = EventSource;
      ["open", "error", "message"].forEach(function(method) {
        Object.defineProperty(EventSource.prototype, "on" + method, {
          /**
           * Returns the current listener
           *
           * @return {Mixed} the set function or undefined
           * @api private
           */
          get: function get3() {
            var listener = this.listeners(method)[0];
            return listener ? listener._listener ? listener._listener : listener : void 0;
          },
          /**
           * Start listening for events
           *
           * @param {Function} listener the listener
           * @return {Mixed} the set function or undefined
           * @api private
           */
          set: function set(listener) {
            this.removeAllListeners(method);
            this.addEventListener(method, listener);
          }
        });
      });
      Object.defineProperty(EventSource, "CONNECTING", { enumerable: true, value: 0 });
      Object.defineProperty(EventSource, "OPEN", { enumerable: true, value: 1 });
      Object.defineProperty(EventSource, "CLOSED", { enumerable: true, value: 2 });
      EventSource.prototype.CONNECTING = 0;
      EventSource.prototype.OPEN = 1;
      EventSource.prototype.CLOSED = 2;
      EventSource.prototype.close = function() {
        this._close();
      };
      EventSource.prototype.addEventListener = function addEventListener(type2, listener) {
        if (typeof listener === "function") {
          listener._listener = listener;
          this.on(type2, listener);
        }
      };
      EventSource.prototype.dispatchEvent = function dispatchEvent(event) {
        if (!event.type) {
          throw new Error("UNSPECIFIED_EVENT_TYPE_ERR");
        }
        this.emit(event.type, event.detail);
      };
      EventSource.prototype.removeEventListener = function removeEventListener(type2, listener) {
        if (typeof listener === "function") {
          listener._listener = void 0;
          this.removeListener(type2, listener);
        }
      };
      function Event(type2, optionalProperties) {
        Object.defineProperty(this, "type", { writable: false, value: type2, enumerable: true });
        if (optionalProperties) {
          for (var f5 in optionalProperties) {
            if (optionalProperties.hasOwnProperty(f5)) {
              Object.defineProperty(this, f5, { writable: false, value: optionalProperties[f5], enumerable: true });
            }
          }
        }
      }
      function MessageEvent(type2, eventInitDict) {
        Object.defineProperty(this, "type", { writable: false, value: type2, enumerable: true });
        for (var f5 in eventInitDict) {
          if (eventInitDict.hasOwnProperty(f5)) {
            Object.defineProperty(this, f5, { writable: false, value: eventInitDict[f5], enumerable: true });
          }
        }
      }
      function removeUnsafeHeaders(headers) {
        var safe = {};
        for (var key in headers) {
          if (reUnsafeHeader.test(key)) {
            continue;
          }
          safe[key] = headers[key];
        }
        return safe;
      }
    }
  });

  // ../binding-http/dist/subscription-protocols.js
  var require_subscription_protocols = __commonJS({
    "../binding-http/dist/subscription-protocols.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.SSESubscription = exports21.LongPollingSubscription = void 0;
      var eventsource_1 = __importDefault(require_eventsource());
      var core_1 = require_core3();
      var stream_1 = (init_stream(), __toCommonJS(stream_exports));
      var { debug } = (0, core_1.createLoggers)("binding-http", "subscription-protocols");
      var LongPollingSubscription = class {
        constructor(form, client) {
          this.form = form;
          this.client = client;
          this.closed = false;
          this.abortController = new AbortController();
        }
        open(next, error, complete) {
          return new Promise((resolve2, reject) => {
            const polling = async (handshake) => {
              try {
                if (handshake) {
                  const headRequest = await this.client["generateFetchRequest"](this.form, "HEAD", {
                    timeout: 1e3,
                    signal: this.abortController.signal
                  });
                  const result2 = await this.client["doFetch"](headRequest);
                  if (result2.ok)
                    resolve2();
                }
                const request3 = await this.client["generateFetchRequest"](this.form, "GET", {
                  timeout: 60 * 60 * 1e3,
                  signal: this.abortController.signal
                });
                debug(`HttpClient (subscribeResource) sending ${request3.method} to ${request3.url}`);
                const result = await this.client["doFetch"](request3);
                this.client["checkFetchResponse"](result);
                debug(`HttpClient received ${result.status} from ${request3.url}`);
                debug(`HttpClient received headers: ${JSON.stringify(result.headers.raw())}`);
                debug(`HttpClient received Content-Type: ${result.headers.get("content-type")}`);
                if (!this.closed) {
                  const body = core_1.ProtocolHelpers.toNodeStream(result.body);
                  next(new core_1.Content(result.headers.get("content-type") ?? core_1.ContentSerdes.DEFAULT, body));
                  polling(false);
                }
                complete && complete();
              } catch (e5) {
                const err = e5 instanceof Error ? e5 : new Error(JSON.stringify(e5));
                error && error(err);
                complete && complete();
                reject(e5);
              }
            };
            polling(true);
          });
        }
        close() {
          this.abortController.abort();
          this.closed = true;
        }
      };
      exports21.LongPollingSubscription = LongPollingSubscription;
      var SSESubscription = class {
        constructor(form) {
          this.form = form;
          this.closed = false;
        }
        open(next, error, complete) {
          return new Promise((resolve2, reject) => {
            this.eventSource = new eventsource_1.default(this.form.href);
            this.eventSource.onopen = (event) => {
              debug(`HttpClient (subscribeResource) Server-Sent Event connection is opened to ${this.form.href}`);
              resolve2();
            };
            this.eventSource.onmessage = (event) => {
              debug(`HttpClient received ${JSON.stringify(event)} from ${this.form.href}`);
              const output = new core_1.Content(this.form.contentType ?? core_1.ContentSerdes.DEFAULT, stream_1.Readable.from(event.data));
              next(output);
            };
            this.eventSource.onerror = function(event) {
              error?.(new Error(event.toString()));
              complete && complete();
              reject(event.toString());
            };
          });
        }
        close() {
          this.eventSource?.close();
        }
      };
      exports21.SSESubscription = SSESubscription;
    }
  });

  // ../binding-http/dist/http-client-impl.js
  var require_http_client_impl = __commonJS({
    "../binding-http/dist/http-client-impl.js"(exports21) {
      "use strict";
      init_buffer2();
      var __createBinding = exports21 && exports21.__createBinding || (Object.create ? function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m4, k3);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k3];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o5[k22] = m4[k3];
      });
      var __setModuleDefault = exports21 && exports21.__setModuleDefault || (Object.create ? function(o5, v5) {
        Object.defineProperty(o5, "default", { enumerable: true, value: v5 });
      } : function(o5, v5) {
        o5["default"] = v5;
      });
      var __importStar = exports21 && exports21.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o5) {
          ownKeys = Object.getOwnPropertyNames || function(o6) {
            var ar = [];
            for (var k3 in o6) if (Object.prototype.hasOwnProperty.call(o6, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o5);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i5 = 0; i5 < k3.length; i5++) if (k3[i5] !== "default") __createBinding(result, mod, k3[i5]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      var http = __importStar((init_http(), __toCommonJS(http_exports)));
      var https = __importStar((init_https(), __toCommonJS(https_exports)));
      var Subscription_1 = require_Subscription();
      var core_1 = require_core3();
      var node_fetch_1 = __importStar(require_browser2());
      var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));
      var oauth_manager_1 = __importDefault(require_oauth_manager());
      var credential_1 = require_credential();
      var subscription_protocols_1 = require_subscription_protocols();
      var { debug, warn, error } = (0, core_1.createLoggers)("binding-http", "http-client-impl");
      var HttpClient = class _HttpClient {
        constructor(config2 = null, secure = false, oauthManager = new oauth_manager_1.default()) {
          this.proxyRequest = null;
          this.allowSelfSigned = false;
          this.credential = null;
          this.activeSubscriptions = /* @__PURE__ */ new Map();
          if (config2 !== null && config2.proxy && config2.proxy.href) {
            this.proxyRequest = new node_fetch_1.Request(_HttpClient.fixLocalhostName(config2.proxy.href));
            if (config2.proxy.scheme === "basic") {
              if (!Object.prototype.hasOwnProperty.call(config2.proxy, "username") || !Object.prototype.hasOwnProperty.call(config2.proxy, "password"))
                warn("HttpClient client configured for basic proxy auth, but no username/password given");
              this.proxyRequest.headers.set("proxy-authorization", "Basic " + buffer_1.Buffer.from(config2.proxy.username + ":" + config2.proxy.password).toString("base64"));
            } else if (config2.proxy.scheme === "bearer") {
              if (!Object.prototype.hasOwnProperty.call(config2.proxy, "token"))
                warn("HttpClient client configured for bearer proxy auth, but no token given");
              this.proxyRequest.headers.set("proxy-authorization", "Bearer " + config2.proxy.token);
            }
            if (this.proxyRequest.protocol === "https") {
              secure = true;
            }
            debug(`HttpClient using ${secure ? "secure " : ""}proxy ${this.proxyRequest.hostname}:${this.proxyRequest.port}`);
          }
          if (config2 !== null && config2.allowSelfSigned !== void 0) {
            this.allowSelfSigned = config2.allowSelfSigned;
            warn(`HttpClient allowing self-signed/untrusted certificates -- USE FOR TESTING ONLY`);
          }
          this.agent = secure ? new https.Agent({
            rejectUnauthorized: !this.allowSelfSigned
          }) : new http.Agent();
          this.provider = secure ? "https" : "http";
          this.oauth = oauthManager;
        }
        toString() {
          return `[HttpClient]`;
        }
        async readResource(form) {
          const headers = form.contentType != null ? [["accept", form.contentType]] : [["accept", core_1.ContentSerdes.DEFAULT]];
          const request3 = await this.generateFetchRequest(form, "GET", { headers });
          debug(`HttpClient (readResource) sending ${request3.method} to ${request3.url}`);
          const result = await this.doFetch(request3);
          this.checkFetchResponse(result);
          debug(`HttpClient received headers: ${JSON.stringify(result.headers.raw())}`);
          debug(`HttpClient received Content-Type: ${result.headers.get("content-type")}`);
          const body = core_1.ProtocolHelpers.toNodeStream(result.body);
          return new core_1.Content(result.headers.get("content-type") ?? core_1.ContentSerdes.DEFAULT, body);
        }
        async writeResource(form, content) {
          const request3 = await this.generateFetchRequest(form, "PUT", {
            headers: [["content-type", content.type]],
            body: content.body
          });
          debug(`HttpClient (writeResource) sending ${request3.method} with '${request3.headers.get("Content-Type")}' to ${request3.url}`);
          const result = await this.doFetch(request3);
          debug(`HttpClient received ${result.status} from ${result.url}`);
          this.checkFetchResponse(result);
          debug(`HttpClient received headers: ${JSON.stringify(result.headers.raw())}`);
        }
        async subscribeResource(form, next, error2, complete) {
          const defaultSubprotocol = "longpoll";
          let subprotocol = form.subprotocol;
          if (subprotocol == null) {
            warn(`Subscribing to ${form.href} using long polling for form without subprotocol`);
            subprotocol = defaultSubprotocol;
          }
          let internalSubscription;
          if (subprotocol === defaultSubprotocol) {
            internalSubscription = new subscription_protocols_1.LongPollingSubscription(form, this);
          } else if (form.subprotocol === "sse") {
            internalSubscription = new subscription_protocols_1.SSESubscription(form);
          } else {
            throw new Error(`HttpClient does not support subprotocol ${form.subprotocol}`);
          }
          await internalSubscription.open(next, error2, complete);
          this.activeSubscriptions.set(form.href, internalSubscription);
          return new Subscription_1.Subscription(() => {
            internalSubscription.close();
          });
        }
        async invokeResource(form, content) {
          const headers = content != null ? [["content-type", content.type]] : [];
          if (form.response?.contentType != null) {
            headers.push(["accept", form.response?.contentType]);
          } else if (form.contentType != null) {
            headers.push(["accept", form.contentType]);
          } else {
            headers.push(["accept", core_1.ContentSerdes.DEFAULT]);
          }
          const request3 = await this.generateFetchRequest(form, "POST", {
            headers,
            body: content?.body
          });
          debug(`HttpClient (invokeResource) sending ${request3.method} ${content != null ? `with '"${request3.headers.get("Content-Type")}"` : ""} to ${request3.url}`);
          const result = await this.doFetch(request3);
          debug(`HttpClient received ${result.status} from ${request3.url}`);
          debug(`HttpClient received Content-Type: ${result.headers.get("content-type")}`);
          this.checkFetchResponse(result);
          const body = core_1.ProtocolHelpers.toNodeStream(result.body);
          return new core_1.Content(result.headers.get("content-type") ?? core_1.ContentSerdes.DEFAULT, body);
        }
        async unlinkResource(form) {
          debug(`HttpClient (unlinkResource) ${form.href}`);
          const internalSub = this.activeSubscriptions.get(form.href);
          if (internalSub) {
            internalSub.close();
          } else {
            warn(`HttpClient cannot unlink ${form.href} no subscription found`);
          }
        }
        async requestThingDescription(uri) {
          const headers = {
            Accept: "application/td+json"
          };
          const request3 = await this.generateFetchRequest({ href: uri }, "GET", headers);
          const response = await this.doFetch(request3);
          const body = core_1.ProtocolHelpers.toNodeStream(response.body);
          return new core_1.Content(response.headers.get("content-type") ?? "application/td+json", body);
        }
        async start() {
        }
        async stop() {
          this.agent?.destroy?.();
        }
        setSecurity(metadata, credentials) {
          if (metadata === void 0 || !Array.isArray(metadata) || metadata.length === 0) {
            warn("HttpClient without security");
            return false;
          }
          const security = metadata[0];
          switch (security.scheme) {
            case "basic": {
              const securityBasic = security;
              this.credential = new credential_1.BasicCredential(credentials, securityBasic);
              break;
            }
            case "bearer": {
              const securityBearer = security;
              this.credential = new credential_1.BearerCredential(credentials, securityBearer);
              break;
            }
            case "apikey": {
              const securityAPIKey = security;
              this.credential = new credential_1.BasicKeyCredential(credentials, securityAPIKey);
              break;
            }
            case "oauth2": {
              const securityOAuth = security;
              if (securityOAuth.flow === "client") {
                securityOAuth.flow = "client_credentials";
                this.credential = this.oauth.handleClient(securityOAuth, credentials);
              } else if (securityOAuth.flow === "password") {
                this.credential = this.oauth.handleResourceOwnerCredential(securityOAuth, credentials);
              }
              break;
            }
            case "TuyaCustomBearer": {
              this.credential = new credential_1.TuyaCustomBearer(credentials, security);
              break;
            }
            case "nosec":
              break;
            default:
              error(`HttpClient cannot set security scheme '${security.scheme}'. ${metadata}`);
              return false;
          }
          if (security.proxy != null) {
            if (this.proxyRequest !== null) {
              debug(`HttpClient overriding client-side proxy with security proxy '${security.proxy}`);
            }
            this.proxyRequest = new node_fetch_1.Request(_HttpClient.fixLocalhostName(security.proxy));
            if (security.scheme === "basic") {
              const basicCredential = credentials;
              if (basicCredential === void 0 || basicCredential.username === void 0 || basicCredential.password === void 0) {
                throw new Error(`No Basic credentials for Thing`);
              }
              this.proxyRequest.headers.set("proxy-authorization", "Basic " + buffer_1.Buffer.from(basicCredential.username + ":" + basicCredential.password).toString("base64"));
            } else if (security.scheme === "bearer") {
              const tokenCredentials = credentials;
              if (credentials === void 0 || tokenCredentials.token === void 0) {
                throw new Error(`No Bearer credentials for Thing`);
              }
              this.proxyRequest.headers.set("proxy-authorization", "Bearer " + tokenCredentials.token);
            }
          }
          debug(`HttpClient using security scheme '${security.scheme}'`);
          return true;
        }
        async generateFetchRequest(form, defaultMethod, additionalOptions = {}) {
          const requestInit = additionalOptions;
          const url = _HttpClient.fixLocalhostName(form.href);
          requestInit.method = form["htv:methodName"] ? form["htv:methodName"] : defaultMethod;
          requestInit.headers = requestInit.headers ?? [];
          requestInit.headers = requestInit.headers;
          if (Array.isArray(form["htv:headers"])) {
            debug(`HttpClient got Form 'headers' ${form["htv:headers"]}`);
            const headers = form["htv:headers"];
            for (const option of headers) {
              requestInit.headers = requestInit.headers.filter((header) => header[0].toLowerCase() !== option["htv:fieldName"].toLowerCase());
              requestInit.headers.push([option["htv:fieldName"], option["htv:fieldValue"]]);
            }
          } else if (typeof form["htv:headers"] === "object") {
            debug(`HttpClient got Form SINGLE-ENTRY 'headers' ${form["htv:headers"]}`);
            const option = form["htv:headers"];
            requestInit.headers = requestInit.headers.filter((header) => header[0].toLowerCase() !== option["htv:fieldName"].toLowerCase());
            requestInit.headers.push([option["htv:fieldName"], option["htv:fieldValue"]]);
          }
          requestInit.agent = this.agent;
          let request3 = this.proxyRequest ? new node_fetch_1.Request(this.proxyRequest, requestInit) : new node_fetch_1.Request(url, requestInit);
          if (this.credential) {
            request3 = await this.credential.sign(request3);
          }
          if (this.proxyRequest) {
            const parsedBaseURL = new URL(url);
            request3.url = request3.url + parsedBaseURL.pathname;
            debug(`HttpClient proxy request URL: ${request3.url}`);
            request3.headers.set("host", parsedBaseURL.hostname);
          }
          return request3;
        }
        _fetch(request3) {
          return (0, node_fetch_1.default)(request3, { body: request3.body });
        }
        async doFetch(request3) {
          const result = await this._fetch(request3);
          if (_HttpClient.isOAuthTokenExpired(result, this.credential)) {
            this.credential = await this.credential.refreshToken();
            return await this._fetch(await this.credential.sign(request3));
          }
          return result;
        }
        checkFetchResponse(response) {
          const statusCode = response.status;
          if (statusCode < 200) {
            throw new Error(`HttpClient received ${statusCode} and cannot continue (not implemented, open GitHub Issue)`);
          } else if (statusCode < 300) {
          } else if (statusCode < 400) {
            throw new Error(`HttpClient received ${statusCode} and cannot continue (not implemented, open GitHub Issue)`);
          } else if (statusCode < 500) {
            throw new Error(`Client error: ${response.statusText}`);
          } else {
            throw new Error(`Server error: ${response.statusText}`);
          }
        }
        static isOAuthTokenExpired(result, credential) {
          return result.status === 401 && credential instanceof credential_1.OAuthCredential;
        }
        static fixLocalhostName(url) {
          const localhostPresent = /^(https?:)?(\/\/)?(?:[^@\n]+@)?(www\.)?(localhost)/gm;
          if (localhostPresent.test(url)) {
            warn("LOCALHOST FIX");
            return url.replace(localhostPresent, "$1$2127.0.0.1");
          }
          return url;
        }
      };
      exports21.default = HttpClient;
    }
  });

  // ../binding-http/dist/http-client-browser.js
  var require_http_client_browser = __commonJS({
    "../binding-http/dist/http-client-browser.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      var core_1 = require_core3();
      var node_fetch_1 = __importDefault(require_browser2());
      var stream_1 = (init_stream(), __toCommonJS(stream_exports));
      var http_client_impl_1 = __importDefault(require_http_client_impl());
      var BrowserHttpClient = class extends http_client_impl_1.default {
        async generateFetchRequest(form, defaultMethod, additionalOptions) {
          if (additionalOptions?.body instanceof stream_1.Readable) {
            const buffer2 = await core_1.ProtocolHelpers.readStreamFully(additionalOptions.body);
            additionalOptions.body = buffer2;
          }
          return super.generateFetchRequest(form, defaultMethod, additionalOptions);
        }
        async _fetch(request3) {
          return (0, node_fetch_1.default)(request3);
        }
      };
      exports21.default = BrowserHttpClient;
    }
  });

  // ../binding-http/dist/http-client-factory.js
  var require_http_client_factory = __commonJS({
    "../binding-http/dist/http-client-factory.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      var core_1 = require_core3();
      var http_client_1 = __importDefault(require_http_client_browser());
      var oauth_manager_1 = __importDefault(require_oauth_manager());
      var { debug, warn } = (0, core_1.createLoggers)("binding-http", "http-client-factory");
      var HttpClientFactory = class {
        constructor(config2 = null) {
          this.scheme = "http";
          this.config = null;
          this.oAuthManager = new oauth_manager_1.default();
          this.config = config2;
        }
        getClient() {
          if (this.config && this.config.proxy && this.config.proxy.href && this.config.proxy.href.startsWith("https:")) {
            warn("HttpClientFactory creating client for 'https' due to secure proxy configuration");
            return new http_client_1.default(this.config, true, this.oAuthManager);
          } else {
            debug(`HttpClientFactory creating client for '${this.scheme}'`);
            return new http_client_1.default(this.config);
          }
        }
        init() {
          return true;
        }
        destroy() {
          return true;
        }
      };
      exports21.default = HttpClientFactory;
    }
  });

  // ../binding-http/dist/https-client-factory.js
  var require_https_client_factory = __commonJS({
    "../binding-http/dist/https-client-factory.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      var core_1 = require_core3();
      var http_client_1 = __importDefault(require_http_client_browser());
      var { debug, warn } = (0, core_1.createLoggers)("binding-http", "https-client-factory");
      var HttpsClientFactory = class {
        constructor(config2 = null) {
          this.scheme = "https";
          this.config = null;
          this.config = config2;
        }
        getClient() {
          if (this.config && this.config.proxy && this.config.proxy.href && this.config.proxy.href.startsWith("http:")) {
            warn("HttpsClientFactory creating client for 'http' due to insecure proxy configuration");
            return new http_client_1.default(this.config);
          } else {
            debug(`HttpsClientFactory creating client for '${this.scheme}'`);
            return new http_client_1.default(this.config, true);
          }
        }
        init() {
          return true;
        }
        destroy() {
          return true;
        }
      };
      exports21.default = HttpsClientFactory;
    }
  });

  // ../binding-http/dist/http-browser.js
  var require_http_browser = __commonJS({
    "../binding-http/dist/http-browser.js"(exports21) {
      "use strict";
      init_buffer2();
      var __createBinding = exports21 && exports21.__createBinding || (Object.create ? function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m4, k3);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k3];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o5[k22] = m4[k3];
      });
      var __exportStar = exports21 && exports21.__exportStar || function(m4, exports22) {
        for (var p5 in m4) if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports22, p5)) __createBinding(exports22, m4, p5);
      };
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.HttpForm = exports21.HttpHeader = exports21.HttpsClientFactory = exports21.HttpClientFactory = exports21.HttpClient = void 0;
      var core_1 = require_core3();
      var node_fetch_1 = require_browser2();
      var http_client_1 = require_http_client_browser();
      Object.defineProperty(exports21, "HttpClient", { enumerable: true, get: function() {
        return __importDefault(http_client_1).default;
      } });
      var http_client_factory_1 = require_http_client_factory();
      Object.defineProperty(exports21, "HttpClientFactory", { enumerable: true, get: function() {
        return __importDefault(http_client_factory_1).default;
      } });
      var https_client_factory_1 = require_https_client_factory();
      Object.defineProperty(exports21, "HttpsClientFactory", { enumerable: true, get: function() {
        return __importDefault(https_client_factory_1).default;
      } });
      __exportStar(require_http_client_browser(), exports21);
      __exportStar(require_http_client_factory(), exports21);
      __exportStar(require_https_client_factory(), exports21);
      var HttpHeader = class {
      };
      exports21.HttpHeader = HttpHeader;
      var HttpForm = class extends core_1.Form {
      };
      exports21.HttpForm = HttpForm;
      node_fetch_1.Headers.prototype.raw = function() {
        const result = {};
        for (const [headerKey, headerValue] of this.entries()) {
          result[headerKey] = headerValue.split(",");
        }
        return result;
      };
      node_fetch_1.Response.prototype.buffer = async function() {
        return Buffer2.from(await this.arrayBuffer());
      };
    }
  });

  // ../binding-websockets/dist/ws-client.js
  var require_ws_client = __commonJS({
    "../binding-websockets/dist/ws-client.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var core_1 = require_core3();
      var { debug, warn } = (0, core_1.createLoggers)("binding-websockets", "ws-client");
      var WebSocketClient = class {
        constructor() {
        }
        toString() {
          return `[WebSocketClient]`;
        }
        readResource(form) {
          return new Promise((resolve2, reject) => {
          });
        }
        writeResource(form, content) {
          return new Promise((resolve2, reject) => {
          });
        }
        invokeResource(form, content) {
          return new Promise((resolve2, reject) => {
          });
        }
        unlinkResource(form) {
          return new Promise((resolve2, reject) => {
          });
        }
        subscribeResource(form, next, error, complete) {
          throw new Error("Websocket client does not implement subscribeResource");
        }
        async requestThingDescription(uri) {
          throw new Error("Method not implemented");
        }
        async start() {
        }
        async stop() {
        }
        setSecurity(metadata, credentials) {
          if (metadata === void 0 || !Array.isArray(metadata) || metadata.length === 0) {
            warn("WebSocketClient received empty security metadata");
            return false;
          }
          const security = metadata[0];
          debug(`WebSocketClient using security scheme '${security.scheme}'`);
          return true;
        }
      };
      exports21.default = WebSocketClient;
    }
  });

  // ../binding-websockets/dist/ws-client-factory.js
  var require_ws_client_factory = __commonJS({
    "../binding-websockets/dist/ws-client-factory.js"(exports21) {
      "use strict";
      init_buffer2();
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      var core_1 = require_core3();
      var ws_client_1 = __importDefault(require_ws_client());
      var { debug } = (0, core_1.createLoggers)("binding-websockets", "ws-client-factory");
      var WebSocketClientFactory = class {
        constructor(proxy = null) {
          this.scheme = "ws";
          this.clientSideProxy = null;
          this.clientSideProxy = proxy;
        }
        getClient() {
          debug(`HttpClientFactory creating client for '${this.scheme}'`);
          return new ws_client_1.default();
        }
        init() {
          return true;
        }
        destroy() {
          return true;
        }
      };
      exports21.default = WebSocketClientFactory;
    }
  });

  // ../binding-websockets/dist/wss-client-factory.js
  var require_wss_client_factory = __commonJS({
    "../binding-websockets/dist/wss-client-factory.js"(exports21) {
      "use strict";
      init_buffer2();
      Object.defineProperty(exports21, "__esModule", { value: true });
      var WssClientFactory = class {
        constructor() {
          this.scheme = "wss";
        }
        getClient() {
          throw new Error("WssClientFactory for 'wss' is not implemented");
        }
        init() {
          return true;
        }
        destroy() {
          return true;
        }
      };
      exports21.default = WssClientFactory;
    }
  });

  // ../binding-websockets/dist/ws-browser.js
  var require_ws_browser = __commonJS({
    "../binding-websockets/dist/ws-browser.js"(exports21) {
      "use strict";
      init_buffer2();
      var __createBinding = exports21 && exports21.__createBinding || (Object.create ? function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m4, k3);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k3];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m4, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o5[k22] = m4[k3];
      });
      var __exportStar = exports21 && exports21.__exportStar || function(m4, exports22) {
        for (var p5 in m4) if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports22, p5)) __createBinding(exports22, m4, p5);
      };
      var __importDefault = exports21 && exports21.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports21, "__esModule", { value: true });
      exports21.WebSocketSecureClientFactory = exports21.WebSocketClientFactory = exports21.WebSocketClient = void 0;
      var ws_client_1 = require_ws_client();
      Object.defineProperty(exports21, "WebSocketClient", { enumerable: true, get: function() {
        return __importDefault(ws_client_1).default;
      } });
      var ws_client_factory_1 = require_ws_client_factory();
      Object.defineProperty(exports21, "WebSocketClientFactory", { enumerable: true, get: function() {
        return __importDefault(ws_client_factory_1).default;
      } });
      var wss_client_factory_1 = require_wss_client_factory();
      Object.defineProperty(exports21, "WebSocketSecureClientFactory", { enumerable: true, get: function() {
        return __importDefault(wss_client_factory_1).default;
      } });
      __exportStar(require_ws_client(), exports21);
      __exportStar(require_ws_client_factory(), exports21);
      __exportStar(require_wss_client_factory(), exports21);
    }
  });

  // index.ts
  var index_exports = {};
  __export(index_exports, {
    Core: () => Core,
    Http: () => Http,
    WebSocket: () => WebSocket
  });
  init_buffer2();
  var Core = __toESM(require_core3());
  var Http = __toESM(require_http_browser());
  var WebSocket = __toESM(require_ws_browser());
  return __toCommonJS(index_exports);
})();
/*! Bundled license information:

@jspm/core/nodelibs/browser/chunk-DtuTasat.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/chunk-CcCWfKp1.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/chunk-B738Er4n.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

web-streams-polyfill/dist/ponyfill.js:
  (**
   * @license
   * web-streams-polyfill v4.1.0
   * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)

content-type/index.js:
  (*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=wot-bundle.js.map
